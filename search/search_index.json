{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Kubernetes GitOps with nix and Argo CD.</p> <p> Getting Started \u2022   Documentation \u2022   Features \u2022   Examples </p>"},{"location":"#why-nixidy","title":"Why Nixidy?","text":"<p>Managing Kubernetes configurations at scale is hard. Helm charts require complex value overrides, Kustomize leads to repetitive overlays, and raw YAML becomes unmaintainable. Reviewing changes across environments is nearly impossible.</p> <p>Nixidy solves this by bringing the power of Nix and the NixOS module system to Kubernetes:</p> <ul> <li>Declarative: Define your entire cluster state in one place</li> <li>Typed: Catch configuration errors before deployment</li> <li>Composable: Build complex configurations from reusable modules</li> <li>Reviewable: Generate plain YAML for easy PR reviews</li> <li>Reproducible: Same input always produces the same output</li> </ul>"},{"location":"#how-it-works","title":"How It Works","text":"<p>Define your Kubernetes resources using Nix:</p> <pre><code>{\n  applications.demo = {\n    namespace = \"demo\";\n    createNamespace = true;\n\n    resources = {\n      deployments.nginx.spec = {\n        replicas = 3;\n        selector.matchLabels.app = \"nginx\";\n        template = {\n          metadata.labels.app = \"nginx\";\n          spec.containers.nginx = {\n            image = \"nginx:1.25.1\";\n            ports.http.containerPort = 80;\n          };\n        };\n      };\n\n      services.nginx.spec = {\n        selector.app = \"nginx\";\n        ports.http.port = 80;\n      };\n    };\n  };\n}\n</code></pre> <p>Build with nixidy:</p> <pre><code>nixidy build .#prod\n</code></pre> <p>Get clean, reviewable YAML:</p> <pre><code>result/\n\u251c\u2500\u2500 apps/\n\u2502   \u2514\u2500\u2500 Application-demo.yaml\n\u2514\u2500\u2500 demo/\n    \u251c\u2500\u2500 Deployment-nginx.yaml\n    \u251c\u2500\u2500 Namespace-demo.yaml\n    \u2514\u2500\u2500 Service-nginx.yaml\n</code></pre> <p>Argo CD picks up the changes, after committing the new manifests to your repository, and deploys to your cluster. That's it.</p>"},{"location":"#features","title":"Features","text":""},{"location":"#declarative-cluster-management","title":"\ud83c\udfaf Declarative Cluster Management","text":"<p>Define your entire cluster state using Nix. No more scattered YAML files, Helm value overrides, or Kustomize patches. Everything in one place, with one language.</p>"},{"location":"#strongly-typed-configuration","title":"\ud83d\udd12 Strongly-Typed Configuration","text":"<p>Every Kubernetes resource is typed. Catch typos and validate configurations before they hit your cluster.</p> <pre><code># This will error at build time, not runtime\nresources.deployments.nginx.spec.replicas = \"three\"; # Type error!\n</code></pre>"},{"location":"#first-class-helm-support","title":"\ud83d\udce6 First-Class Helm Support","text":"<p>Use existing Helm charts without giving up control. Override values, patch resources, and clean up Helm artifacts.</p> <pre><code>applications.traefik = {\n  namespace = \"traefik\";\n\n  helm.releases.traefik = {\n    chart = lib.helm.downloadHelmChart {\n      repo = \"https://traefik.github.io/charts/\";\n      chart = \"traefik\";\n      version = \"25.0.0\";\n      chartHash = \"sha256-ua8KnUB6MxY7APqrrzaKKSOLwSjDYkk9tfVkb1bqkVM=\";\n    };\n    values = {\n      ingressClass.enabled = true;\n    };\n  };\n\n  # Patch Helm output with nixidy\n  resources.deployments.traefik.spec.replicas = lib.mkForce 5;\n};\n</code></pre>"},{"location":"#kustomize-integration","title":"\ud83d\udd27 Kustomize Integration","text":"<p>Seamlessly incorporate Kustomize applications:</p> <pre><code>applications.argocd.kustomize.applications.argocd = {\n  namespace = \"argocd\";\n  kustomization = {\n    src = pkgs.fetchFromGitHub {\n      owner = \"argoproj\";\n      repo = \"argo-cd\";\n      rev = \"v2.9.3\";\n      hash = \"sha256-GaY4Cw/LlSwy35umbB4epXt6ev8ya19UjHRwhDwilqU=\";\n    };\n    path = \"manifests/cluster-install\";\n  };\n};\n</code></pre>"},{"location":"#multi-environment-made-easy","title":"\ud83c\udf0d Multi-Environment Made Easy","text":"<p>Manage dev, staging, and production with shared base configurations and environment-specific overrides:</p> <pre><code># base.nix - shared configuration\n{lib, ...}: {\n  applications.api.resources.deployments.api.spec = {\n    replicas = lib.mkDefault 1;\n    selector.matchLabels.app = \"api\";\n    template.spec.containers.api.image = \"api:latest\";\n  };\n}\n\n# prod.nix - production overrides\n{lib, ...}: {\n  imports = [ ./base.nix ];\n  applications.api.resources.deployments.api.spec = {\n    replicas = lib.mkForce 10;\n    template.spec.containers.api.resources = {\n      requests.memory = \"512Mi\";\n      limits.memory = \"1Gi\";\n    };\n  };\n}\n</code></pre>"},{"location":"#reusable-templates","title":"\ud83c\udfd7\ufe0f Reusable Templates","text":"<p>Create templates for common patterns and reuse them across applications:</p> <pre><code>templates.webApp = {\n  options = {\n    image = mkOption {\n      type = lib.types.str;\n      description = \"The image to use in the web application deployment\";\n    };\n    replicas = mkOption {\n      type = lib.types.int;\n      default = 3;\n      description = \"The number of replicas for the web application deployment.\";\n    };\n    port = mkOption {\n      type = lib.types.port;\n      default = 8080;\n      description = \"The web application's port.\";\n    };\n  };\n  output = { name, config, ... }: {\n    deployments.${name}.spec = {\n      replicas = config.replicas;\n      selector.matchLabels.app = name;\n      template = {\n        metadata.labels.app = name;\n        spec.containers.${name} = {\n          image = config.image;\n          ports.http.containerPort = config.port;\n        };\n      };\n    };\n    services.${name}.spec = {\n      selector.app = name;\n      ports.http.port = config.port;\n    };\n  };\n};\n\n# Use the template\napplications.frontend.templates.webApp.frontend = {\n  image = \"frontend:v1.2.3\";\n  replicas = 5;\n};\n</code></pre>"},{"location":"#gitops-ready","title":"\ud83d\udd04 GitOps Ready","text":"<p>Nixidy implements the Rendered Manifests Pattern. Your CI generates plain YAML, you review the exact changes in PRs, and Argo CD deploys them. No surprises.</p>"},{"location":"#app-of-apps-bootstrap","title":"\ud83d\ude80 App-of-Apps Bootstrap","text":"<p>Bootstrap your entire cluster with a single command:</p> <pre><code>nixidy bootstrap .#prod | kubectl apply -f -\n</code></pre>"},{"location":"#direct-apply","title":"\u26a1 Direct Apply","text":"<p>Skip GitOps if you want to:</p> <pre><code>nixidy apply .#dev\n</code></pre> <p>Uses <code>kubectl apply --prune</code> for safe, declarative deployments directly to your cluster.</p>"},{"location":"#crd-support","title":"\ud83c\udf9b\ufe0f CRD Support","text":"<p>Generate typed Nix options from any Custom Resource Definition:</p> <pre><code>packages.generators.cilium = nixidy.packages.${system}.generators.fromCRD {\n  name = \"cilium\";\n  src = pkgs.fetchFromGitHub { /* ... */ };\n  crds = [\n    \"pkg/k8s/apis/cilium.io/client/crds/v2/ciliumnetworkpolicies.yaml\"\n  ];\n};\n</code></pre> <p>Then use your CRDs with full type safety:</p> <pre><code>resources.ciliumNetworkPolicies.allow-dns.spec = {\n  endpointSelector = {};\n  egress = [{\n    toEndpoints = [{ matchLabels.\"k8s:io.kubernetes.pod.namespace\" = \"kube-system\"; }];\n    toPorts = [{ ports = [{ port = \"53\"; protocol = \"UDP\"; }]; }];\n  }];\n};\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#with-flakes","title":"With Flakes","text":"flake.nix<pre><code>{\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n    nixidy.url = \"github:arnarg/nixidy\";\n  };\n\n  outputs = { nixpkgs, nixidy, ... }: {\n    nixidyEnvs.x86_64-linux = nixidy.lib.mkEnvs {\n      pkgs = nixpkgs.legacyPackages.x86_64-linux;\n      envs.dev.modules = [ ./env/dev.nix ];\n    };\n  };\n}\n</code></pre> env/dev.nix<pre><code>{\n  nixidy.target.repository = \"https://github.com/you/your-repo.git\";\n  nixidy.target.branch = \"main\";\n\n  applications.hello = {\n    namespace = \"hello\";\n    createNamespace = true;\n    resources.deployments.hello.spec = {\n      selector.matchLabels.app = \"hello\";\n      template = {\n        metadata.labels.app = \"hello\";\n        spec.containers.hello.image = \"hello-world:latest\";\n      };\n    };\n  };\n}\n</code></pre> <p>See the Getting Started Guide for detailed setup instructions.</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Getting Started \u2014 Set up your first nixidy project</li> <li>Helm Charts \u2014 Integrate existing Helm charts</li> <li>Templates \u2014 Create reusable application patterns</li> <li>Git Strategies \u2014 Monorepo vs. environment branches</li> <li>GitHub Actions \u2014 CI/CD integration</li> <li>Typed Resources \u2014 Generate types for CRDs</li> </ul>"},{"location":"#examples","title":"Examples","text":"<ul> <li>arnarg/cluster \u2014 Real-world cluster configuration using nixidy</li> </ul>"},{"location":"#comparison","title":"Comparison","text":"Feature nixidy Helm Kustomize Raw YAML Type Safety \u2705 Full \u274c None \u274c None \u274c None Composability \u2705 Modules \u26a0\ufe0f Subcharts \u26a0\ufe0f Overlays \u274c Copy/Paste Helm Integration \u2705 Native \u2705 Native \u26a0\ufe0f Inflate \u274c Manual Reviewable Output \u2705 Plain YAML \u274c Templates \u26a0\ufe0f Patches \u2705 Plain YAML Multi-Environment \u2705 Built-in \u26a0\ufe0f Values files \u26a0\ufe0f Overlays \u274c Manual Reproducibility \u2705 Guaranteed \u26a0\ufe0f Depends \u26a0\ufe0f Depends \u26a0\ufe0f Depends"},{"location":"#community","title":"Community","text":"<ul> <li>Issues: GitHub Issues</li> <li>Discussions: GitHub Discussions</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Whether it's bug reports, feature requests, documentation improvements, or code contributions, please feel free to open an issue or pull request on our GitHub repository.</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<ul> <li>nix-kube-generators \u2014 Used internally for Helm chart rendering</li> <li>kubenix \u2014 Resource options generator forked from kubenix</li> </ul>"},{"location":"#license","title":"License","text":"<p>nixidy is licensed under the MIT License.</p>"},{"location":"cli_reference/","title":"CLI Reference","text":"<p>This page provides documentation for the nixidy command line tool.</p>"},{"location":"cli_reference/#nixidy","title":"nixidy","text":"<p>Usage:</p> <pre><code>nixidy [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre> <p>Subcommands</p> <ul> <li>apply: Build and apply declarative manifests to Kubernetes.</li> <li>bootstrap: Output a manifest to bootstrap appOfApps.</li> <li>build: Build a nixidy environment.</li> <li>diff: Diff environment manifests.</li> <li>info: Get info about a nixidy environment.</li> <li>switch: Build and switch to a nixidy environment.</li> </ul>"},{"location":"cli_reference/#nixidy-apply","title":"nixidy apply","text":"<p>Build and apply declarative manifests to Kubernetes.</p> <p>ENVIRONMENT is used to determine if flakes or flake-less nix should be used and which environment should be built.</p> <p>Example: <code>.#prod</code> Uses a flake in the local directory whereas <code>prod</code> does not use flake but builds the <code>prod</code> environment</p> <p>Usage:</p> <pre><code>nixidy apply [OPTIONS] ENVIRONMENT\n</code></pre> <p>Options:</p> <pre><code>  -f, --file PATH  Path to entrypoint nix file (only flake-less).  [default:\n                   default.nix]\n  --help           Show this message and exit.\n</code></pre>"},{"location":"cli_reference/#nixidy-bootstrap","title":"nixidy bootstrap","text":"<p>Output a manifest to bootstrap appOfApps.</p> <p>ENVIRONMENT is used to determine if flakes or flake-less nix should be used and which environment should be built.</p> <p>Example: <code>.#prod</code> Uses a flake in the local directory whereas <code>prod</code> does not use flake but builds the <code>prod</code> environment</p> <p>Usage:</p> <pre><code>nixidy bootstrap [OPTIONS] ENVIRONMENT\n</code></pre> <p>Options:</p> <pre><code>  -f, --file PATH  Path to entrypoint nix file (only flake-less).  [default:\n                   default.nix]\n  --help           Show this message and exit.\n</code></pre>"},{"location":"cli_reference/#nixidy-build","title":"nixidy build","text":"<p>Build a nixidy environment.</p> <p>ENVIRONMENT is used to determine if flakes or flake-less nix should be used and which environment should be built.</p> <p>Example: <code>.#prod</code> Uses a flake in the local directory whereas <code>prod</code> does not use flake but builds the <code>prod</code> environment</p> <p>Usage:</p> <pre><code>nixidy build [OPTIONS] ENVIRONMENT\n</code></pre> <p>Options:</p> <pre><code>  -f, --file PATH    Path to entrypoint nix file (only flake-less).  [default:\n                     default.nix]\n  --no-link          Don't create a result symlink.\n  --out-link PATH    Create a custom result symlink.\n  --print-out-paths  Print the resulting output paths.\n  --help             Show this message and exit.\n</code></pre>"},{"location":"cli_reference/#nixidy-diff","title":"nixidy diff","text":"<p>Diff environment manifests.</p> <p>ENVIRONMENT is the environment to build and compare with either <code>--path</code> or <code>--env</code>.</p> <p>Use <code>--path</code> to compare with a previously built environment at a specific path.</p> <p>Use <code>--env</code> to build and compare with another environment.</p> <p>Examples:</p> <pre><code># Compare prod with staging environment.\n\nnixidy diff .#prod --env .#staging\n\n# Compare prod with previously built manifests in ./manifests/prod\n\nnixidy diff .#prod --path ./manifests/prod\n</code></pre> <p>Usage:</p> <pre><code>nixidy diff [OPTIONS] ENVIRONMENT\n</code></pre> <p>Options:</p> <pre><code>  -f, --file PATH  Path to entrypoint nix file (only flake-less).  [default:\n                   default.nix]\n  -p, --path PATH  Path to previously built environment to compare to.\n  -e, --env ENV    Another environment to build and compare to.\n  --help           Show this message and exit.\n</code></pre>"},{"location":"cli_reference/#nixidy-info","title":"nixidy info","text":"<p>Get info about a nixidy environment.</p> <p>ENVIRONMENT is used to determine if flakes or flake-less nix should be used and which environment should be built.</p> <p>Example: <code>.#prod</code> Uses a flake in the local directory whereas <code>prod</code> does not use flake but builds the <code>prod</code> environment</p> <p>Usage:</p> <pre><code>nixidy info [OPTIONS] ENVIRONMENT\n</code></pre> <p>Options:</p> <pre><code>  -f, --file PATH  Path to entrypoint nix file (only flake-less).  [default:\n                   default.nix]\n  --json           Output info in JSON format.\n  --help           Show this message and exit.\n</code></pre>"},{"location":"cli_reference/#nixidy-switch","title":"nixidy switch","text":"<p>Build and switch to a nixidy environment.</p> <p>ENVIRONMENT is used to determine if flakes or flake-less nix should be used and which environment should be built.</p> <p>Example: <code>.#prod</code> Uses a flake in the local directory whereas <code>prod</code> does not use flake but builds the <code>prod</code> environment</p> <p>Usage:</p> <pre><code>nixidy switch [OPTIONS] ENVIRONMENT\n</code></pre> <p>Options:</p> <pre><code>  -f, --file PATH  Path to entrypoint nix file (only flake-less).  [default:\n                   default.nix]\n  --help           Show this message and exit.\n</code></pre>"},{"location":"library/","title":"Libary Functions","text":"<p>The argument <code>lib</code> is passed to each module in nixidy. This is the standard nixpkgs library extended with the following functions.</p>"},{"location":"library/#libhelmdownloadhelmchart","title":"lib.helm.downloadHelmChart","text":"<p>Type: <code>downloadHelmChart :: AttrSet -&gt; Derivation</code></p> <p>Downloads a helm chart from a helm registry.</p> <p>This is re-exported directly from farcaller/nix-kube-generators.</p>"},{"location":"library/#libhelmbuildhelmchart","title":"lib.helm.buildHelmChart","text":"<p>Type: <code>buildHelmChart :: AttrSet -&gt; Derivation</code></p> <p>Templates a helm chart with provided values and creates a derivation with the output.</p> <p>This is re-exported directly from farcaller/nix-kube-generators.</p>"},{"location":"library/#libhelmgetchartvalues","title":"lib.helm.getChartValues","text":"<p>Type: <code>getChartValues :: Derivation -&gt; AttrSet</code></p> <p>Parse the default values file shipped with the helm chart.</p> <code>chart</code> <p>Derivation containing helm chart. Usually output of lib.helm.downloadHelmChart.</p> <p>Example:</p> <pre><code>getChartValues (lib.helm.downloadHelmChart {\n    repo = \"https://argoproj.github.io/argo-helm/\";\n    chart = \"argo-cd\";\n    version = \"5.51.4\";\n    chartHash = \"sha256-LOEJ5mYaHEA0RztDkgM9DGTA0P5eNd0SzSlwJIgpbWY=\";\n})\n=&gt; {\n  server.replicas = 1;\n  controller.replicas = 1;\n  # ...\n}\n</code></pre>"},{"location":"library/#libhelmmkchartattrs","title":"lib.helm.mkChartAttrs","text":"<p>Type: <code>mkChartAttrs :: Path -&gt; AttrSet</code></p> <p>Walk a directory tree and import all <code>default.nix</code> to download helm charts.</p> <p>The <code>default.nix</code> needs to have the following format:</p> ./charts/kubernetes-csi/csi-driver-nfs/default.nix<pre><code>{\n  repo = \"https://raw.githubusercontent.com/kubernetes-csi/csi-driver-nfs/master/charts\";\n  chart = \"csi-driver-nfs\";\n  version = \"4.7.0\";\n  chartHash = \"sha256-EU2qaZglUU3vxa41l1p/2yBscksIhYMr8kSgH8t0vL8=\";\n}\n</code></pre> <code>dir</code> <p>Path to a directory containing the correct directory structure described above.</p> <p>Example:</p> <pre><code>mkChartAttrs ./charts\n=&gt; {\n  kubernetes-csi = {\n    csi-driver-nfs = lib.helm.downloadHelmChart {\n      repo = \"https://raw.githubusercontent.com/kubernetes-csi/csi-driver-nfs/master/charts\";\n      chart = \"csi-driver-nfs\";\n      version = \"4.7.0\";\n      chartHash = \"sha256-EU2qaZglUU3vxa41l1p/2yBscksIhYMr8kSgH8t0vL8=\";\n    };\n  };\n}\n</code></pre>"},{"location":"library/#libkustomizebuildkustomization","title":"lib.kustomize.buildKustomization","text":"<p>Type: <code>buildKustomization :: AttrSet -&gt; Derivation</code></p> <p>Builds a kustomization and creates a derivation with the output.</p> structured function argument <p><code>name</code></p> <p>Name is only used for derivation name.</p> <code>src</code> <p>Derivation containing the kustomization entrypoint and all relative bases that it might reference.</p> <code>path</code> <p>Relative path from the base of <code>src</code> to the kustomization folder to render.</p> <code>namespace</code> <p>Override namespace in kustomization.yaml.</p> <p>Example:</p> <pre><code>buildKustomization {\n  name = \"argocd\";\n  src = pkgs.fetchFromGitHub {\n    owner = \"argoproj\";\n    repo = \"argo-cd\";\n    rev = \"v2.9.3\";\n    hash = \"sha256-GaY4Cw/LlSwy35umbB4epXt6ev8ya19UjHRwhDwilqU=\";\n  };\n  path = \"manifests/cluster-install\";\n  namespace = \"argocd\";\n}\n=&gt; /nix/store/7i52...7pww-kustomize-argocd\n</code></pre>"},{"location":"library/#libkubefromyaml","title":"lib.kube.fromYAML","text":"<p>Type: <code>fromYAML :: String -&gt; [AttrSet]</code></p> <p>Parses a YAML document string into a list of attribute sets.</p> <p>This is re-exported directly from farcaller/nix-kube-generators.</p> <code>yaml</code> <p>String with a yaml document.</p> <p>Example:</p> <pre><code>fromYAML ''\n  apiVersion: v1\n  kind: Namespace\n  metadata:\n    name: default\n  ---\n  apiVersion: v1\n  kind: Namespace\n  metadata:\n    name: kube-system\n''\n=&gt; [\n  {\n    apiVersion = \"v1\";\n    kind = \"Namespace\";\n    metadata.name = \"default\";\n  }\n  {\n    apiVersion = \"v1\";\n    kind = \"Namespace\";\n    metadata.name = \"kube-system\";\n  }\n]\n</code></pre>"},{"location":"library/#libkubefromoctal","title":"lib.kube.fromOctal","text":"<p>Type: <code>fromOctal :: String -&gt; Integer</code></p> <p>Parse an octal representation of a number and convert into a decimal number. This can be useful when having to represent permission bits in a resource as nix has no support for representing octal numbers.</p> <code>octal</code> <p>String representation of the octal number to parse.</p> <p>Example:</p> <pre><code>fromOctal \"0555\"\n=&gt; 365\n</code></pre>"},{"location":"library/#libkuberemovelabels","title":"lib.kube.removeLabels","text":"<p>Type: <code>removeLabels :: [String] -&gt; AttrSet -&gt; AttrSet</code></p> <p>Removes labels from a Kubernetes manifest.</p> <code>labels</code> <p>List of labels that should be removed</p> <code>manifest</code> <p>Kubernetes manifest</p> <p>Example:</p> <pre><code>removeLabels [\"helm.sh/chart\"] {\n  apiVersion = \"v1\";\n  kind = \"ConfigMap\";\n  metadata = {\n    name = \"argocd-cm\";\n    labels = {\n      \"app.kubernetes.io/name\" = \"argocd-cm\";\n      \"helm.sh/chart\" = \"argo-cd-5.51.6\";\n    };\n  };\n}\n=&gt; {\n  apiVersion = \"v1\";\n  kind = \"ConfigMap\";\n  metadata = {\n    name = \"argocd-cm\";\n    labels = {\n      \"app.kubernetes.io/name\" = \"argocd-cm\";\n    };\n  };\n}\n</code></pre>"},{"location":"options/","title":"Configuration Options","text":"<p>To see all available resources options, use the nixidy options search powered by N\u00fcschtOS.</p>"},{"location":"options/#applications","title":"applications","text":"<p>An application is a single Argo CD application that will be rendered by nixidy.</p> <p>The resources will be rendered into it's own directory and an Argo CD application created for it.</p> <p>Type: attribute set of (submodule)</p> <p>Default: <code>{ }</code></p> <p>Example:</p> <pre><code>{\n  nginx = {\n    namespace = \"nginx\";\n    resources = {\n      deployments = {\n        nginx = {\n          spec = {\n            replicas = 3;\n            selector = {\n              matchLabels = {\n                app = \"nginx\";\n              };\n            };\n            template = {\n              metadata = {\n                labels = {\n                  app = \"nginx\";\n                };\n              };\n              spec = {\n                containers = {\n                  nginx = {\n                    image = \"nginx:1.25.1\";\n                    imagePullPolicy = \"IfNotPresent\";\n                  };\n                };\n                securityContext = {\n                  fsGroup = 1000;\n                };\n              };\n            };\n          };\n        };\n      };\n      services = {\n        nginx = {\n          spec = {\n            ports = {\n              http = {\n                port = 80;\n              };\n            };\n            selector = {\n              app = \"nginx\";\n            };\n          };\n        };\n      };\n    };\n  };\n}\n</code></pre> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnameannotations","title":"applications.&lt;name&gt;.annotations","text":"<p>Annotations to add to the rendered ArgoCD application.</p> <p>Type: attribute set of string</p> <p>Default: <code>{ }</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamecompareoptionsignoreextraneous","title":"applications.&lt;name&gt;.compareOptions.ignoreExtraneous","text":"<p>Sets IgnoreExtraneous compare option for the application. Only setting it as <code>true</code> has any effect.</p> <p>Type: null or boolean</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamecompareoptionsincludemutationwebhook","title":"applications.&lt;name&gt;.compareOptions.includeMutationWebhook","text":"<p>Sets IncludeMutationWebhook compare option for the application. Only setting it as <code>true</code> has any effect.</p> <p>Type: null or boolean</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamecompareoptionsserversidediff","title":"applications.&lt;name&gt;.compareOptions.serverSideDiff","text":"<p>Sets ServerSideDiff compare option for the application. Leave as <code>null</code> for the default behavior.</p> <p>Type: null or boolean</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamecreatenamespace","title":"applications.&lt;name&gt;.createNamespace","text":"<p>Whether or not a namespace resource should be automatically created.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamedestinationname","title":"applications.&lt;name&gt;.destination.name","text":"<p>The name of the cluster that ArgoCD should deploy all applications to.</p> <p>Type: null or string</p> <p>Default: <code>config.nixidy.defaults.destination.name</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamedestinationserver","title":"applications.&lt;name&gt;.destination.server","text":"<p>The Kubernetes server that ArgoCD should deploy the application to.</p> <p>Type: null or string</p> <p>Default: <code>config.nixidy.defaults.destination.server</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamefinalizer","title":"applications.&lt;name&gt;.finalizer","text":"<p>Specify the finalizer to apply to the ArgoCD application.</p> <p>Type: one of \"background\", \"foreground\", \"non-cascading\"</p> <p>Default: <code>config.nixidy.defaults.finalizer</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleases","title":"applications.&lt;name&gt;.helm.releases","text":"<p>Helm releases to template and add to the rendered application's resources.</p> <p>Type: attribute set of (submodule)</p> <p>Default: <code>{ }</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/helm.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnamechart","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.chart","text":"<p>Derivation containing the helm chart for the release.</p> <p>Type: package or absolute path</p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/helm.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnameextraopts","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.extraOpts","text":"<p>Extra options to pass to <code>helm template</code> that is run when rendering the helm chart.</p> <p>Type: list of string</p> <p>Default: <code>config.nixidy.defaults.helm.extraOpts</code></p> <p>Example:</p> <pre><code>[\n  \"--no-hooks\"\n]\n</code></pre> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/helm.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnameincludecrds","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.includeCRDs","text":"<p>Whether or not to include CRDs in the helm release.</p> <p>Type: boolean</p> <p>Default: <code>true</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/helm.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnamename","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.name","text":"<p>Name of the helm release.</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/helm.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnamenamespace","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.namespace","text":"<p>Namespace for the release.</p> <p>Type: string</p> <p>Default: <code>config.applications.&lt;name&gt;.namespace</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/helm.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnametransformer","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.transformer","text":"<p>Function that will be applied to the list of rendered manifests after the helm templating.</p> <p>Type: function that evaluates to a(n) list of attribute set of anything</p> <p>Default: <code>config.nixidy.defaults.helm.transformer</code></p> <p>Example: <code>map (lib.kube.removeLabels [\"helm.sh/chart\"])</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/helm.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnamevalues","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.values","text":"<p>Values to pass to the helm chart when rendering it.</p> <p>Type: attribute set of anything</p> <p>Default: <code>{ }</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/helm.nix&gt;</li> </ul>"},{"location":"options/#applicationsnameignoredifferences","title":"applications.&lt;name&gt;.ignoreDifferences","text":"<p>IgnoreDifferences is a list of resources and their fields which should be ignored during comparison.</p> <p>More info here.</p> <p>Type: null or (attribute set of (submodule))</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnameignoredifferencesnamegroup","title":"applications.&lt;name&gt;.ignoreDifferences.&lt;name&gt;.group","text":"<p>Type: null or string</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnameignoredifferencesnamejqpathexpressions","title":"applications.&lt;name&gt;.ignoreDifferences.&lt;name&gt;.jqPathExpressions","text":"<p>Type: null or (list of string)</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnameignoredifferencesnamejsonpointers","title":"applications.&lt;name&gt;.ignoreDifferences.&lt;name&gt;.jsonPointers","text":"<p>Type: null or (list of string)</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnameignoredifferencesnamekind","title":"applications.&lt;name&gt;.ignoreDifferences.&lt;name&gt;.kind","text":"<p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnameignoredifferencesnamemanagedfieldsmanagers","title":"applications.&lt;name&gt;.ignoreDifferences.&lt;name&gt;.managedFieldsManagers","text":"<p>ManagedFieldsManagers is a list of trusted managers. Fields mutated by those managers will take precedence over the desired state defined in the SCM and won't be displayed in diffs</p> <p>Type: null or (list of string)</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnameignoredifferencesnamename","title":"applications.&lt;name&gt;.ignoreDifferences.&lt;name&gt;.name","text":"<p>Type: null or string</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnameignoredifferencesnamenamespace","title":"applications.&lt;name&gt;.ignoreDifferences.&lt;name&gt;.namespace","text":"<p>Type: null or string</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamekustomizeapplications","title":"applications.&lt;name&gt;.kustomize.applications","text":"<p>Kustomize applications to render and add to the rendered application's resources.</p> <p>Type: attribute set of (submodule)</p> <p>Default: <code>{ }</code></p> <p>Example:</p> <pre><code>{\n  argocd = {\n    namespace = \"argocd\";\n    # Equivalent to `github.com/argoproj/argo-cd/manifests/cluster-install?ref=v2.9.3`\n    # in kustomization.yaml.\n    kustomization = {\n      src = pkgs.fetchFromGitHub {\n        owner = \"argoproj\";\n        repo = \"argo-cd\";\n        rev = \"v2.9.3\";\n        hash = \"sha256-GaY4Cw/LlSwy35umbB4epXt6ev8ya19UjHRwhDwilqU=\";\n      };\n      path = \"manifests/cluster-install\";\n    };\n  };\n};\n</code></pre> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/kustomize.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamekustomizeapplicationsnamekustomizationpath","title":"applications.&lt;name&gt;.kustomize.applications.&lt;name&gt;.kustomization.path","text":"<p>Path relative to the base of <code>src</code> to the entrypoint kustomization directory.</p> <p>Type: string</p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/kustomize.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamekustomizeapplicationsnamekustomizationsrc","title":"applications.&lt;name&gt;.kustomize.applications.&lt;name&gt;.kustomization.src","text":"<p>Derivation containing all the kustomize bases and overlays.</p> <p>Type: package or absolute path</p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/kustomize.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamekustomizeapplicationsnamename","title":"applications.&lt;name&gt;.kustomize.applications.&lt;name&gt;.name","text":"<p>Name of the kustomize application.</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/kustomize.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamekustomizeapplicationsnamenamespace","title":"applications.&lt;name&gt;.kustomize.applications.&lt;name&gt;.namespace","text":"<p>Namespace for the kustomize application.</p> <p>Type: string</p> <p>Default: <code>config.applications.&lt;name&gt;.namespace</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/kustomize.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamekustomizeapplicationsnametransformer","title":"applications.&lt;name&gt;.kustomize.applications.&lt;name&gt;.transformer","text":"<p>Function that will be applied to the list of rendered manifests from kustomize.</p> <p>Type: function that evaluates to a(n) list of attribute set of anything</p> <p>Default: <code>config.nixidy.defaults.kustomize.transformer</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/kustomize.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamename","title":"applications.&lt;name&gt;.name","text":"<p>Name of the application.</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamenamespace","title":"applications.&lt;name&gt;.namespace","text":"<p>Namespace to deploy application into (defaults to name).</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnameoutputpath","title":"applications.&lt;name&gt;.output.path","text":"<p>Name of the folder that contains all rendered resources for the application. Relative to the root of the repository.</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnameproject","title":"applications.&lt;name&gt;.project","text":"<p>ArgoCD project to make application a part of.</p> <p>Type: string</p> <p>Default: <code>\"default\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnameresources","title":"applications.&lt;name&gt;.resources","text":"<p>Kubernetes resources for the application.</p> <p>The entire list of available resource options is too large for the current documentation setup but can be searched in the nixidy options search powered by N\u00fcschtOS.</p> <p>Type: attribute set</p> <p>Default: <code>{ }</code></p> <p>Example:</p> <pre><code>{\n  deployments = {\n    nginx = {\n      spec = {\n        replicas = 3;\n        selector = {\n          matchLabels = {\n            app = \"nginx\";\n          };\n        };\n        template = {\n          metadata = {\n            labels = {\n              app = \"nginx\";\n            };\n          };\n          spec = {\n            containers = {\n              nginx = {\n                image = \"nginx:1.25.1\";\n                imagePullPolicy = \"IfNotPresent\";\n              };\n            };\n            securityContext = {\n              fsGroup = 1000;\n            };\n          };\n        };\n      };\n    };\n  };\n  services = {\n    nginx = {\n      spec = {\n        ports = {\n          http = {\n            port = 80;\n          };\n        };\n        selector = {\n          app = \"nginx\";\n        };\n      };\n    };\n  };\n}\n</code></pre> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicyautosyncenable","title":"applications.&lt;name&gt;.syncPolicy.autoSync.enable","text":"<p>Specifies if application should automatically sync.</p> <p>Type: boolean</p> <p>Default: <code>config.nixidy.defaults.syncPolicy.autoSync.enable</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicyautosyncprune","title":"applications.&lt;name&gt;.syncPolicy.autoSync.prune","text":"<p>Specifies if resources should be pruned during auto-syncing.</p> <p>Type: boolean</p> <p>Default: <code>config.nixidy.defaults.syncPolicy.autoSync.prune</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicyautosyncselfheal","title":"applications.&lt;name&gt;.syncPolicy.autoSync.selfHeal","text":"<p>Specifies if partial app sync should be executed when resources are changed only in target Kubernetes cluster and no git change detected.</p> <p>Type: boolean</p> <p>Default: <code>config.nixidy.defaults.syncPolicy.autoSync.selfHeal</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicymanagednamespacemetadata","title":"applications.&lt;name&gt;.syncPolicy.managedNamespaceMetadata","text":"<p>ArgoCD Managed namespace metadata.</p> <p>Type: null or (submodule)</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicymanagednamespacemetadataannotations","title":"applications.&lt;name&gt;.syncPolicy.managedNamespaceMetadata.annotations","text":"<p>Annotations to add to the ArgoCD managed namespace.</p> <p>Type: null or (attribute set of string)</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicymanagednamespacemetadatalabels","title":"applications.&lt;name&gt;.syncPolicy.managedNamespaceMetadata.labels","text":"<p>Label to add to the ArgoCD managed namespace.</p> <p>Type: null or (attribute set of string)</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicyretry","title":"applications.&lt;name&gt;.syncPolicy.retry","text":"<p>ArgoCD retry syncPolicy.</p> <p>Type: null or (submodule)</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicyretrybackoff","title":"applications.&lt;name&gt;.syncPolicy.retry.backoff","text":"<p>Type: null or (submodule)</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicyretrybackoffduration","title":"applications.&lt;name&gt;.syncPolicy.retry.backoff.duration","text":"<p>Type: null or string</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicyretrybackofffactor","title":"applications.&lt;name&gt;.syncPolicy.retry.backoff.factor","text":"<p>Type: null or signed integer</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicyretrybackoffmaxduration","title":"applications.&lt;name&gt;.syncPolicy.retry.backoff.maxDuration","text":"<p>Type: null or string</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicyretrylimit","title":"applications.&lt;name&gt;.syncPolicy.retry.limit","text":"<p>Type: null or signed integer</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicysyncoptionsapplyoutofsynconly","title":"applications.&lt;name&gt;.syncPolicy.syncOptions.applyOutOfSyncOnly","text":"<p>Currently when syncing using auto sync Argo CD applies every object in the application. For applications containing thousands of objects this takes quite a long time and puts undue pressure on the api server. Turning on selective sync option which will sync only out-of-sync resources.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicysyncoptionscreatenamespace","title":"applications.&lt;name&gt;.syncPolicy.syncOptions.createNamespace","text":"<p>Namespace Auto-Creation ensures that namespace specified as the application destination exists in the destination cluster.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicysyncoptionsfailonsharedresource","title":"applications.&lt;name&gt;.syncPolicy.syncOptions.failOnSharedResource","text":"<p>By default, Argo CD will apply all manifests found in the git path configured in the Application regardless if the resources defined in the yamls are already applied by another Application. If the <code>failOnSharedResource</code> sync option is set, Argo CD will fail the sync whenever it finds a resource in the current Application that is already applied in the cluster by another Application.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicysyncoptionsprunelast","title":"applications.&lt;name&gt;.syncPolicy.syncOptions.pruneLast","text":"<p>This feature is to allow the ability for resource pruning to happen as a final, implicit wave of a sync operation, after the other resources have been deployed and become healthy, and after all other waves completed successfully.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicysyncoptionsreplace","title":"applications.&lt;name&gt;.syncPolicy.syncOptions.replace","text":"<p>By default, Argo CD executes <code>kubectl apply</code> operation to apply the configuration stored in Git. In some cases <code>kubectl apply</code> is not suitable. For example, resource spec might be too big and won't fit into <code>kubectl.kubernetes.io/last-applied-configuration</code> annotation that is added by kubectl apply.</p> <p>If the <code>replace = true;</code> sync option is set the Argo CD will use <code>kubectl replace</code> or <code>kubectl create</code> command to apply changes.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicysyncoptionsserversideapply","title":"applications.&lt;name&gt;.syncPolicy.syncOptions.serverSideApply","text":"<p>By default, Argo CD executes <code>kubectl apply</code> operation to apply the configuration stored in Git. This is a client side operation that relies on <code>kubectl.kubernetes.io/last-applied-configuration</code> annotation to store the previous resource state.</p> <p>If <code>serverSideApply = true;</code> sync option is set, Argo CD will use <code>kubectl apply --server-side</code> command to apply changes.</p> <p>More info here.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnameyamls","title":"applications.&lt;name&gt;.yamls","text":"<p>List of Kubernetes manifests declared in YAML strings. They will be parsed and added to the application's <code>resources</code> where they can be overwritten and modified.</p> <p>Can be useful for reading existing YAML files (i.e. <code>[(builtins.readFile ./deployment.yaml)]</code>).</p> <p>Type: list of string</p> <p>Default: <code>[ ]</code></p> <p>Example:</p> <pre><code>[\n  ''\n    apiVersion: v1\n    kind: Namespace\n    metadata:\n      name: default\n  ''\n]\n</code></pre> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/yamls.nix&gt;</li> </ul>"},{"location":"options/#nixidyappofappsdestinationname","title":"nixidy.appOfApps.destination.name","text":"<p>The name of the cluster that ArgoCD should deploy the app of apps to.</p> <p>Type: null or string</p> <p>Default: <code>config.nixidy.defaults.destination.name</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidyappofappsdestinationserver","title":"nixidy.appOfApps.destination.server","text":"<p>The Kubernetes server that ArgoCD should deploy the app of apps to.</p> <p>Type: null or string</p> <p>Default: <code>config.nixidy.defaults.destination.server</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidyappofappsname","title":"nixidy.appOfApps.name","text":"<p>Name of the application for bootstrapping all other applications (app of apps pattern).</p> <p>Type: string</p> <p>Default: <code>\"apps\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidyappofappsnamespace","title":"nixidy.appOfApps.namespace","text":"<p>Destination namespace for generated Argo CD Applications in the app of apps applications.</p> <p>Type: string</p> <p>Default: <code>\"argocd\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidyappofappsproject","title":"nixidy.appOfApps.project","text":"<p>The project of the generated bootstrap app for appOfApps</p> <p>Type: string</p> <p>Default: <code>\"default\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidyappendnamewithenv","title":"nixidy.appendNameWithEnv","text":"<p>When this is set to true, all applications names will be suffixed by the environment.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidyapplicationimports","title":"nixidy.applicationImports","text":"<p>List of modules to import into <code>applications.*</code> submodule (most useful for resource definition options).</p> <p>Type: list of (package or absolute path or function that evaluates to a(n) (attribute set))</p> <p>Default: <code>[ ]</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#nixidybootstrapmanifestenable","title":"nixidy.bootstrapManifest.enable","text":"<p>Automatically include a <code>bootstrap.yaml</code> manifest in the generated output. This can be used to bootstrap the app of apps by running <code>kubectl apply -f bootstrap.yaml</code>.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/extra-files.nix&gt;</li> </ul>"},{"location":"options/#nixidybuildrevision","title":"nixidy.build.revision","text":"<p>The revision being built. Will be written to <code>.revision</code> in the environment destination directory.</p> <p>Type: null or string</p> <p>Default: <code>null</code></p> <p>Example: <code>if (self ? rev) then self.rev else self.dirtyRev</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidycharts","title":"nixidy.charts","text":"<p>Attrset of derivations containing helm charts. This will be passed as <code>charts</code> to every module.</p> <p>Type: attribute set of anything</p> <p>Default: <code>{ }</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidychartsdir","title":"nixidy.chartsDir","text":"<p>Path to a directory containing sub-directory structure that can be used to build a charts attrset. This will be passed as <code>charts</code> to every module.</p> <p>Type: null or absolute path</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidydefaultsdestinationname","title":"nixidy.defaults.destination.name","text":"<p>The name of the cluster that ArgoCD should deploy all applications to.</p> <p>This is the default value for all applications if not explicitly set for the application.</p> <p>Type: null or string</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidydefaultsdestinationserver","title":"nixidy.defaults.destination.server","text":"<p>The Kubernetes server that ArgoCD should deploy all applications to.</p> <p>This is the default value for all applications if not explicitly set for the application.</p> <p>Type: null or string</p> <p>Default: <code>\"https://kubernetes.default.svc\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidydefaultsfinalizer","title":"nixidy.defaults.finalizer","text":"<p>Specify the default finalizer to apply to all ArgoCD application, by default.</p> <p>Type: one of \"background\", \"foreground\", \"non-cascading\"</p> <p>Default: <code>\"non-cascading\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidydefaultshelmextraopts","title":"nixidy.defaults.helm.extraOpts","text":"<p>The default extra options to pass to <code>helm template</code> that is run when rendering the helm chart, applies to all applications.</p> <p>Type: list of string</p> <p>Default: <code>[ ]</code></p> <p>Example:</p> <pre><code>[\n  \"--no-hooks\"\n]\n</code></pre> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidydefaultshelmtransformer","title":"nixidy.defaults.helm.transformer","text":"<p>Function that will be applied to the list of rendered manifests after the helm templating. This option applies to all helm releases in all applications unless explicitly specified there.</p> <p>Type: function that evaluates to a(n) list of attribute set of anything</p> <p>Default: <code>res: res</code></p> <p>Example: <code>map (lib.kube.removeLabels [\"helm.sh/chart\"])</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidydefaultskustomizetransformer","title":"nixidy.defaults.kustomize.transformer","text":"<p>Function that will be applied to the list of rendered manifests after kustomize rendering. This option applies to all kustomize applications in all nixidy applications unless explicitly specified there.</p> <p>Type: function that evaluates to a(n) list of attribute set of anything</p> <p>Default: <code>res: res</code></p> <p>Example: <code>map (lib.kube.removeLabels [\"app.kubernetes.io/version\"])</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidydefaultssyncpolicyautosyncenable","title":"nixidy.defaults.syncPolicy.autoSync.enable","text":"<p>Specifies if applications should automatically sync.</p> <p>This is the default value for all applications if not explicitly set for the application.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidydefaultssyncpolicyautosyncprune","title":"nixidy.defaults.syncPolicy.autoSync.prune","text":"<p>Specifies if resources should be pruned during auto-syncing.</p> <p>This is the default value for all applications if not explicitly set for the application.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidydefaultssyncpolicyautosyncselfheal","title":"nixidy.defaults.syncPolicy.autoSync.selfHeal","text":"<p>Specifies if partial app sync should be executed when resources are changed only in target Kubernetes cluster and no git change detected.</p> <p>This is the default value for all applications if not explicitly set for the application.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidyenv","title":"nixidy.env","text":"<p>The environment name for this configuration.</p> <p>Type: string</p> <p>Default: <code>\"default\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidyextrafiles","title":"nixidy.extraFiles","text":"<p>Extra files to write in the generated stage.</p> <p>Type: attribute set of (submodule)</p> <p>Default: <code>{ }</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/extra-files.nix&gt;</li> </ul>"},{"location":"options/#nixidyextrafilesnamepath","title":"nixidy.extraFiles.&lt;name&gt;.path","text":"<p>Path of output file.</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/extra-files.nix&gt;</li> </ul>"},{"location":"options/#nixidyextrafilesnamesource","title":"nixidy.extraFiles.&lt;name&gt;.source","text":"<p>Path of the source file.</p> <p>Type: absolute path</p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/extra-files.nix&gt;</li> </ul>"},{"location":"options/#nixidyextrafilesnametext","title":"nixidy.extraFiles.&lt;name&gt;.text","text":"<p>Text of the output file.</p> <p>Type: null or strings concatenated with \"\\n\"</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/extra-files.nix&gt;</li> </ul>"},{"location":"options/#nixidyk8sversion","title":"nixidy.k8sVersion","text":"<p>The Kubernetes version for generated resource options to use.</p> <p>Type: one of \"1.31\", \"1.32\", \"1.33\", \"1.34\", \"1.35\"</p> <p>Default: <code>\"1.34\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#nixidytargetbranch","title":"nixidy.target.branch","text":"<p>The destination branch of the generated applications.</p> <p>Type: string</p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidytargetrepository","title":"nixidy.target.repository","text":"<p>The repository URL to put in all generated applications.</p> <p>Type: string</p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidytargetrootpath","title":"nixidy.target.rootPath","text":"<p>The root path of all generated applications in the repository.</p> <p>Type: string</p> <p>Default: <code>\"./\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#templates","title":"templates","text":"<p>Defines reusable templates that can be used in applications. See documentation.</p> <p>Type: attribute set of (submodule)</p> <p>Default: <code>{ }</code></p> <p>Example:</p> <pre><code>{\n  webApplication = {\n    options = with lib; {\n      image = mkOption {\n        type = lib.types.str;\n        description = \"The image to use in the web application deployment\";\n      };\n      replicas = mkOption {\n        type = lib.types.int;\n        default = 3;\n        description = \"The number of replicas for the web application deployment.\";\n      };\n      port = mkOption {\n        type = lib.types.port;\n        default = 8080;\n        description = \"The web application's port.\";\n      };\n      ingressHost = mkOption {\n        type = with lib.types; nullOr str;\n        default = null;\n        description = \"The application's ingress host. Set to null to disable ingress.\";\n      };\n    };\n\n    output = {\n      name,\n      config,\n      ...\n    }: let\n      cfg = config;\n      appLabels = {\n        \"app.kubernetes.io/name\" = name;\n        \"app.kubernetes.io/instance\" = name;\n      };\n    in {\n      deployments.\"${name}\".spec = {\n        replicas = cfg.replicas;\n        selector.matchLabels = appLabels;\n        template = {\n          metadata.labels = appLabels;\n          spec.containers.\"${name}\" = {\n            image = cfg.image;\n            ports.\"http\".containerPort = cfg.port;\n          };\n        };\n      };\n\n      services.\"${name}\".spec = {\n        selector = appLabels;\n        ports.http = {\n          port = cfg.port;\n          targetPort = cfg.port;\n        };\n      };\n\n      ingresses = lib.mkIf (cfg.ingressHost != null) {\n        \"${name}\".spec = {\n          rules = [\n            {\n              host = cfg.ingressHost;\n              http.paths = [\n                {\n                  path = \"/\";\n                  pathType = \"Prefix\";\n                  backend.service = {\n                    inherit name;\n                    port.number = cfg.port;\n                  };\n                }\n              ];\n            }\n          ];\n        };\n      };\n    };\n  };\n};\n</code></pre> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/templates.nix&gt;</li> </ul>"},{"location":"options/#templatesnameoptions","title":"templates.&lt;name&gt;.options","text":"<p>A set of module options that define the configurable parameters for your template.</p> <p>Type: attribute set of option</p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/templates.nix&gt;</li> </ul>"},{"location":"options/#templatesnameoutput","title":"templates.&lt;name&gt;.output","text":"<p>A Nix function that takes the template instance's <code>name</code> and its <code>config</code> (derived from the <code>options</code> you defined) and returns a set of nixidy resources (e.g., deployments, services, ingresses).</p> <p>Type: function that evaluates to a(n) attribute set of anything</p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/templates.nix&gt;</li> </ul>"},{"location":"developer_guide/architecture/","title":"Nixidy Architecture Guide for Contributors","text":"<p>This guide provides a comprehensive overview of the nixidy codebase to help new contributors understand the project structure, key concepts, and development workflow.</p>"},{"location":"developer_guide/architecture/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Project Structure</li> <li>Core Concepts</li> <li>Module System Deep Dive</li> <li>Library Functions</li> <li>Code Generators</li> <li>Testing Framework</li> <li>Development Workflow</li> <li>Adding New Features</li> <li>Common Tasks</li> <li>Code Style</li> </ul>"},{"location":"developer_guide/architecture/#project-structure","title":"Project Structure","text":"<pre><code>nixidy/\n\u251c\u2500\u2500 cli/                    # Python-based CLI tool\n\u251c\u2500\u2500 docs/                   # Documentation (MkDocs)\n\u2502   \u2514\u2500\u2500 user_guide/         # User-facing documentation\n\u251c\u2500\u2500 lib/                    # Nix function library\n\u2502   \u251c\u2500\u2500 default.nix         # Library entry point\n\u2502   \u251c\u2500\u2500 helm.nix            # Helm-related functions\n\u2502   \u251c\u2500\u2500 kube.nix            # Kubernetes utility functions\n\u2502   \u251c\u2500\u2500 kustomize.nix       # Kustomize-related functions\n\u2502   \u2514\u2500\u2500 tests.nix           # Library unit tests\n\u251c\u2500\u2500 modules/                # NixOS-style modules\n\u2502   \u251c\u2500\u2500 applications/       # Application submodule\n\u2502   \u2502   \u251c\u2500\u2500 default.nix     # Application options and config\n\u2502   \u2502   \u251c\u2500\u2500 helm.nix        # Helm release processing\n\u2502   \u2502   \u251c\u2500\u2500 kustomize.nix   # Kustomize processing\n\u2502   \u2502   \u251c\u2500\u2500 lib.nix         # Application helper functions\n\u2502   \u2502   \u2514\u2500\u2500 yamls.nix       # Raw YAML processing\n\u2502   \u251c\u2500\u2500 generated/          # Auto-generated resource options\n\u2502   \u2502   \u251c\u2500\u2500 argocd.nix      # ArgoCD CRD options\n\u2502   \u2502   \u2514\u2500\u2500 k8s/            # Kubernetes resource options by version\n\u2502   \u251c\u2500\u2500 testing/            # Testing framework modules\n\u2502   \u2502   \u251c\u2500\u2500 default.nix     # Test suite configuration\n\u2502   \u2502   \u2514\u2500\u2500 eval.nix        # Test evaluation logic\n\u2502   \u251c\u2500\u2500 applications.nix    # Main applications option\n\u2502   \u251c\u2500\u2500 build.nix           # Build output packages\n\u2502   \u251c\u2500\u2500 default.nix         # Module entry point\n\u2502   \u251c\u2500\u2500 extra-files.nix     # Extra files configuration\n\u2502   \u251c\u2500\u2500 modules.nix         # Module list\n\u2502   \u251c\u2500\u2500 nixidy.nix          # Core nixidy options\n\u2502   \u2514\u2500\u2500 templates.nix       # Template system\n\u251c\u2500\u2500 nixidy/                 # Legacy bash CLI (deprecated)\n\u251c\u2500\u2500 pkgs/                   # Nix packages and generators\n\u2502   \u2514\u2500\u2500 generators/         # CRD and K8s schema generators\n\u2502       \u251c\u2500\u2500 crd2jsonschema.py   # CRD to JSON schema converter\n\u2502       \u251c\u2500\u2500 default.nix         # Generator entry point\n\u2502       \u251c\u2500\u2500 generator.nix       # Nix options generator\n\u2502       \u2514\u2500\u2500 versions.nix        # Kubernetes versions config\n\u251c\u2500\u2500 tests/                  # Module unit tests\n\u2502   \u251c\u2500\u2500 helm/               # Helm-specific tests\n\u2502   \u251c\u2500\u2500 kustomize/          # Kustomize-specific tests\n\u2502   \u2514\u2500\u2500 *.nix               # Individual test files\n\u251c\u2500\u2500 flake.nix               # Nix flake definition\n\u2514\u2500\u2500 default.nix             # Non-flake entry point\n</code></pre>"},{"location":"developer_guide/architecture/#core-concepts","title":"Core Concepts","text":""},{"location":"developer_guide/architecture/#1-nixos-module-system","title":"1. NixOS Module System","text":"<p>Nixidy is built on top of the NixOS module system. If you're unfamiliar with it, read the NixOS Module System documentation first.</p> <p>Key concepts: - Options: Define the configuration interface with types, defaults, and descriptions - Config: Contains the actual configuration values after module evaluation - Imports: Modules can import other modules to extend functionality - Special Args: Additional arguments passed to all modules (<code>lib</code>, <code>pkgs</code>, <code>config</code>, etc.)</p>"},{"location":"developer_guide/architecture/#2-application-lifecycle","title":"2. Application Lifecycle","text":"<pre><code>User Config \u2192 Module Evaluation \u2192 Resource Processing \u2192 Manifest Generation \u2192 Output\n</code></pre> <ol> <li>User Configuration: Nix files defining applications and resources</li> <li>Module Evaluation: NixOS module system merges all configurations</li> <li>Resource Processing: Helm/Kustomize/YAML converted to typed resources</li> <li>Manifest Generation: Resources serialized to YAML files</li> <li>Output: Packages created for different deployment strategies</li> </ol>"},{"location":"developer_guide/architecture/#3-resource-type-system","title":"3. Resource Type System","text":"<p>Resources are organized by Group/Version/Kind (GVK):</p> <pre><code>resources.&lt;group&gt;.&lt;version&gt;.&lt;kind&gt;.&lt;name&gt; = { ... };\n\n# Examples:\nresources.core.v1.ConfigMap.my-config = { ... };\nresources.apps.v1.Deployment.nginx = { ... };\nresources.\"networking.k8s.io\".v1.Ingress.main = { ... };\n</code></pre> <p>Aliases provide convenient access: <pre><code>resources.configMaps.my-config = { ... };      # \u2192 core.v1.ConfigMap\nresources.deployments.nginx = { ... };          # \u2192 apps.v1.Deployment\nresources.ingresses.main = { ... };             # \u2192 networking.k8s.io.v1.Ingress\n</code></pre></p>"},{"location":"developer_guide/architecture/#4-processing-pipeline","title":"4. Processing Pipeline","text":"<p>All input sources are normalized to typed nix resources:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Helm Charts    \u2502\u2500\u2500\u2510\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502\n\u2502  Kustomize      \u2502\u2500\u2500\u2524\u2500\u2500\u2192 [GVK Classification] \u2500\u2500\u2192 [Typed Nix Resources] \u2500\u2500\u2192 [YAML Output]\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502\n\u2502  Raw YAML       \u2502\u2500\u2500\u2518\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"developer_guide/architecture/#module-system-deep-dive","title":"Module System Deep Dive","text":""},{"location":"developer_guide/architecture/#main-modules","title":"Main Modules","text":""},{"location":"developer_guide/architecture/#modulesapplicationsnix","title":"<code>modules/applications.nix</code>","text":"<p>Defines the top-level <code>applications</code> option:</p> <pre><code>{\n  options.applications = mkOption {\n    type = attrsOf (submoduleWith {\n      modules = [ ./applications ] ++ config.nixidy.applicationImports;\n      specialArgs.nixidyDefaults = config.nixidy.defaults;\n    });\n  };\n}\n</code></pre> <p>Key responsibilities: - Creates application submodules - Manages Kubernetes version selection (<code>nixidy.k8sVersion</code>) - Imports generated resource options</p>"},{"location":"developer_guide/architecture/#modulesnixidynix","title":"<code>modules/nixidy.nix</code>","text":"<p>Core nixidy configuration:</p> <pre><code>{\n  options.nixidy = {\n    env = mkOption { ... };                    # Environment name\n    target.repository = mkOption { ... };      # Git repository URL\n    target.branch = mkOption { ... };          # Target branch\n    target.rootPath = mkOption { ... };        # Root path for manifests\n    defaults = { ... };                        # Default settings\n    appOfApps = { ... };                       # Bootstrap app config\n    charts = mkOption { ... };                 # Helm chart sources\n  };\n}\n</code></pre> <p>Also handles: - App-of-apps pattern generation - Chart attribute set building - Public apps list management</p>"},{"location":"developer_guide/architecture/#modulesapplicationsdefaultnix","title":"<code>modules/applications/default.nix</code>","text":"<p>Defines individual application options:</p> <pre><code>{\n  options = {\n    name = mkOption { ... };\n    namespace = mkOption { ... };\n    createNamespace = mkOption { ... };\n    syncPolicy = { ... };\n    destination = { ... };\n    resources = { ... };  # Typed Kubernetes resources\n    objects = mkOption { ... };  # Internal: final resource list\n  };\n}\n</code></pre> <p>Key responsibilities: - Application metadata and settings - Sync policy configuration - Resource type registration - Final object list generation</p>"},{"location":"developer_guide/architecture/#modulesapplicationshelmnix","title":"<code>modules/applications/helm.nix</code>","text":"<p>Helm chart integration:</p> <pre><code>{\n  options.helm.releases = mkOption {\n    type = attrsOf (submodule {\n      options = {\n        chart = mkOption { ... };\n        values = mkOption { ... };\n        transformer = mkOption { ... };\n      };\n    });\n  };\n}\n</code></pre> <p>Processing flow: 1. <code>helm.buildHelmChart</code> templates the chart 2. <code>builtins.readFile</code> reads output 3. <code>kube.fromYAML</code> parses to attribute sets 4. <code>transformer</code> function applied 5. Objects grouped by GVK 6. Added to <code>resources</code> or <code>objects</code></p>"},{"location":"developer_guide/architecture/#modulesapplicationskustomizenix","title":"<code>modules/applications/kustomize.nix</code>","text":"<p>Kustomize integration (similar pattern to Helm):</p> <pre><code>{\n  options.kustomize.applications = mkOption {\n    type = attrsOf (submodule {\n      options = {\n        kustomization.src = mkOption { ... };\n        kustomization.path = mkOption { ... };\n        transformer = mkOption { ... };\n      };\n    });\n  };\n}\n</code></pre>"},{"location":"developer_guide/architecture/#modulesapplicationsyamlsnix","title":"<code>modules/applications/yamls.nix</code>","text":"<p>Raw YAML manifest support:</p> <pre><code>{\n  options.yamls = mkOption {\n    type = listOf str;\n    description = \"List of YAML manifest strings\";\n  };\n}\n</code></pre>"},{"location":"developer_guide/architecture/#modulesbuildnix","title":"<code>modules/build.nix</code>","text":"<p>Creates output packages:</p> <ul> <li><code>environmentPackage</code>: All application manifests combined</li> <li><code>activationPackage</code>: For <code>nixidy switch</code> operations</li> <li><code>declarativePackage</code>: For <code>kubectl apply --prune</code></li> <li><code>bootstrapPackage</code>: App-of-apps manifest</li> </ul>"},{"location":"developer_guide/architecture/#modulestemplatesnix","title":"<code>modules/templates.nix</code>","text":"<p>Template system for reusable patterns:</p> <pre><code>{\n  options.templates = mkOption {\n    type = attrsOf (submodule {\n      options = {\n        options = mkOption { ... };  # Template parameters\n        output = mkOption { ... };   # Resource generator function\n      };\n    });\n  };\n}\n</code></pre> <p>Templates become application imports, allowing: <pre><code>applications.myapp.templates.webApp.frontend = {\n  image = \"nginx:latest\";\n  replicas = 3;\n};\n</code></pre></p>"},{"location":"developer_guide/architecture/#helper-functions-modulesapplicationslibnix","title":"Helper Functions (<code>modules/applications/lib.nix</code>)","text":"<pre><code>{\n  # Extract Group/Version/Kind from Kubernetes object\n  getGVK = object: {\n    group = ...;   # \"core\" for v1, otherwise first part of apiVersion\n    version = ...; # Version string\n    kind = ...;    # Kind string\n  };\n\n  # Flatten *List objects (e.g., ConfigMapList \u2192 [ConfigMap, ...])\n  flattenListObjects = ...;\n}\n</code></pre>"},{"location":"developer_guide/architecture/#library-functions","title":"Library Functions","text":""},{"location":"developer_guide/architecture/#entry-point-libdefaultnix","title":"Entry Point (<code>lib/default.nix</code>)","text":"<p>Extends <code>nixpkgs.lib</code> with nixidy functions:</p> <pre><code>lib.extend (self: old: {\n  kustomize = import ./kustomize.nix { ... };\n  helm = import ./helm.nix { ... };\n  kube = import ./kube.nix { ... };\n})\n</code></pre>"},{"location":"developer_guide/architecture/#helm-functions-libhelmnix","title":"Helm Functions (<code>lib/helm.nix</code>)","text":"Function Description <code>downloadHelmChart</code> Downloads chart from Helm registry <code>buildHelmChart</code> Templates chart with values <code>getChartValues</code> Parses chart's default values.yaml <code>mkChartAttrs</code> Creates chart attrset from directory structure"},{"location":"developer_guide/architecture/#kube-functions-libkubenix","title":"Kube Functions (<code>lib/kube.nix</code>)","text":"Function Description <code>fromYAML</code> Parses YAML string to attribute sets <code>fromOctal</code> Converts octal string to integer <code>removeLabels</code> Removes specified labels from manifests"},{"location":"developer_guide/architecture/#kustomize-functions-libkustomizenix","title":"Kustomize Functions (<code>lib/kustomize.nix</code>)","text":"Function Description <code>buildKustomization</code> Builds kustomize application"},{"location":"developer_guide/architecture/#code-generators","title":"Code Generators","text":""},{"location":"developer_guide/architecture/#overview-pkgsgenerators","title":"Overview (<code>pkgs/generators/</code>)","text":"<p>Nixidy generates typed Nix options from: 1. Kubernetes OpenAPI schemas 2. Custom Resource Definitions (CRDs)</p>"},{"location":"developer_guide/architecture/#kubernetes-schema-generation","title":"Kubernetes Schema Generation","text":"<p><code>pkgs/generators/default.nix</code> handles K8s schema generation:</p> <ol> <li>Fetches Kubernetes source for each version in <code>versions.nix</code></li> <li>Extracts OpenAPI swagger spec</li> <li>Generates namespaced resource info</li> <li>Produces Nix options via <code>generator.nix</code></li> </ol> <p>Output: <code>modules/generated/k8s/v1.XX.nix</code></p>"},{"location":"developer_guide/architecture/#crd-generation","title":"CRD Generation","text":"<p>Two entry points:</p>"},{"location":"developer_guide/architecture/#fromcrd","title":"<code>fromCRD</code>","text":"<pre><code>fromCRD {\n  name = \"cilium\";\n  src = pkgs.fetchFromGitHub { ... };\n  crds = [ \"path/to/crd.yaml\" ];\n  namePrefix = \"\";           # Optional prefix for attribute names\n  attrNameOverrides = { };   # Manual name overrides\n  skipCoerceToList = { };    # Skip list coercion for specific fields\n}\n</code></pre>"},{"location":"developer_guide/architecture/#fromchartcrd","title":"<code>fromChartCRD</code>","text":"<pre><code>fromChartCRD {\n  name = \"cert-manager\";\n  chartAttrs = { repo = \"...\"; chart = \"...\"; version = \"...\"; };\n  crds = [ \"Certificate\" ];  # Filter by kind\n}\n</code></pre>"},{"location":"developer_guide/architecture/#crd-processing-crd2jsonschemapy","title":"CRD Processing (<code>crd2jsonschema.py</code>)","text":"<p>Python script that: 1. Reads CRD YAML files 2. Extracts OpenAPI v3 schemas 3. Flattens <code>$ref</code> references 4. Outputs JSON schema for <code>generator.nix</code></p>"},{"location":"developer_guide/architecture/#testing-framework","title":"Testing Framework","text":""},{"location":"developer_guide/architecture/#module-tests-tests","title":"Module Tests (<code>tests/</code>)","text":"<p>Located in <code>tests/</code>, using nixidy's testing framework.</p>"},{"location":"developer_guide/architecture/#test-structure","title":"Test Structure","text":"<pre><code># tests/my-feature.nix\n{\n  lib,\n  config,\n  ...\n}:\nlet\n  apps = config.applications;\nin\n{\n  # Define test configuration\n  applications.test1 = {\n    namespace = \"test\";\n    resources.configMaps.cm.data.FOO = \"bar\";\n  };\n\n  # Define test assertions\n  test = {\n    name = \"my feature test\";\n    description = \"Description of what's being tested\";\n    assertions = [\n      {\n        description = \"ConfigMap should have FOO key\";\n        expression = (elemAt apps.test1.objects 0).data;\n        expected = { FOO = \"bar\"; };\n      }\n      {\n        description = \"Custom assertion function\";\n        expression = apps.test1.objects;\n        assertion = objs: length objs == 1;\n      }\n    ];\n  };\n}\n</code></pre>"},{"location":"developer_guide/architecture/#running-tests","title":"Running Tests","text":"<pre><code># Run module tests\nnix run .#moduleTests\n\n# Run library tests\nnix run .#libTests\n</code></pre>"},{"location":"developer_guide/architecture/#test-registration-testsdefaultnix","title":"Test Registration (<code>tests/default.nix</code>)","text":"<pre><code>{\n  testing = {\n    name = \"nixidy modules\";\n    tests = [\n      ./configmap.nix\n      ./create-namespace.nix\n      ./helm/with-values.nix\n      # ... more tests\n    ];\n  };\n}\n</code></pre>"},{"location":"developer_guide/architecture/#library-tests-libtestsnix","title":"Library Tests (<code>lib/tests.nix</code>)","text":"<p>Uses <code>lib.runTests</code> pattern:</p> <pre><code>{\n  kube = {\n    fromYAML = {\n      testSingleObject = {\n        expr = lib.kube.fromYAML \"...\";\n        expected = [ { ... } ];\n      };\n    };\n    removeLabels = {\n      testLabelPresent = {\n        expr = lib.kube.removeLabels [\"helm.sh/chart\"] { ... };\n        expected = { ... };\n      };\n    };\n  };\n}\n</code></pre>"},{"location":"developer_guide/architecture/#development-workflow","title":"Development Workflow","text":""},{"location":"developer_guide/architecture/#prerequisites","title":"Prerequisites","text":"<ul> <li>Nix with flakes enabled</li> <li>Basic understanding of NixOS module system</li> </ul>"},{"location":"developer_guide/architecture/#common-commands","title":"Common Commands","text":"<pre><code># Format code\nnix fmt\n\n# Run static linter\nnix run .#staticCheck\n\n# Run library tests\nnix run .#libTests\n\n# Run module tests\nnix run .#moduleTests\n\n# Generate Kubernetes modules\nnix run .#generate\n\n# Serve documentation locally\nnix run .#docsServe\n</code></pre>"},{"location":"developer_guide/architecture/#development-cycle","title":"Development Cycle","text":"<ol> <li>Make changes to modules or library</li> <li>Write tests for new functionality</li> <li>Run tests to verify changes</li> <li>Format code with <code>nix fmt</code></li> <li>Run linter with <code>nix run .#staticCheck</code></li> <li>Test manually with a sample configuration</li> </ol>"},{"location":"developer_guide/architecture/#manual-testing","title":"Manual Testing","text":"<p>Create a test configuration:</p> <pre><code># test-config.nix\n{\n  nixidy.target = {\n    repository = \"https://github.com/test/repo.git\";\n    branch = \"main\";\n  };\n\n  applications.test = {\n    namespace = \"test\";\n    createNamespace = true;\n    resources.deployments.nginx.spec = {\n      selector.matchLabels.app = \"nginx\";\n      template = {\n        metadata.labels.app = \"nginx\";\n        spec.containers.nginx.image = \"nginx:latest\";\n      };\n    };\n  };\n}\n</code></pre> <p>Build and inspect:</p> <pre><code>nix run .#cli -- build .#test\ntree result/\ncat result/test/Deployment-nginx.yaml\n</code></pre>"},{"location":"developer_guide/architecture/#adding-new-features","title":"Adding New Features","text":""},{"location":"developer_guide/architecture/#adding-a-new-application-option","title":"Adding a New Application Option","text":"<ol> <li>Define the option in <code>modules/applications/default.nix</code>:</li> </ol> <pre><code>{\n  options = {\n    myNewOption = mkOption {\n      type = types.bool;\n      default = false;\n      description = \"Description of the option.\";\n    };\n  };\n}\n</code></pre> <ol> <li>Use the option in config:</li> </ol> <pre><code>{\n  config = lib.mkIf config.myNewOption {\n    # Configuration when option is enabled\n  };\n}\n</code></pre> <ol> <li>Write tests in <code>tests/</code>:</li> </ol> <pre><code># tests/my-new-option.nix\n{\n  applications.test1 = {\n    myNewOption = true;\n    # ...\n  };\n\n  test = {\n    name = \"my new option\";\n    description = \"Test the new option\";\n    assertions = [ ... ];\n  };\n}\n</code></pre> <ol> <li> <p>Register test in <code>tests/default.nix</code></p> </li> <li> <p>Document in <code>docs/user_guide/</code></p> </li> </ol>"},{"location":"developer_guide/architecture/#adding-a-new-library-function","title":"Adding a New Library Function","text":"<ol> <li>Add function to appropriate file in <code>lib/</code>:</li> </ol> <pre><code># lib/kube.nix\n{\n  myNewFunction =\n    # Parameter description\n    param:\n    # Implementation\n    ...;\n}\n</code></pre> <ol> <li>Add documentation as comments:</li> </ol> <pre><code>/*\n  Description of function.\n\n  Type:\n    myNewFunction :: ParamType -&gt; ReturnType\n\n  Example:\n    myNewFunction \"input\"\n    =&gt; \"output\"\n*/\nmyNewFunction = ...;\n</code></pre> <ol> <li>Write tests in <code>lib/tests.nix</code>:</li> </ol> <pre><code>{\n  kube = {\n    myNewFunction = {\n      testBasicCase = {\n        expr = lib.kube.myNewFunction \"input\";\n        expected = \"output\";\n      };\n    };\n  };\n}\n</code></pre>"},{"location":"developer_guide/architecture/#adding-a-new-resource-processor","title":"Adding a New Resource Processor","text":"<p>Similar to Helm/Kustomize, create a new module:</p> <ol> <li>Create module <code>modules/applications/myprocessor.nix</code>:</li> </ol> <pre><code>{\n  nixidyDefaults,\n  lib,\n  config,\n  ...\n}:\nlet\n  helpers = import ./lib.nix lib;\nin\n{\n  options.myProcessor = mkOption {\n    type = with types; attrsOf (submodule { ... });\n  };\n\n  config = {\n    # Process inputs and add to resources/objects\n    resources = mkMerge [ ... ];\n    objects = [ ... ];\n  };\n}\n</code></pre> <ol> <li>Import in <code>modules/applications/default.nix</code>:</li> </ol> <pre><code>{\n  imports = [\n    ./helm.nix\n    ./kustomize.nix\n    ./yamls.nix\n    ./myprocessor.nix  # Add here\n  ];\n}\n</code></pre>"},{"location":"developer_guide/architecture/#common-tasks","title":"Common Tasks","text":""},{"location":"developer_guide/architecture/#updating-kubernetes-versions","title":"Updating Kubernetes Versions","text":"<ol> <li>Edit <code>pkgs/generators/versions.nix</code>:</li> </ol> <pre><code>{\n  \"1.34.0\" = {\n    hash = \"sha256-...\";\n    spec = \"api/openapi-spec/swagger.json\";\n    discovery = {\n      core = \"api/discovery/core_v1.json\";\n      aggregated = \"api/discovery/aggregated_v2.json\";\n    };\n  };\n}\n</code></pre> <ol> <li>Regenerate:</li> </ol> <pre><code>nix run .#generate\n</code></pre> <ol> <li>Update default version in <code>modules/applications.nix</code> if needed</li> </ol>"},{"location":"developer_guide/architecture/#adding-a-new-sync-option","title":"Adding a New Sync Option","text":"<ol> <li>Add option in <code>modules/applications/default.nix</code> under <code>syncPolicy.syncOptions</code>:</li> </ol> <pre><code>{\n  syncPolicy.syncOptions.myOption = mkOption {\n    type = types.bool;\n    default = false;\n    apply = val: if val then \"MyOption=true\" else null;\n    description = \"Description\";\n  };\n}\n</code></pre> <ol> <li> <p>The <code>apply</code> function converts to ArgoCD sync option format</p> </li> <li> <p><code>convertSyncOptionsList</code> automatically collects non-null options</p> </li> </ol>"},{"location":"developer_guide/architecture/#debugging-module-evaluation","title":"Debugging Module Evaluation","text":"<p>Use <code>builtins.trace</code> for debugging:</p> <pre><code>{\n  config = lib.mkMerge [\n    (builtins.trace \"Processing ${config.name}\" {\n      # ...\n    })\n  ];\n}\n</code></pre> <p>Or use <code>lib.debug.traceValSeqN</code>:</p> <pre><code>{\n  objects = lib.debug.traceValSeqN 2 config.resources;\n}\n</code></pre>"},{"location":"developer_guide/architecture/#code-style","title":"Code Style","text":""},{"location":"developer_guide/architecture/#nix","title":"Nix","text":"<ul> <li>Format: Use <code>nix fmt</code> (nixfmt-rfc-style)</li> <li>Sorting: Keep attribute sets alphabetically sorted</li> <li>Inherit: Use <code>inherit</code> where possible to reduce verbosity</li> <li>Imports: Group imports logically</li> <li>Types: Use specific types over <code>types.anything</code> when possible</li> </ul> <pre><code># Good\n{\n  lib,\n  config,\n  pkgs,\n  ...\n}:\nlet\n  inherit (config) namespace;\n  inherit (lib) mkOption types;\nin\n{\n  options.myOption = mkOption {\n    type = types.str;\n    default = \"\";\n  };\n}\n\n# Avoid\n{lib, config, pkgs, ...}: let\n  namespace = config.namespace;\nin {\n  options.myOption = lib.mkOption {\n    type = lib.types.str;\n    default = \"\";\n  };\n}\n</code></pre>"},{"location":"developer_guide/architecture/#python-cli","title":"Python (CLI)","text":"<ul> <li>Follow PEP 8 guidelines</li> <li>Use type hints for all function signatures</li> <li>Document public functions with docstrings</li> </ul>"},{"location":"developer_guide/architecture/#documentation","title":"Documentation","text":"<ul> <li>Use MkDocs syntax</li> <li>Include code examples with syntax highlighting</li> <li>Cross-reference related documentation</li> <li>Keep language clear and concise</li> </ul>"},{"location":"developer_guide/architecture/#getting-help","title":"Getting Help","text":"<ul> <li>Issues: GitHub Issues</li> <li>Discussions: GitHub Discussions</li> <li>Documentation: nixidy.dev</li> </ul>"},{"location":"developer_guide/architecture/#summary","title":"Summary","text":"<p>Key files for different tasks:</p> Task Files Add application option <code>modules/applications/default.nix</code> Add nixidy option <code>modules/nixidy.nix</code> Add library function <code>lib/*.nix</code> Add resource processor <code>modules/applications/</code> Add template feature <code>modules/templates.nix</code> Modify build output <code>modules/build.nix</code> Add K8s version <code>pkgs/generators/versions.nix</code> Write module test <code>tests/*.nix</code>, <code>tests/default.nix</code> Write library test <code>lib/tests.nix</code> <p>Welcome to the nixidy project! We look forward to your contributions.</p>"},{"location":"user_guide/direct_apply/","title":"Directly Apply Manifests","text":"<p>The <code>nixidy apply</code> sub-command provides a way to directly apply the manifests to a Kubernetes cluster. This is an alternative to using a GitOps controller like Argo CD.</p>"},{"location":"user_guide/direct_apply/#how-it-works","title":"How it works","text":"<p>When you run <code>nixidy apply</code>, it builds a nix package that contains all your Kubernetes manifests. These manifests are grouped into three categories and applied in the following order:</p> <ol> <li>Custom Resource Definitions (CRDs): CRDs are applied first to ensure that any custom resources are known to the cluster before the manifests that use them are applied.</li> <li>Namespaces: Namespaces are applied next to ensure that all required namespaces exist before any namespaced resources are created.</li> <li>Other manifests: All other manifests, such as Deployments, Services, and ConfigMaps, are applied last.</li> </ol> <p>It uses <code>kubectl apply --prune</code> to apply the manifests. The <code>--prune</code> flag is used to remove any resources from the cluster that are no longer defined in your nixidy configuration. Specific labels are added to all resources to make pruning safe and effective.</p>"},{"location":"user_guide/direct_apply/#usage","title":"Usage","text":"<p>To apply the manifests for a specific environment, you can run:</p> <pre><code>nixidy apply .#dev\n</code></pre> <p>This will build the manifests for the <code>dev</code> environment and apply them to the currently configured Kubernetes cluster.</p> <p>Info</p> <p>Make sure to set <code>createNamespace = true;</code> in all nixidy applications using namespaces that do not already exist in your Kubernetes cluster.</p>"},{"location":"user_guide/getting_started/","title":"Getting Started","text":"<p>This guide walks you through setting up your first nixidy project step by step.</p>"},{"location":"user_guide/getting_started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Nix installed with flakes enabled</li> <li>A Git repository for your Kubernetes manifests</li> <li>Basic familiarity with Kubernetes concepts</li> </ul>"},{"location":"user_guide/getting_started/#what-youll-build","title":"What You'll Build","text":"<p>By the end of this guide, you'll have:</p> <ol> <li>A nixidy project that generates Kubernetes manifests</li> <li>An nginx deployment with configuration</li> <li>An Argo CD application ready for GitOps</li> </ol>"},{"location":"user_guide/getting_started/#step-1-create-your-project","title":"Step 1: Create Your Project","text":"<p>Create a new directory for your project:</p> <pre><code>mkdir my-cluster &amp;&amp; cd my-cluster\ngit init\n</code></pre>"},{"location":"user_guide/getting_started/#step-2-set-up-the-flake","title":"Step 2: Set Up the Flake","text":"<p>Create a <code>flake.nix</code> file in your project root:</p> flake.nix<pre><code>{\n  description = \"My Kubernetes cluster managed with nixidy\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n    flake-utils.url = \"github:numtide/flake-utils\";\n    nixidy.url = \"github:arnarg/nixidy\";\n  };\n\n  outputs = {\n    nixpkgs,\n    flake-utils,\n    nixidy,\n    ...\n  }:\n    flake-utils.lib.eachDefaultSystem (system: let\n      pkgs = import nixpkgs {inherit system;};\n    in {\n      # Define your environments\n      nixidyEnvs = nixidy.lib.mkEnvs {\n        inherit pkgs;\n\n        envs = {\n          dev.modules = [./env/dev.nix];\n        };\n      };\n\n      # Make nixidy CLI available\n      packages.nixidy = nixidy.packages.${system}.default;\n\n      # Development shell with nixidy\n      devShells.default = pkgs.mkShell {\n        buildInputs = [nixidy.packages.${system}.default];\n      };\n    });\n}\n</code></pre> Using nixidy without flakes <p>If you prefer not to use flakes, you can use npins or niv for dependency management.</p> npinsniv <pre><code>npins init --bare\nnpins add github arnarg nixidy --branch main\n</code></pre> <pre><code>niv init --no-nixpkgs\nniv add github arnarg/nixidy --branch main\n</code></pre> <p>Then create <code>default.nix</code>:</p> default.nix<pre><code>let\n  sources = import ./npins;  # or ./nix/sources.nix for niv\n  nixidy = import sources.nixidy {};\nin\n  nixidy.lib.mkEnvs {\n    envs = {\n      dev.modules = [./env/dev.nix];\n    };\n  }\n</code></pre> <p>Command syntax</p> <p>The rest of this guide uses flake syntax (e.g., <code>nixidy build .#dev</code>). Without flakes, omit the <code>.#</code> prefix (e.g., <code>nixidy build dev</code>).</p>"},{"location":"user_guide/getting_started/#step-3-create-your-environment-configuration","title":"Step 3: Create Your Environment Configuration","text":"<p>Create the environment directory and configuration file:</p> <pre><code>mkdir -p env\n</code></pre> env/dev.nix<pre><code>{\n  # Where should the generated manifests be stored?\n  nixidy.target.repository = \"https://github.com/YOUR_USERNAME/my-cluster.git\";\n  nixidy.target.branch = \"main\";\n  nixidy.target.rootPath = \"./manifests/dev\";\n}\n</code></pre> <p>Replace the repository URL</p> <p>Change <code>YOUR_USERNAME</code> to your actual GitHub username, or use your preferred Git hosting URL.</p>"},{"location":"user_guide/getting_started/#step-4-verify-your-setup","title":"Step 4: Verify Your Setup","text":"<p>Enter the development shell and verify everything works:</p> <pre><code>nix develop\nnixidy info .#dev\n</code></pre> <p>You should see:</p> <pre><code>Repository: https://github.com/YOUR_USERNAME/my-cluster.git\nBranch:     main\n</code></pre> <p>Try building (it will be empty for now):</p> <pre><code>nixidy build .#dev\ntree result\n</code></pre> <p>Output:</p> <pre><code>result\n\u2514\u2500\u2500 apps/\n</code></pre> <p>The <code>apps/</code> folder is empty because we haven't defined any applications yet.</p>"},{"location":"user_guide/getting_started/#step-5-create-your-first-application","title":"Step 5: Create Your First Application","text":"<p>Now let's add an nginx application. Update your <code>env/dev.nix</code>:</p> env/dev.nix<pre><code>{\n  # Target configuration\n  nixidy.target.repository = \"https://github.com/YOUR_USERNAME/my-cluster.git\";\n  nixidy.target.branch = \"main\";\n  nixidy.target.rootPath = \"./manifests/dev\";\n\n  # Define the nginx application\n  applications.nginx = {\n    # Deploy to the \"nginx\" namespace\n    namespace = \"nginx\";\n\n    # Automatically create the namespace\n    createNamespace = true;\n\n    # Define Kubernetes resources\n    resources = {\n      # Deployment\n      deployments.nginx.spec = {\n        replicas = 2;\n        selector.matchLabels.app = \"nginx\";\n        template = {\n          metadata.labels.app = \"nginx\";\n          spec.containers.nginx = {\n            image = \"nginx:1.25.1\";\n            ports.http.containerPort = 80;\n          };\n        };\n      };\n\n      # Service\n      services.nginx.spec = {\n        selector.app = \"nginx\";\n        ports.http.port = 80;\n      };\n    };\n  };\n}\n</code></pre>"},{"location":"user_guide/getting_started/#step-6-build-and-inspect","title":"Step 6: Build and Inspect","text":"<p>Build your configuration:</p> <pre><code>nixidy build .#dev\ntree result\n</code></pre> <p>You should see:</p> <pre><code>result\n\u251c\u2500\u2500 apps\n\u2502   \u2514\u2500\u2500 Application-nginx.yaml\n\u2514\u2500\u2500 nginx\n    \u251c\u2500\u2500 Deployment-nginx.yaml\n    \u251c\u2500\u2500 Namespace-nginx.yaml\n    \u2514\u2500\u2500 Service-nginx.yaml\n</code></pre> <p>Inspect the generated deployment:</p> <pre><code>cat result/nginx/Deployment-nginx.yaml\n</code></pre> <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx\n  namespace: nginx\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n        - image: nginx:1.25.1\n          name: nginx\n          ports:\n            - containerPort: 80\n              name: http\n</code></pre> <p>Nixidy also generates an Argo CD Application:</p> <pre><code>cat result/apps/Application-nginx.yaml\n</code></pre> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: nginx\n  namespace: argocd\nspec:\n  destination:\n    namespace: nginx\n    server: https://kubernetes.default.svc\n  project: default\n  source:\n    path: ./manifests/dev/nginx\n    repoURL: https://github.com/YOUR_USERNAME/my-cluster.git\n    targetRevision: main\n</code></pre>"},{"location":"user_guide/getting_started/#step-7-sync-manifests-to-your-repository","title":"Step 7: Sync Manifests to Your Repository","text":"<p>Copy the generated manifests to your repository:</p> <pre><code>nixidy switch .#dev\n</code></pre> <p>This creates the <code>./manifests/dev</code> directory with all your manifests. Commit and push:</p> <pre><code>git add .\ngit commit -m \"Initial nixidy configuration\"\ngit push\n</code></pre>"},{"location":"user_guide/getting_started/#step-8-deploy-to-your-cluster","title":"Step 8: Deploy to Your Cluster","text":""},{"location":"user_guide/getting_started/#option-a-bootstrap-with-argo-cd","title":"Option A: Bootstrap with Argo CD","text":"<p>If you have Argo CD installed, bootstrap all applications with one command:</p> <pre><code>nixidy bootstrap .#dev | kubectl apply -f -\n</code></pre> <p>This creates an \"app of apps\" that automatically deploys all your applications.</p>"},{"location":"user_guide/getting_started/#option-b-apply-directly","title":"Option B: Apply Directly","text":"<p>For quick testing without Argo CD:</p> <pre><code>nixidy apply .#dev\n</code></pre> <p>This applies all manifests directly using <code>kubectl apply --prune</code>.</p>"},{"location":"user_guide/getting_started/#adding-more-resources","title":"Adding More Resources","text":"<p>Let's extend the nginx application with a ConfigMap:</p> env/dev.nix<pre><code>{\n  nixidy.target.repository = \"https://github.com/YOUR_USERNAME/my-cluster.git\";\n  nixidy.target.branch = \"main\";\n  nixidy.target.rootPath = \"./manifests/dev\";\n\n  applications.nginx = {\n    namespace = \"nginx\";\n    createNamespace = true;\n\n    resources = {\n      # Deployment with ConfigMap volume\n      deployments.nginx.spec = {\n        replicas = 2;\n        selector.matchLabels.app = \"nginx\";\n        template = {\n          metadata.labels.app = \"nginx\";\n          spec = {\n            containers.nginx = {\n              image = \"nginx:1.25.1\";\n              ports.http.containerPort = 80;\n              volumeMounts.\"/usr/share/nginx/html\".name = \"html\";\n            };\n            volumes.html.configMap.name = \"nginx-html\";\n          };\n        };\n      };\n\n      # Service\n      services.nginx.spec = {\n        selector.app = \"nginx\";\n        ports.http.port = 80;\n      };\n\n      # ConfigMap with HTML content\n      configMaps.nginx-html.data.\"index.html\" = ''\n        &lt;!DOCTYPE html&gt;\n        &lt;html&gt;\n          &lt;body&gt;\n            &lt;h1&gt;Hello from nixidy!&lt;/h1&gt;\n          &lt;/body&gt;\n        &lt;/html&gt;\n      '';\n    };\n  };\n}\n</code></pre> <p>Build to see the new ConfigMap:</p> <pre><code>nixidy build .#dev\ncat result/nginx/ConfigMap-nginx-html.yaml\n</code></pre>"},{"location":"user_guide/getting_started/#adding-multiple-applications","title":"Adding Multiple Applications","text":"<p>You can define multiple applications in the same file or split them into separate modules:</p> env/dev.nix<pre><code>{\n  nixidy.target.repository = \"https://github.com/YOUR_USERNAME/my-cluster.git\";\n  nixidy.target.branch = \"main\";\n  nixidy.target.rootPath = \"./manifests/dev\";\n\n  # First application\n  applications.nginx = {\n    namespace = \"nginx\";\n    createNamespace = true;\n    resources.deployments.nginx.spec = {\n      selector.matchLabels.app = \"nginx\";\n      template = {\n        metadata.labels.app = \"nginx\";\n        spec.containers.nginx.image = \"nginx:1.25.1\";\n      };\n    };\n  };\n\n  # Second application\n  applications.redis = {\n    namespace = \"redis\";\n    createNamespace = true;\n    resources.deployments.redis.spec = {\n      selector.matchLabels.app = \"redis\";\n      template = {\n        metadata.labels.app = \"redis\";\n        spec.containers.redis.image = \"redis:7\";\n      };\n    };\n  };\n}\n</code></pre>"},{"location":"user_guide/getting_started/#project-structure","title":"Project Structure","text":"<p>A typical nixidy project looks like this:</p> <pre><code>my-cluster/\n\u251c\u2500\u2500 flake.nix              # Project definition\n\u251c\u2500\u2500 flake.lock             # Locked dependencies\n\u251c\u2500\u2500 env/\n\u2502   \u251c\u2500\u2500 dev.nix            # Development environment\n\u2502   \u251c\u2500\u2500 staging.nix        # Staging environment\n\u2502   \u2514\u2500\u2500 prod.nix           # Production environment\n\u251c\u2500\u2500 modules/\n\u2502   \u251c\u2500\u2500 default.nix        # Common module that imports all applications\n\u2502   \u251c\u2500\u2500 nginx.nix          # Reusable nginx module\n\u2502   \u2514\u2500\u2500 redis.nix          # Reusable redis module\n\u2514\u2500\u2500 manifests/             # Generated manifests\n    \u251c\u2500\u2500 dev/\n    \u251c\u2500\u2500 staging/\n    \u2514\u2500\u2500 prod/\n</code></pre>"},{"location":"user_guide/getting_started/#common-commands","title":"Common Commands","text":"Command Description <code>nixidy info .#dev</code> Show environment info <code>nixidy build .#dev</code> Build manifests to <code>./result</code> <code>nixidy switch .#dev</code> Sync manifests to target directory <code>nixidy bootstrap .#dev</code> Output bootstrap Application YAML <code>nixidy apply .#dev</code> Apply directly to cluster"},{"location":"user_guide/getting_started/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user_guide/getting_started/#nixidy-command-not-found","title":"\"nixidy: command not found\"","text":"<p>Make sure you're in the development shell:</p> <pre><code>nix develop\n</code></pre> <p>Or run nixidy directly:</p> <pre><code>nix run .#nixidy -- build .#dev\n</code></pre>"},{"location":"user_guide/getting_started/#build-fails-with-type-errors","title":"Build fails with type errors","text":"<p>Nixidy validates your configuration against Kubernetes schemas. Check the error message for the specific field that's incorrect. Common issues:</p> <ul> <li>Wrong types (string instead of number)</li> <li>Misspelled field names</li> </ul>"},{"location":"user_guide/getting_started/#next-steps","title":"Next Steps","text":"<p>Now that you have a working nixidy project, explore these topics:</p> <ul> <li>Helm Charts \u2014 Use existing Helm charts in your applications</li> <li>Templates \u2014 Create reusable application patterns</li> <li>Git Strategies \u2014 Organize manifests across branches or repositories</li> <li>GitHub Actions \u2014 Automate manifest generation in CI</li> <li>Direct Apply \u2014 Deploy without Argo CD</li> </ul>"},{"location":"user_guide/getting_started/#example-repository","title":"Example Repository","text":"<p>For a complete real-world example, check out arnarg/cluster.</p>"},{"location":"user_guide/git_strategies/","title":"Git Strategies","text":"<p>When it comes to planning out how to structure the git repositories for your environments some options are available.</p>"},{"location":"user_guide/git_strategies/#monorepo","title":"Monorepo","text":"<p>With this strategy everything happens on the <code>main</code>/<code>master</code> branch. With every change to nixidy modules should result in a rebuild and the resulting manifests will be put in a sub-directory on the same branch.</p> <p></p> <p>The biggest gain from using this strategy is fast iteration locally as any change made to a nixidy module can be previewed by running <code>nixidy switch .#&lt;env&gt;</code> and then followed by <code>git diff</code> to see what has actually changed in the generated manifests.</p> <p>This strategy does require more complicated access control mechanism such as CODEOWNER file to make sure not everyone can change the generated manifests.</p>"},{"location":"user_guide/git_strategies/#setup","title":"Setup","text":"<p>In a module that's common to all the environment the target repository and branch needs to be set.</p> modules/default.nix<pre><code>{\n  # Set the target repository for the rendered manifests\n  # and applications.\n  # This should be replaced with yours.\n  nixidy.target.repository = \"https://github.com/arnarg/nixidy-demo.git\";\n\n  # Set the target branch the rendered manifests for every\n  # environment should be pushed to in the repository defined\n  # above.\n  nixidy.target.branch = \"main\";\n}\n</code></pre> <p>And in a module that's specific to each environment the target root path needs to be set.</p> env/dev.nix<pre><code>{\n  # Set the target sub-directory to copy the generated\n  # manifests to when running `nixidy switch .#dev`.\n  nixidy.target.rootPath = \"./manifests/dev\";\n}\n</code></pre> <p>Tip</p> <p>When using <code>mkEnvs</code> from nixidy, each environment's <code>rootPath</code> is automatically set to <code>./manifests/${dev}</code>.</p>"},{"location":"user_guide/git_strategies/#environment-branches","title":"Environment branches","text":"<p>With this strategy generated manifests are committed and pushed to separate environment specific branches. As these branches will not share any git history with the <code>main</code> branch or other environment branches (this is not git flow) they need to be created as orphan branches.</p> <p></p> <p>The biggest gain from this strategy is that it's simpler to implement access control compared to the monorepo, the branches can be setup with basic branch protection rules.</p>"},{"location":"user_guide/git_strategies/#setup_1","title":"Setup","text":"<p>In a module that's common to all the environments the target repository needs to be set. Unless you want the root path to differ between the environment's that can also be set here.</p> modules/default.nix<pre><code>{\n  # Set the target repository for the rendered manifests\n  # and applications.\n  # This should be replaced with yours.\n  nixidy.target.repository = \"https://github.com/arnarg/nixidy-demo.git\";\n\n  # The generated manifests should be at the root of\n  # each environment branch.\n  nixidy.target.rootPath = \"./\";\n}\n</code></pre> <p>And in a module that's specific to each environment the target branch needs to be set.</p> env/dev.nix<pre><code>{\n  # Set the target branch the rendered manifests for _this_\n  # environment should be pushed to in the repository defined\n  # above.\n  nixidy.target.branch = \"env/dev\";\n}\n</code></pre> <p>Info</p> <p>The environment branches need to be created manually and they need to be created as orphan branches.</p> <pre><code>git checkout --orphan env/dev\necho \"# env/dev\" &gt; README.md\ngit add README.md\ngit commit -m \"Initial commmit\"\ngit push -u origin env/dev\n</code></pre>"},{"location":"user_guide/git_strategies/#environment-repositories","title":"Environment repositories","text":"<p>With this strategy generated manifests are committed and pushed to separate repositories entirely.</p> <p></p> <p>The biggest gain from this strategy is that it's possible to go even further with access control from the environment branches.</p>"},{"location":"user_guide/git_strategies/#setup_2","title":"Setup","text":"<p>In a module that's common to all the branches only the root path should be set, unless that should differ between the environments.</p> modules/default.nix<pre><code>{\n  # The generated manifests should be at the root of\n  # each environment repository.\n  nixidy.target.rootPath = \"./\";\n}\n</code></pre> <p>And in a module that's specific to each environment the target repository and target branch needs to be set.</p> env/dev.nix<pre><code>{\n  # Set the target repository for the rendered manifests\n  # and applications.\n  # This should be replaced with yours.\n  nixidy.target.repository = \"https://github.com/arnarg/nixidy-demo-dev.git\";\n\n  # Set the target branch the rendered manifests for _this_\n  # environment should be pushed to in the repository defined\n  # above.\n  nixidy.target.branch = \"main\";\n}\n</code></pre>"},{"location":"user_guide/github_actions/","title":"GitHub Actions","text":"<p>Nixidy offers two GitHub Actions to build and switch to an environment.</p>"},{"location":"user_guide/github_actions/#arnargnixidyactionsbuild","title":"arnarg/nixidy/actions/build","text":"<p>This action will run <code>nixidy build</code> on a specified environment. It will not produce a <code>result</code> symlink and instead will have the output path in it's output <code>out-path</code>.</p>"},{"location":"user_guide/github_actions/#example","title":"Example","text":"<pre><code>name: Generate Kubernetes manifests\n\non:\n  push:\n    branches:\n      - main\n    paths-ignore:\n      - manifests/**\n\njobs:\n  generate:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v4\n\n    - uses: cachix/install-nix-action@v31\n      with:\n        # The `arnarg/nixidy/actions/build` action depends\n        # on nix flakes to run the actual nixidy cli.\n        # Therefore the following setting is required even\n        # when using nixidy with non-flakes.\n        extra_nix_config: |\n          extra-experimental-features = nix-command flakes\n\n    - uses: arnarg/nixidy/actions/build@main\n      id: build\n      with:\n        environment: .#dev\n        # Without flakes:\n        # environment: dev\n\n    - shell: bash\n      run: |\n        rsync --recursive --delete '${{steps.build.outputs.out-path}}/' manifests\n\n    - uses: EndBug/add-and-commit@v9\n      id: commit\n      with:\n        default_author: github_actions\n        message: \"chore: promote to dev ${{github.sha}}\"\n        fetch: false\n        new_branch: promote/env/dev\n        push: --set-upstream origin promote/env/dev --force\n\n    - uses: thomaseizinger/create-pull-request@1.4.0\n      if: ${{ steps.commit.outputs.pushed == 'true' }}\n      with:\n        github_token: ${{github.token}}\n        head: promote/env/dev\n        base: main\n        title: \"chore: promote to dev ${{github.sha}}\"\n</code></pre>"},{"location":"user_guide/github_actions/#arnargnixidyactionsswitch","title":"arnarg/nixidy/actions/switch","text":"<p>This action will run <code>nixidy switch</code> on a specified environment.</p>"},{"location":"user_guide/github_actions/#example_1","title":"Example","text":"<pre><code>name: Generate Kubernetes manifests\n\non:\n  push:\n    branches:\n      - main\n    paths-ignore:\n      - manifests/**\n\njobs:\n  generate:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v4\n\n    - uses: cachix/install-nix-action@v31\n      with:\n        # The `arnarg/nixidy/actions/switch` action depends\n        # on nix flakes to run the actual nixidy cli.\n        # Therefore the following setting is required even\n        # when using nixidy with non-flakes.\n        extra_nix_config: |\n          extra-experimental-features = nix-command flakes\n\n    - uses: arnarg/nixidy/actions/switch@main\n      with:\n        environment: .#dev\n        # Without flakes:\n        # environment: dev\n\n    - uses: EndBug/add-and-commit@v9\n      id: commit\n      with:\n        default_author: github_actions\n        message: \"chore: promote to dev ${{github.sha}}\"\n        fetch: false\n        new_branch: promote/env/dev\n        push: --set-upstream origin promote/env/dev --force\n\n    - uses: thomaseizinger/create-pull-request@1.4.0\n      if: ${{ steps.commit.outputs.pushed == 'true' }}\n      with:\n        github_token: ${{github.token}}\n        head: promote/env/dev\n        base: main\n        title: \"chore: promote to dev ${{github.sha}}\"\n</code></pre>"},{"location":"user_guide/helm_charts/","title":"Using Helm Charts","text":"<p>For better or for worse majority of software that's deployable to Kubernetes is packaged using Helm by developers or its community. It would be a waste not to use them and having to define all of its manifest yourself in nixidy.</p>"},{"location":"user_guide/helm_charts/#adding-a-helm-release-as-part-of-an-application","title":"Adding a Helm release as part of an application","text":"<p>Nixidy supports rendering Helm charts as part of applications. This can be done by specifying <code>applications.&lt;applicationName&gt;.helm.releases.&lt;releaseName&gt;</code>.</p>"},{"location":"user_guide/helm_charts/#example","title":"Example","text":"<pre><code>{lib, ...}: {\n  applications.traefik = {\n    namespace = \"traefik\";\n    createNamespace = true;\n\n    helm.releases.traefik = {\n      # Use `lib.helm.downloadHelmChart` to fetch\n      # the Helm Chart to use.\n      chart = lib.helm.downloadHelmChart {\n        repo = \"https://traefik.github.io/charts/\";\n        chart = \"traefik\";\n        version = \"25.0.0\";\n        chartHash = \"sha256-ua8KnUB6MxY7APqrrzaKKSOLwSjDYkk9tfVkb1bqkVM=\";\n      };\n\n      # Example values to pass to the Helm Chart.\n      values = {\n        ingressClass.enabled = true;\n      };\n    };\n  };\n}\n</code></pre>"},{"location":"user_guide/helm_charts/#patching-manifests-rendered-by-helm","title":"Patching manifests rendered by Helm","text":"<p>In some cases the Helm Chart doesn't support changing certain aspects of the final manifests. These can be modified to nixidy by overriding certain fields.</p>"},{"location":"user_guide/helm_charts/#example_1","title":"Example","text":"<pre><code>{lib, ...}: {\n  applications.traefik = {\n    namespace = \"traefik\";\n    createNamespace = true;\n\n    helm.releases.traefik = {\n      # Use `lib.helm.downloadHelmChart` to fetch\n      # the Helm Chart to use.\n      chart = lib.helm.downloadHelmChart {\n        repo = \"https://traefik.github.io/charts/\";\n        chart = \"traefik\";\n        version = \"25.0.0\";\n        chartHash = \"sha256-ua8KnUB6MxY7APqrrzaKKSOLwSjDYkk9tfVkb1bqkVM=\";\n      };\n\n      # Example values to pass to the Helm Chart.\n      values = {\n        ingressClass.enabled = true;\n      };\n    };\n\n    resources = {\n      # Add a label to the traefik pod and change\n      # the image.\n      deployments.traefik.spec.template = {\n        metadata.labels.my-custom-label = \"my-custom-values\";\n        spec.containers.traefik.image = lib.mkForce \"my-registry.io/patched-traefik:v3.0.0\";\n      };\n    };\n  };\n}\n</code></pre>"},{"location":"user_guide/templates/","title":"Templates","text":"<p>Templates provide a powerful way to define reusable configurations for your applications, reducing duplication and promoting consistency. A template encapsulates a set of configurable options and a function to generate Kubernetes resources based on those options.</p>"},{"location":"user_guide/templates/#defining-a-template","title":"Defining a Template","text":"<p>You define templates within the <code>templates</code> option in your nixidy configuration. Each template requires two main attributes:</p> <ul> <li><code>options</code>: A set of module options that define the configurable parameters for your template.</li> <li><code>output</code>: A Nix function that takes the template instance's <code>name</code> and its <code>config</code> (derived from the <code>options</code> you defined) and returns a set of nixidy resources (e.g., deployments, services, ingresses).</li> </ul>"},{"location":"user_guide/templates/#example-webapplication-template","title":"Example: <code>webApplication</code> Template","text":"<p>Let's look at an example of a <code>webApplication</code> template, which defines common settings for a web application and generates a Kubernetes Deployment, Service, and an optional Ingress.</p> modules/templates.nix<pre><code>{lib, ...}: {\n  templates.webApplication = {\n    options = with lib; {\n      image = mkOption {\n        type = lib.types.str;\n        description = \"The image to use in the web application deployment\";\n      };\n      replicas = mkOption {\n        type = lib.types.int;\n        default = 3;\n        description = \"The number of replicas for the web application deployment.\";\n      };\n      port = mkOption {\n        type = lib.types.port;\n        default = 8080;\n        description = \"The web application's port.\";\n      };\n      ingressHost = mkOption {\n        type = with lib.types; nullOr str;\n        default = null;\n        description = \"The application's ingress host. Set to null to disable ingress.\";\n      };\n    };\n\n    output = {\n      name,\n      config,\n      ...\n    }: let\n      cfg = config;\n      appLabels = {\n        \"app.kubernetes.io/name\" = name;\n        \"app.kubernetes.io/instance\" = name;\n      };\n    in {\n      deployments.\"${name}\".spec = {\n        replicas = cfg.replicas;\n        selector.matchLabels = appLabels;\n        template = {\n          metadata.labels = appLabels;\n          spec.containers.\"${name}\" = {\n            image = cfg.image;\n            ports.\"http\".containerPort = cfg.port;\n          };\n        };\n      };\n\n      services.\"${name}\".spec = {\n        selector = appLabels;\n        ports.http = {\n          port = cfg.port;\n          targetPort = cfg.port;\n        };\n      };\n\n      ingresses = lib.mkIf (cfg.ingressHost != null) {\n        \"${name}\".spec = {\n          rules = [\n            {\n              host = cfg.ingressHost;\n              http.paths = [\n                {\n                  path = \"/\";\n                  pathType = \"Prefix\";\n                  backend.service = {\n                    inherit name;\n                    port.number = cfg.port;\n                  };\n                }\n              ];\n            }\n          ];\n        };\n      };\n    };\n  };\n}\n</code></pre> <p>In this example:</p> <ul> <li>The <code>webApplication</code> template defines <code>image</code>, <code>replicas</code>, <code>port</code>, and <code>ingressHost</code> as configurable options.</li> <li>The <code>output</code> function takes the <code>name</code> of the instance and its <code>config</code> (which will contain the values for <code>image</code>, <code>replicas</code>, etc.). It then uses these values to construct Kubernetes Deployment, Service, and Ingress resources.</li> </ul>"},{"location":"user_guide/templates/#using-a-template","title":"Using a Template","text":"<p>Once a template is defined you can use it within an application by referring to it under the <code>templates</code> attribute set of your application.</p> modules/webapp.nix<pre><code>{ config, lib, ... }: {\n  imports = [\n    ./templates.nix\n  ];\n\n  applications.webapp = {\n    templates.webApplication = {\n      # Use the template in an application.\n      frontend = {\n        image = \"frontend:latest\";\n        replicas = 1;\n        ingressHost = \"example.com\";\n      };\n    };\n\n    # You can still modify the generated resources.\n    resources = {\n      # Add extra label to the deployment.\n      deployments.frontend.metadata.labels = {\n        \"custom-label\" = \"frontend\";\n      };\n    };\n  };\n}\n</code></pre> <p>Here, <code>applications.webapp.templates.webApplication.frontend</code> instantiates the <code>webApplication</code> template.</p> <ul> <li><code>webApplication</code> refers to the name of the template we defined.</li> <li><code>frontend</code> is the instance name for this specific use of the template. This name is passed to the <code>output</code> function as <code>name</code>.</li> <li>The attributes <code>image</code>, <code>replicas</code>, and <code>ingressHost</code> are the options we're setting for this <code>frontend</code> instance of the <code>webApplication</code> template. The <code>port</code> option is omitted, so it will use its default value of <code>8080</code>.</li> </ul> <p>When nixidy evaluates this configuration, it will call the <code>output</code> function of the <code>webApplication</code> template with <code>name = \"frontend\"</code> and <code>config</code> containing the provided options, generating the corresponding Kubernetes resources under <code>applications.webapp.resources</code>.</p>"},{"location":"user_guide/transformers/","title":"Transformers","text":"<p>Nixidy supports adding a transformers to Helm releases and Kustomize applications. A transformer is only a function that takes in a list of Kubernetes manifests in attribute sets and returns the same (<code>[AttrSet] -&gt; [AttrSet]</code>). It is called after the manifests have been rendered and parsed into nix but before they're transformed into the nixidy form (<code>&lt;group&gt;.&lt;version&gt;.&lt;kind&gt;.&lt;name&gt;</code>) and can be used to modify the resources.</p> <p>Transformers can be set globally in <code>nixidy.defaults.helm.transformer</code> for Helm releases and <code>nixidy.defaults.kustomize.transformer</code> for kustomize applications.</p>"},{"location":"user_guide/transformers/#remove-version-specific-labels","title":"Remove Version Specific Labels","text":"<p>It's very common that helm charts will add the labels <code>helm.sh/chart</code> and <code>app.kubernetes.io/version</code> to all resources it renders. This can produce very big diffs when they're updated and nixidy renders them and commits the manifests to a git branch. The changes in these labels are not very relevant and will mostly just be noise to distract from the actual relevant changes of the rendered output.</p> <p>A transformer can be used to filter out these labels.</p> <pre><code>{\n  applications.argocd.helm.releases.argocd = {\n    # ...\n\n    # Remove the following labels from all manifests\n    transformer = map (lib.kube.removeLabels [\n      \"app.kubernetes.io/version\"\n      \"helm.sh/chart\"\n    ]);\n  }\n}\n</code></pre> <p>Here we use map to call <code>lib.kube.removeLabels</code> on each manifest in the list to remove the specified labels. The example uses function currying, this is equivalent to <code>manifests: map (m: lib.kube.removeLabels [\"...\"] m) manifests</code>.</p>"},{"location":"user_guide/typed_resources/","title":"Typed Resource Options","text":"<p>Kubenix has done a great work with generating nix options definitions from official JSON schemas and nixidy builds on top of this.</p> <p>All core Kubernetes resources are imported by default in nixidy along with Argo CD's <code>Application</code> and <code>AppProject</code>. Every resource can be defined under <code>applications.&lt;applicationName&gt;.resources.&lt;group&gt;.&lt;version&gt;.&lt;kind&gt;</code> but is also offered as an alias <code>applications.&lt;applicationName&gt;.resources.&lt;attrName&gt;</code> where <code>&lt;attrName&gt;</code> is the plural form of the kind in camelCase.</p> <p>For example:</p> <ul> <li><code>resources.core.v1.Service</code> -&gt; <code>resources.services</code></li> <li><code>resources.\"networking.k8s.io\".v1.NetworkPolicy</code> -&gt; <code>resources.networkPolicies</code></li> </ul> <p>The lack of availability of typed resource options only hinders the ability to define the resources in nix. Any manifests that are rendered from a Helm Chart or defined in <code>applications.&lt;applicationName&gt;.yamls</code> and do not have defined resource options for that group, version and kind will go straight to the output for the application and can not be patched by nixidy.</p>"},{"location":"user_guide/typed_resources/#generating-your-own-resource-options-from-crds","title":"Generating your own resource options from CRDs","text":"<p>Thankfully a code generator for generating resource options from CRDs is provided by nixidy (this is based heavily on kubenix's code generator).</p> <p>As an example, to generate resource options for Cilium's <code>CiliumNetworkPolicy</code> and <code>CiliumClusterwideNetworkPolicy</code> the following can be defined in <code>flake.nix</code>.</p> flake.nix<pre><code>{\n  description = \"My ArgoCD configuration with nixidy.\";\n  inputs.nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n  inputs.flake-utils.url = \"github:numtide/flake-utils\";\n  inputs.nixidy = {\n    url = \"github:arnarg/nixidy\";\n    inputs.nixpkgs.follows = \"nixpkgs\";\n  };\n  outputs = {\n    self,\n    nixpkgs,\n    flake-utils,\n    nixidy,\n  }: (flake-utils.lib.eachDefaultSystem (system: let\n    pkgs = import nixpkgs {\n      inherit system;\n    };\n  in {\n    packages = {\n      generators.cilium = nixidy.packages.${system}.generators.fromCRD {\n        name = \"cilium\";\n        src = pkgs.fetchFromGitHub {\n          owner = \"cilium\";\n          repo = \"cilium\";\n          rev = \"v1.15.6\";\n          hash = \"sha256-oC6pjtiS8HvqzzRQsE+2bm6JP7Y3cbupXxCKSvP6/kU=\";\n        };\n        crds = [\n          \"pkg/k8s/apis/cilium.io/client/crds/v2/ciliumnetworkpolicies.yaml\"\n          \"pkg/k8s/apis/cilium.io/client/crds/v2/ciliumclusterwidenetworkpolicies.yaml\"\n        ];\n      };\n    };\n  }));\n}\n</code></pre> <p>Then running <code>nix build .#generators.cilium</code> will produce a nix file that can be copied into place in your repository. After that the generated file has to be added to <code>nixidy.applicationImports</code> in your nixidy modules.</p> env/dev.nix<pre><code>{\n  nixidy.applicationImports = [\n    ./generated/cilium.nix\n  ];\n}\n</code></pre> Using nixidy without flakes <p>If you prefer not to use flakes, you can write the following in <code>generate.nix</code>.</p> generate.nix<pre><code>let\n  # With npins\n  sources = import ./npins;\n  # With niv\n  # sources = import ./nix/sources.nix;\n\n  # nixpkgs added with:\n  #   npins: `npins add --name nixpkgs channel nixos-unstable`\n  #   niv: `niv add github nixos/nixpkgs -b nixos-unstable`\n  nixpkgs = sources.nixpkgs;\n  pkgs = import nixpkgs {};\n\n  # Import nixidy\n  nixidy = import sources.nixidy {inherit nixpkgs;};\nin\n  {\n    cilium = nixidy.generators.fromCRD {\n      name = \"cilium\";\n      src = pkgs.fetchFromGitHub {\n        owner = \"cilium\";\n        repo = \"cilium\";\n        rev = \"v1.15.6\";\n        hash = \"sha256-oC6pjtiS8HvqzzRQsE+2bm6JP7Y3cbupXxCKSvP6/kU=\";\n      };\n      crds = [\n        \"pkg/k8s/apis/cilium.io/client/crds/v2/ciliumnetworkpolicies.yaml\"\n        \"pkg/k8s/apis/cilium.io/client/crds/v2/ciliumclusterwidenetworkpolicies.yaml\"\n      ];\n    };\n  }\n</code></pre> <p>Then running <code>nix-build generate.nix -A cilium</code> will produce a nix file that can be copied into place in your repository and imported using <code>nixidy.applicationImports</code> in a nixidy module.</p>"},{"location":"user_guide/typed_resources/#generating-resource-options-from-helm-chart-crds","title":"Generating resource options from Helm Chart CRDs","text":"<p>In some cases, CRDs are only available through Helm charts or it's beneficial to keep them in sync with the chart version you're deploying. The <code>fromChartCRD</code> function provides a solution by templating the Helm chart and extracting CRDs from the output, generating nixidy resource options from them.</p> <p>This approach also handles CRDs that include Helm templating within their definitions, which would not be properly processed by the regular <code>fromCRD</code> function.</p> <p>As an example, to generate resource options for cert-manager's <code>Certificate</code> CRD directly from the Helm chart:</p> flake.nix<pre><code>{\n  description = \"My ArgoCD configuration with nixidy.\";\n  inputs.nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n  inputs.flake-utils.url = \"github:numtide/flake-utils\";\n  inputs.nixidy = {\n    url = \"github:arnarg/nixidy\";\n    inputs.nixpkgs.follows = \"nixpkgs\";\n  };\n  inputs.nixhelm = {\n    url = \"github:farcaller/nixhelm\";\n    inputs.nixpkgs.follows = \"nixpkgs\";\n  };\n  outputs = {\n    self,\n    nixpkgs,\n    flake-utils,\n    nixidy,\n    nixhelm,\n  }: (flake-utils.lib.eachDefaultSystem (system: let\n    pkgs = import nixpkgs {\n      inherit system;\n    };\n  in {\n    packages = {\n      generators.certManager = nixidy.packages.${system}.generators.fromChartCRD {\n        name = \"cert-manager\";\n        chartAttrs = {\n          repo = \"https://charts.jetstack.io\";\n          chart = \"cert-manager\";\n          version = \"v1.19.1\";\n          chartHash = \"sha256-fs14wuKK+blC0l+pRfa//oBV2X+Dr3nNX+Z94nrQVrA=\";\n        };\n        # Or from nixhelm\n        # chart = nixhelm.chartsDerivations.${system}.jetstack.cert-manager;\n        crds = [ \"Certificate\" ];  # Optional: filter by specific CRD kinds\n      };\n    };\n  }));\n}\n</code></pre> <p>Then running <code>nix build .#generators.certManager</code> will produce a nix file that can be copied into place in your repository.</p> Using nixidy without flakes <p>If you prefer not to use flakes, you can write the following in <code>generate.nix</code>.</p> generate.nix<pre><code>let\n  # With npins\n  sources = import ./npins;\n  # With niv\n  # sources = import ./nix/sources.nix;\n\n  # nixpkgs added with:\n  #   npins: `npins add --name nixpkgs channel nixos-unstable`\n  #   niv: `niv add github nixos/nixpkgs -b nixos-unstable`\n  nixpkgs = sources.nixpkgs;\n  pkgs = import nixpkgs {};\n\n  # Import nixidy\n  nixidy = import sources.nixidy {inherit nixpkgs;};\nin\n  {\n    certManager = nixidy.generators.fromChartCRD {\n      name = \"cert-manager\";\n      chartAttrs = {\n        repo = \"https://charts.jetstack.io\";\n        chart = \"cert-manager\";\n        version = \"v1.19.1\";\n        chartHash = \"sha256-fs14wuKK+blC0l+pRfa//oBV2X+Dr3nNX+Z94nrQVrA=\";\n      };\n      crds = [ \"Certificate\" ];  # Optional: filter by specific CRD kinds\n    };\n  }\n</code></pre> <p>Then running <code>nix-build generate.nix -A certManager</code> will produce a nix file that can be copied into place in your repository and imported using <code>nixidy.applicationImports</code> in a nixidy module.</p> <p>The <code>fromChartCRD</code> function accepts the same optional arguments as <code>fromCRD</code> (<code>namePrefix</code>, <code>attrNameOverrides</code>, and <code>skipCoerceToList</code>) for customization of the generated options. Additionally, it accepts:</p> <ul> <li><code>chartAttrs</code>: Chart repository, name, version and chartHash configuration</li> <li><code>chart</code>: Alternative to <code>chartAttrs</code>, can use a pre-downloaded chart</li> <li><code>values</code>: Values to pass to the Helm chart templating</li> <li><code>crds</code>: List of CRD kinds to extract (empty list extracts all CRDs)</li> </ul> <p>This approach ensures your CRD definitions stay synchronized with the Helm chart version you're actually deploying in your applications.</p>"},{"location":"user_guide/typed_resources/#resolving-naming-conflicts","title":"Resolving Naming Conflicts","text":"<p>Sometimes, multiple Custom Resource Definitions from different sources might define the same resource <code>kind</code>. This can lead to conflicts in the generated attribute names. For instance, if two different operators both define a CRD with the kind <code>Database</code>, they would both try to generate options for <code>resources.databases</code>.</p> <p>To resolve this, the <code>fromCRD</code> function accepts a <code>namePrefix</code> argument. This prefix will be added to the generated attribute name, making it unique.</p> <p>For example, if you have two operators that both provide a <code>Database</code> CRD, you can distinguish them like this:</p> <pre><code>{\n  # For postgres-operator\n  postgres = nixidy.generators.fromCRD {\n    name = \"postgres-operator\";\n    namePrefix = \"postgres\";\n    # ...\n  };\n\n  # For mysql-operator\n  mysql = nixidy.generators.fromCRD {\n    name = \"mysql-operator\";\n    namePrefix = \"mysql\";\n    # ...\n  };\n}\n</code></pre> <p>This will generate <code>resources.postgresDatabases</code> and <code>resources.mysqlDatabases</code> respectively, avoiding any conflicts.</p> <p>If the heuristics for attribute name generation still create conflicts, for example within the same chart, or if you wish to further customize the name for ergonomics, <code>fromCRD</code> also accepts an <code>attrNameOverrides</code> argument which takes precedence over all other methods.</p> <p>This argument is a mapping from the CRD's name (<code>&lt;plural&gt;.&lt;group&gt;</code>) to the desired attribute name. For example:</p> <pre><code>{\n  keycloak = nixidy.generators.fromCRD {\n    name = \"keycloak\";\n    src = pkgs.fetchFromGitHub {\n      owner = \"crossplane-contrib\";\n      repo = \"provider-keycloak\";\n      ...\n    };\n    crds = [\n      # This CRD conflicts with Kubernetes builtin Binding\n      \"package/crds/authenticationflow.keycloak.crossplane.io_bindings.yaml\"\n      # These CRDs have identical plural references\n      \"package/crds/group.keycloak.crossplane.io_groups.yaml\"\n      \"package/crds/user.keycloak.crossplane.io_groups.yaml\"\n    ];\n    namePrefix = \"keycloak\";\n    attrNameOverrides.\"groups.user.keycloak.crossplane.io\" = \"keycloakUserGroups\";\n  };\n}\n</code></pre> <p>will expose <code>keycloakBindings</code>, <code>keycloakGroups</code>, and <code>keycloakUserGroups</code> under an application's <code>resources</code>.</p>"},{"location":"user_guide/using_nixhelm/","title":"Using nixhelm","text":"<p>nixhelm is a collection of Helm Charts that can be used with nix-kube-generators and as a result also nixidy. The charts are automatically updated to the most recent version by CI regularly.</p> <p>To use with nixidy, pass the nixhelm derivation attribute set to nixidy's <code>mkEnv</code> builder like so.</p> flake.nix<pre><code>{\n  description = \"My ArgoCD configuration with nixidy.\";\n  inputs.nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n  inputs.flake-utils.url = \"github:numtide/flake-utils\";\n  inputs.nixidy = {\n    url = \"github:arnarg/nixidy\";\n    inputs.nixpkgs.follows = \"nixpkgs\";\n  };\n  inputs.nixhelm = {\n    url = \"github:farcaller/nixhelm\";\n    inputs.nixpkgs.follows = \"nixpkgs\";\n  };\n  outputs = {\n    self,\n    nixpkgs,\n    flake-utils,\n    nixidy,\n    nixhelm,\n  }: (flake-utils.lib.eachDefaultSystem (system: let\n    pkgs = import nixpkgs {\n      inherit system;\n    };\n  in {\n    nixidyEnvs.dev = nixidy.lib.mkEnv {\n      inherit pkgs;\n      # Pass nixhelm to all nixidy modules.\n      charts = nixhelm.chartsDerivations.${system};\n      modules = [./env/dev.nix];\n    };\n  }));\n}\n</code></pre> Using nixidy without flakes <p>If you prefer not to use flakes, the following can be written to <code>default.nix</code> instead.</p> default.nix<pre><code>let\n  # With npins\n  sources = import ./npins;\n  # With niv\n  # sources = import ./nix/sources.nix;\n\n  # nixhelm added with:\n  #   npins: `npins add github farcaller nixhelm --branch master`\n  #   niv: `niv add github farcaller/nixhelm --branch master`\n  nixhelm = sources.nixhelm;\n\n  # Import nixidy\n  nixidy = import sources.nixidy {};\nin\n  nixidy.lib.mkEnvs {\n    # These modules get passed to every env.\n    modules = [\n      ({lib, ...}: {\n        # nixhelm is a flake so we can't just import it\n        # like we do in flakes (as an input).\n        # Thankfully the directory structure in nixhelm\n        # is compatible with the one expected by\n        # `lib.helm.mkChartAttrs`.\n        nixidy.charts = lib.helm.mkChartAttrs \"${nixhelm}/charts\";\n      })\n    ];\n\n    # This declares the available nixidy envs.\n    envs = {\n      # Currently we only have the one dev env.\n      dev.modules = [./env/dev.nix];\n    };\n  }\n</code></pre> <p>And then the argument <code>charts</code> will be passed to every module in nixidy.</p> ./env/dev.nix<pre><code>{\n  charts,\n  ...\n}: {\n  applications.traefik = {\n    namespace = \"traefik\";\n    createNamespace = true;\n\n    helm.releases.traefik = {\n      # Use the traefik helm chart from nixhelm.\n      chart = charts.traefik.traefik;\n\n      # Example values to pass to the Helm Chart.\n      values = {\n        ingressClass.enabled = true;\n      };\n    };\n  };\n}\n</code></pre>"},{"location":"user_guide/using_nixhelm/#provide-your-own-charts-not-available-in-nixhelm","title":"Provide your own charts not available in nixhelm","text":"<p>Not all charts are available in nixhelm and in such cases you can contribute an initial version to them or setup a specific folder structure locally to merge with the <code>charts</code> argument passed to modules.</p> <p>With the nixidy option <code>nixidy.chartsDir</code> that folder will be walked recursively and look for <code>default.nix</code> files that will build up the charts attribute set.</p> ./charts/kubernetes-csi/csi-driver-nfs/default.nix<pre><code>{\n  repo = \"https://raw.githubusercontent.com/kubernetes-csi/csi-driver-nfs/master/charts\";\n  chart = \"csi-driver-nfs\";\n  version = \"4.7.0\";\n  chartHash = \"sha256-EU2qaZglUU3vxa41l1p/2yBscksIhYMr8kSgH8t0vL8=\";\n}\n</code></pre> <p>And then in your nixidy modules you pass that <code>./charts</code> folder to <code>nixidy.chartsDir</code>.</p> ./env/dev.nix<pre><code>{charts, ...}: {\n  # Point nixidy to a directory with charts to add to\n  # the charts attribute set.\n  nixidy.chartsDir = ../charts;\n\n  # Use the nfs chart in an application.\n  applications.csi-driver-nfs = {\n    namespace = \"kube-system\";\n\n    helm.releases.csi-driver-nfs = {\n      chart = charts.kubernetes-csi.csi-driver-nfs;\n\n      # Pass some values overrides to the chart.\n      values = {};\n    };\n  };\n}\n</code></pre>"}]}