{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"nixidy","text":"<p>Kubernetes GitOps with nix and Argo CD.</p> <p>Kind of sounds like Nix CD.</p>"},{"location":"#why","title":"Why?","text":"<p>It's desirable to manage Kubernetes clusters in a declarative way using a git repository as a source of truth for manifests that should be deployed into the cluster. One popular solution that is often used to achieve this goal is Argo CD.</p> <p>Argo CD has a concept of applications. Each application has an entrypoint somewhere in your git repository that is either a Helm chart, kustomize application, jsonnet files or just a directory of YAML files. All the resources that are output when templating the helm chart, kustomizing the kustomize application or are defined in the YAML files in the directory, make up the application and are (usually) deployed into a single namespace.</p> <p>For those reasons these git repositories often need quite elaborate designs once many applications should be deployed, requiring use of application sets (generator for applications) or custom Helm charts just to render all the different applications of the repository.</p> <p>On top of that it can be quite obscure what exactly will be deployed by just looking at helm charts (along with all the values override, usually set for each environment) or the kustomize overlays (which often are many depending on number of environments/stages) without going in and just running <code>helm template</code> or <code>kubectl kustomize</code>.</p> <p>Having dealt with these design decisions and pains that come with the different approaches I'm starting to use The Rendered Manifests Pattern. While it's explained in way more detail in the linked blog post, basically it involves using your CI system to pre-render the helm charts or the kustomize overlays and commit all the rendered manifests to an environment branch (or go through a pull request review where you can review the exact changes to your environment). That way you can just point Argo CD to your different directories full of rendered YAML manifests without having to do any helm templating or kustomize rendering.</p>"},{"location":"#nixos-module-system","title":"NixOS' Module System","text":"<p>I have been a user and a fan of NixOS for many years and how its module system works to recursively merge all configuration options that are set in many different modules. Combine that with the power of nix (the language) and generating declarative configurations becomes a breeze.</p> <p>I have not been a fan of helm's string templating of a whitespace-sensitive configuration language or kustomize's repitition (defining a <code>kustomization.yaml</code> file for each layer statically listing files to include, some are json patches some are not...).</p> <p>Therefore I made nixidy as an experiment to see if I can make something better (at least for myself). As all Argo CD applications are defined in a single configuration it can reference configuration options across applications and automatically generate an App of Apps bootstrapping all of them.</p>"},{"location":"#demo","title":"Demo","text":"<p>See nixidy-demo.</p>"},{"location":"#non-goals","title":"Non Goals","text":""},{"location":"#typed-resource-definitions","title":"Typed Resource Definitions","text":"<p>nixidy does not concern itself with defining typed options for every possible Kubernetes resource like is done with kubenix. This approach requires automatic generation from JSON schemas of all supported resources, and needs to be updated for every new release of Kubernetes.</p> <p>That also means that it will explicitly need to support every different CRD from applications it wants to deploy.</p> <p>Instead it allows for outputing any structure as long as it's under <code>&lt;apiVersion&gt;.&lt;kind&gt;.&lt;name&gt;</code> and let Argo CD surface the error if the data is not a valid Kubernetes manifest.</p>"},{"location":"#special-thanks","title":"Special Thanks","text":"<p>farcaller/nix-kube-generators is used internally to pull and render Helm charts and some functions are re-exposed in the lib passed to modules in nixidy.</p>"},{"location":"library/","title":"Libary Functions","text":"<p>The argument <code>lib</code> is passed to each module in nixidy. This is a standard nixpkgs library extended with the following functions.</p>"},{"location":"library/#libresourcesfrommanifests","title":"lib.resources.fromManifests","text":"<p>Type: <code>fromManifests :: [AttrSet] -&gt; AttrSet</code></p> <p>Convert a list of kubernetes manifests (already parsed from YAML/JSON) to the resources format used in nixidy.</p> <code>manifests</code> <p>List of kubernetes manifests in nix AttrSet.</p> <p>Example:</p> <pre><code>fromManifests [\n  {\n    apiVersion = \"v1\";\n    kind = \"Namespace\";\n    metadata.name = \"default\";\n  }\n  {\n    apiVersion = \"v1\";\n    kind = \"ConfigMap\";\n    metadata = {\n      name = \"config\";\n      namespace = \"default\";\n    };\n    data = {\n      key1 = \"val1\";\n      key2 = \"val2\";\n    };\n  }\n]\n=&gt; {\n  v1 = {\n    Namespace.default = {};\n    ConfigMap.config = {\n      metadata.namespace = \"default\";\n      data = {\n        key1 = \"val1\";\n        key2 = \"val2\";\n      };\n    };\n  };\n}\n</code></pre>"},{"location":"library/#libresourcesfrommanifestyamls","title":"lib.resources.fromManifestYAMLs","text":"<p>Type: <code>fromManifestYAMLs :: [String] -&gt; AttrSet</code></p> <p>Convert a list of kubernetes manifests in YAML to the resources format used in nixidy.</p> <code>yamls</code> <p>List of kubernetes manifests in YAML.</p> <p>Example:</p> <pre><code>fromManifestYAMLs [\n  ''\n    apiVersion: v1\n    kind: Namespace\n    metadata:\n      name: default\n''\n''\n    apiVersion: v1\n    kind: ConfigMap\n    metadata:\n      name: config\n      namespace: default\n    data:\n      key1: val1\n      key2: val2\n''\n]\n=&gt; {\n  v1 = {\n    Namespace.default = {};\n    ConfigMap.config = {\n      metadata.namespace = \"default\";\n      data = {\n        key1 = \"val1\";\n        key2 = \"val2\";\n      };\n    };\n  };\n}\n</code></pre>"},{"location":"library/#libresourcesfrommanifestfiles","title":"lib.resources.fromManifestFiles","text":"<p>Type: <code>fromManifestFiles :: [Derivation] -&gt; AttrSet</code></p> <p>Read and convert a list of kubernetes manifests in files to the resources format used in nixidy.</p> <code>files</code> <p>List of derivations where the output is a single file containing kubernetes manifests in YAML.</p> <p>Example:</p> <pre><code>fromManifestFiles [\n  ./namespace.yaml\n  ./configmap.yaml\n]\n=&gt; {\n  v1 = {\n    Namespace.default = {};\n    ConfigMap.config = {\n      metadata.namespace = \"default\";\n      data = {\n        key1 = \"val1\";\n        key2 = \"val2\";\n      };\n    };\n  };\n}\n</code></pre>"},{"location":"library/#libresourcesfromkustomization","title":"lib.resources.fromKustomization","text":"<p>Type: <code>fromKustomization :: AttrSet -&gt; AttrSet</code></p> <p>Render a kustomization and convert the resources to the resources format used in nixidy.</p> structured function argument <p><code>name</code></p> <p>Name is only used for derivation name.</p> <code>src</code> <p>Derivation containing the kustomization entrypoint and all relative bases that it might reference.</p> <code>path</code> <p>Relative path from the base of <code>src</code> to the kustomization folder to render.</p> <code>namespace</code> <p>Override namespace in kustomization.yaml.</p> <p>Example:</p> <pre><code>fromKustomization {\n  name = \"argocd\";\n  src = pkgs.fetchFromGitHub {\n    owner = \"argoproj\";\n    repo = \"argo-cd\";\n    rev = \"v2.9.3\";\n    hash = \"sha256-GaY4Cw/LlSwy35umbB4epXt6ev8ya19UjHRwhDwilqU=\";\n  };\n  path = \"manifests/cluster-install\";\n  namespace = \"argocd\";\n}\n=&gt; {\n  v1 = {\n    Namespace.argocd = {};\n  };\n  # ...\n}\n</code></pre>"},{"location":"library/#libresourcesfromhelmchart","title":"lib.resources.fromHelmChart","text":"<p>Type: <code>fromHelmChart :: AttrSet -&gt; AttrSet</code></p> <p>Render a helm chart and convert the resources to the resources format used in nixidy. This function uses nix-kube-generators' <code>buildHelmChart</code> to do the helm templating.</p> <code>args</code> <p>Function argument</p> <p>Example:</p> <pre><code>fromHelmChart {\n  name = \"argocd\";\n  chart = lib.helm.downloadHelmChart {\n    repo = \"https://argoproj.github.io/argo-helm/\";\n    chart = \"argo-cd\";\n    version = \"5.51.4\";\n    chartHash = \"sha256-LOEJ5mYaHEA0RztDkgM9DGTA0P5eNd0SzSlwJIgpbWY=\";\n  };\n  namespace = \"argocd\";\n  values = {\n    server.replicas = 2;\n  };\n}\n=&gt; {\n  v1 = {\n    Namespace.argocd = {};\n  };\n  # ...\n}\n</code></pre>"},{"location":"library/#libhelmdownloadhelmchart","title":"lib.helm.downloadHelmChart","text":"<p>Type: <code>downloadHelmChart :: AttrSet -&gt; Derivation</code></p> <p>Downloads a helm chart from a helm registry.</p> <p>This is re-exported directly from farcaller/nix-kube-generators.</p>"},{"location":"library/#libhelmbuildhelmchart","title":"lib.helm.buildHelmChart","text":"<p>Type: <code>buildHelmChart :: AttrSet -&gt; Derivation</code></p> <p>Templates a helm chart with provided values and creates a derivation with the output.</p> <p>This is re-exported directly from farcaller/nix-kube-generators.</p>"},{"location":"library/#libhelmgetchartvalues","title":"lib.helm.getChartValues","text":"<p>Type: <code>getChartValues :: Derivation -&gt; AttrSet</code></p> <p>Parse the default values file shipped with the helm chart.</p> <code>chart</code> <p>Derivation containing helm chart. Usually output of lib.helm.downloadHelmChart.</p> <p>Example:</p> <pre><code>getChartValues (lib.helm.downloadHelmChart {\n    repo = \"https://argoproj.github.io/argo-helm/\";\n    chart = \"argo-cd\";\n    version = \"5.51.4\";\n    chartHash = \"sha256-LOEJ5mYaHEA0RztDkgM9DGTA0P5eNd0SzSlwJIgpbWY=\";\n})\n=&gt; {\n  server.replicas = 1;\n  controller.replicas = 1;\n  # ...\n}\n</code></pre>"},{"location":"library/#libkustomizebuildkustomization","title":"lib.kustomize.buildKustomization","text":"<p>Type: <code>buildKustomization :: AttrSet -&gt; Derivation</code></p> <p>Builds a kustomization and creates a derivation with the output.</p> structured function argument <p><code>name</code></p> <p>Name is only used for derivation name.</p> <code>src</code> <p>Derivation containing the kustomization entrypoint and all relative bases that it might reference.</p> <code>path</code> <p>Relative path from the base of <code>src</code> to the kustomization folder to render.</p> <code>namespace</code> <p>Override namespace in kustomization.yaml.</p> <p>Example:</p> <pre><code>buildKustomization {\n  name = \"argocd\";\n  src = pkgs.fetchFromGitHub {\n    owner = \"argoproj\";\n    repo = \"argo-cd\";\n    rev = \"v2.9.3\";\n    hash = \"sha256-GaY4Cw/LlSwy35umbB4epXt6ev8ya19UjHRwhDwilqU=\";\n  };\n  path = \"manifests/cluster-install\";\n  namespace = \"argocd\";\n}\n=&gt; /nix/store/7i52...7pww-kustomize-argocd\n</code></pre>"},{"location":"library/#libkubefromyaml","title":"lib.kube.fromYAML","text":"<p>Type: <code>fromYAML :: String -&gt; [AttrSet]</code></p> <p>Parses a YAML document string into a list of attribute sets.</p> <p>This is re-exported directly from farcaller/nix-kube-generators.</p> <code>yaml</code> <p>String with a yaml document.</p> <p>Example:</p> <pre><code>fromYAML ''\n  apiVersion: v1\n  kind: Namespace\n  metadata:\n    name: default\n  ---\n  apiVersion: v1\n  kind: Namespace\n  metadata:\n    name: kube-system\n''\n=&gt; [\n  {\n    apiVersion = \"v1\";\n    kind = \"Namespace\";\n    metadata.name = \"default\";\n  }\n  {\n    apiVersion = \"v1\";\n    kind = \"Namespace\";\n    metadata.name = \"kube-system\";\n  }\n]\n</code></pre>"},{"location":"library/#libkubenamespace","title":"lib.kube.namespace","text":"<p>Type: <code>namespace :: String -&gt; AttrSet -&gt; AttrSet</code></p> <p>Create a Kubernetes namespace manifest. This will create a manifest in Kubernetes format so if you want to use it for application's resources it should be then parsed with lib.resources.fromManifests.</p> <code>name</code> <p>Name of the namespace manifest to create.</p> structured function argument <p><code>annotations</code></p> <p>Optional annotations to add to the namespace manifest. This should be an attribute set.</p> <code>labels</code> <p>Optional labels to add to the namespace manifest. This should be an attribute set.</p> <p>Example:</p> <pre><code>namespace \"default\" {\n  labels = {\n    \"pod-security.kubernetes.io/enforce\" = \"privileged\";\n  };\n}\n=&gt; {\n  apiVersion = \"v1\";\n  kind = \"Namespace\";\n  metadata = {\n    name = \"default\";\n    labels = {\n      \"pod-security.kubernetes.io/enforce\" = \"privileged\";\n    };\n  };\n}\n</code></pre>"},{"location":"library/#libkubeconfigmap","title":"lib.kube.configMap","text":"<p>Type: <code>configMap :: String -&gt; AttrSet -&gt; AttrSet</code></p> <p>Create a Kubernetes config map manifest. This will create a manifest in Kubernetes format so if you want to use it for application's resources it should be then parsed with lib.resources.fromManifests.</p> <code>name</code> <p>Name of the config map manifest to create.</p> structured function argument <p><code>data</code></p> <p>Attribute set of data to put in the config map.</p> <code>namespace</code> <p>Optional namespace to add to the config map manifest.</p> <code>annotations</code> <p>Optional annotations to add to the namespace manifest. This should be an attribute set.</p> <code>labels</code> <p>Optional labels to add to the namespace manifest. This should be an attribute set.</p> <p>Example:</p> <pre><code>configMap \"my-config\" {\n  namespace = \"default\";\n  data.\"data.txt\" = \"Hello world!\";\n}\n=&gt; {\n  apiVersion = \"v1\";\n  kind = \"ConfigMap\";\n  metadata = {\n    name = \"my-config\";\n    namespace = \"default\";\n  };\n  data = {\n    \"data.txt\" = \"Hello world!\";\n  };\n}\n</code></pre>"},{"location":"library/#libkubesecret","title":"lib.kube.secret","text":"<p>Type: <code>configMap :: String -&gt; AttrSet -&gt; AttrSet</code></p> <p>Create a Kubernetes secret manifest. This will create a manifest in Kubernetes format so if you want to use it for application's resources it should be then parsed with lib.resources.fromManifests.</p> <p>Danger</p> <p>Due to the nature of nixidy this resource will be rendered to YAML and stored in cleartext in git.</p> <p>Using this resource for actual secret data is discouraged.</p> <code>name</code> <p>Name of the secret manifest to create</p> structured function argument <p><code>data</code></p> <p>Attribute set of data to put in the config map. Values should be base64 encoded.</p> <code>stringData</code> <p>Attribute set of data to put in the config map. Values should be in cleartext.</p> <code>namespace</code> <p>Optional namespace to add to the config map manifest.</p> <code>annotations</code> <p>Optional annotations to add to the namespace manifest. This should be an attribute set.</p> <code>labels</code> <p>Optional labels to add to the namespace manifest. This should be an attribute set.</p> <p>Example:</p> <pre><code>secret \"my-secret\" {\n  namespace = \"default\";\n  stringData.\"data.txt\" = \"Hello world!\";\n}\n=&gt; {\n  apiVersion = \"v1\";\n  kind = \"Secret\";\n  metadata = {\n    name = \"my-secret\";\n    namespace = \"default\";\n  };\n  stringData = {\n    \"data.txt\" = \"Hello world!\";\n  };\n}\n</code></pre>"},{"location":"library/#libkubeservice","title":"lib.kube.service","text":"<p>Type: <code>service :: String -&gt; AttrSet -&gt; AttrSet</code></p> <p>Create a Kubernetes service manifest. This will create a manifest in Kubernetes format so if you want to use it for application's resources it should be then parsed with lib.resources.fromManifests.</p> <code>name</code> <p>Name of the service manifest to create.</p> structured function argument <p><code>type</code></p> <p>Type of service to create. Defaults to <code>ClusterIP</code>.</p> <code>selector</code> <p>Label selector to match pods that this service should target. This should be an attribute set.</p> <code>ports</code> <p>Ports this service should have. This should be an attribute set (see example).</p> <code>namespace</code> <p>Optional namespace to add to the config map manifest.</p> <code>annotations</code> <p>Optional annotations to add to the namespace manifest. This should be an attribute set.</p> <code>labels</code> <p>Optional labels to add to the namespace manifest. This should be an attribute set.</p> <p>Example:</p> <pre><code>service \"nginx\" {\n  namespace = \"default\";\n  selector.app = \"nginx\";\n  ports.http = {\n    port = 80;\n  };\n}\n=&gt; {\n  apiVersion = \"v1\";\n  kind = \"Service\";\n  metadata = {\n    name = \"nginx\";\n    namespace = \"default\";\n  };\n  spec = {\n    type = \"ClusterIP\"; # Default\n    selector.app = \"nginx\";\n    ports = [\n      {\n        name = \"http\";\n        port = 80;\n        protocol = \"TCP\"; # Default\n      }\n    ];\n  };\n}\n</code></pre>"},{"location":"options/","title":"Configuration Options","text":""},{"location":"options/#applications","title":"applications","text":"<p>An application is a single Argo CD application that will be rendered by nixidy.</p> <p>The resources will be rendered into it's own directory and an Argo CD application created for it.</p> <p>Type: attribute set of (submodule)</p> <p>Default: <code>{ }</code></p> <p>Example:</p> <pre><code>{\n  argocd = {\n    namespace = \"argocd\";\n    resources = {\n      v1 = {\n        Namespace = {\n          argocd = { };\n        };\n      };\n    };\n  };\n}\n</code></pre> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamecreatenamespace","title":"applications.&lt;name&gt;.createNamespace","text":"<p>Whether or not a namespace resource should be automatically created.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleases","title":"applications.&lt;name&gt;.helm.releases","text":"<p>Helm releases to template and add to the rendered application's resources.</p> <p>Type: attribute set of (submodule)</p> <p>Default: <code>{ }</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnamechart","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.chart","text":"<p>Derivation containing the helm chart for the release.</p> <p>Type: package</p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnameincludecrds","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.includeCRDs","text":"<p>Whether or not to include CRDs in the helm release.</p> <p>Type: boolean</p> <p>Default: <code>true</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnamename","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.name","text":"<p>Name of the helm release.</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnamenamespace","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.namespace","text":"<p>Namespace for the release. When set to <code>null</code> it will use the application's namespace.</p> <p>Type: null or string</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnamevalues","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.values","text":"<p>Values to pass to the helm chart when rendering it.</p> <p>Type: attribute set of anything</p> <p>Default: <code>{ }</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamemanifests","title":"applications.&lt;name&gt;.manifests","text":"<p>List of Kubernetes manifests in nix attribute sets. They will be parsed and added to the application's <code>resources</code> where they can be overwritten and modified.</p> <p>Can be useful for using helper functions in <code>lib.kube</code>.</p> <p>Type: list of attribute set of anything</p> <p>Default: <code>[ ]</code></p> <p>Example:</p> <pre><code>[\n  {\n    apiVersion = \"v1\";\n    kind = \"Namespace\";\n    metadata = {\n      name = \"default\";\n    };\n  }\n]\n</code></pre> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamename","title":"applications.&lt;name&gt;.name","text":"<p>Name of the application.</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamenamespace","title":"applications.&lt;name&gt;.namespace","text":"<p>Namespace to deploy application into (defaults to name).</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnameoutputpath","title":"applications.&lt;name&gt;.output.path","text":"<p>Name of the folder that contains all rendered resources for the application. Relative to the root of the repository.</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnameproject","title":"applications.&lt;name&gt;.project","text":"<p>ArgoCD project to make application a part of.</p> <p>Type: string</p> <p>Default: <code>\"default\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnameresources","title":"applications.&lt;name&gt;.resources","text":"<p>Resources that make up the application.</p> <p>They should be declared in the form <code>&lt;apiVersion&gt;.&lt;kind&gt;.&lt;name&gt;</code>.</p> <p>For example the following namespace resource:</p> <pre><code>apiVersion: v1\nkind: Namespace\nmetadata:\nname: argocd\nlabels:\npod-security.kubernetes.io/enforce: privileged\n</code></pre> <p>Would be declared in like this:</p> <pre><code>{\n  v1.Namespace.argocd = {\n    metadata.labels.\"pod-security.kubernetes.io/enforce\" = \"privileged\";\n  };\n}\n</code></pre> <p>Type: attribute set of attribute set of attribute set of anything</p> <p>Default: <code>{ }</code></p> <p>Example:</p> <pre><code>{\n  v1 = {\n    ConfigMap = {\n      argocd-cmd-params-cm = {\n        data = {\n          \"server.insecure\" = \"true\";\n        };\n        metadata = {\n          namespace = \"argocd\";\n        };\n      };\n    };\n    Namespace = {\n      argocd = { };\n    };\n  };\n}\n</code></pre> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicyautomatedprune","title":"applications.&lt;name&gt;.syncPolicy.automated.prune","text":"<p>Specifies if resources should be pruned during auto-syncing.</p> <p>Defaults to <code>config.nixidy.defaultSyncPolicy.automated.prune</code>.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicyautomatedselfheal","title":"applications.&lt;name&gt;.syncPolicy.automated.selfHeal","text":"<p>Specifies if partial app sync should be executed when resources are changed only in target Kubernetes cluster and no git change detected.</p> <p>Defaults to <code>config.nixidy.defaultSyncPolicy.automated.selfHeal</code>.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnameyamls","title":"applications.&lt;name&gt;.yamls","text":"<p>List of Kubernetes manifests declared in YAML strings. They will be parsed and added to the application's <code>resources</code> where they can be overwritten and modified.</p> <p>Can be useful for reading existing YAML files (i.e. <code>[(builtins.readFile ./deployment.yaml)]</code>).</p> <p>Type: list of string</p> <p>Default: <code>[ ]</code></p> <p>Example:</p> <pre><code>[\n  ''\n    apiVersion: v1\n    kind: Namespace\n    metadata:\n      name: default\n''\n]\n</code></pre> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#nixidyappofappsname","title":"nixidy.appOfApps.name","text":"<p>Name of the application for bootstrapping all other applications (app of apps pattern).</p> <p>Type: string</p> <p>Default: <code>\"apps\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidyappofappsnamespace","title":"nixidy.appOfApps.namespace","text":"<p>Destination namespace for generated Argo CD Applications in the app of apps applications.</p> <p>Type: string</p> <p>Default: <code>\"argocd\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidydefaultsyncpolicyautomatedprune","title":"nixidy.defaultSyncPolicy.automated.prune","text":"<p>Specifies if resources should be pruned during auto-syncing. This is the default value for all applications if not explicitly set.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidydefaultsyncpolicyautomatedselfheal","title":"nixidy.defaultSyncPolicy.automated.selfHeal","text":"<p>Specifies if partial app sync should be executed when resources are changed only in target Kubernetes cluster and no git change detected. This is the default value for all applications if not explicitly set.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidyextrafiles","title":"nixidy.extraFiles","text":"<p>Extra files to write in the generated stage.</p> <p>Type: attribute set of (submodule)</p> <p>Default: <code>{ }</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidyextrafilesnamepath","title":"nixidy.extraFiles.&lt;name&gt;.path","text":"<p>Path of output file.</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidyextrafilesnametext","title":"nixidy.extraFiles.&lt;name&gt;.text","text":"<p>Text of the output file.</p> <p>Type: strings concatenated with \"\\n\"</p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidytargetrepository","title":"nixidy.target.repository","text":"<p>The repository URL to put in all generated applications.</p> <p>Type: string</p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidytargetrevision","title":"nixidy.target.revision","text":"<p>The target revision to put in all generated applications.</p> <p>Type: string</p> <p>Default: <code>\"HEAD\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"}]}