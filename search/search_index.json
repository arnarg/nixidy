{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"nixidy","text":"<p>Kubernetes GitOps with nix and Argo CD.</p> <p>Kind of sounds like Nix CD.</p>"},{"location":"#what-is-it","title":"What is it?","text":"<p>Manage an entire Kubernetes cluster like it's NixOS, then have CI generate plain YAML manifests for ArgoCD.</p> <pre><code>{\n  applications.demo = {\n    namespace = \"demo\";\n\n    # Automatically generate a namespace resource with the\n    # above set namespace\n    createNamespace = true;\n\n    resources = let\n      labels = {\n        \"app.kubernetes.io/name\" = \"nginx\";\n      };\n    in {\n      # Define a deployment for running an nginx server\n      deployments.nginx.spec = {\n        selector.matchLabels = labels;\n        template = {\n          metadata.labels = labels;\n          spec = {\n            securityContext.fsGroup = 1000;\n            containers.nginx = {\n              image = \"nginx:1.25.1\";\n              imagePullPolicy = \"IfNotPresent\";\n              volumeMounts = {\n                \"/etc/nginx\".name = \"config\";\n                \"/var/lib/html\".name = \"static\";\n              };\n            };\n            volumes = {\n              config.configMap.name = \"nginx-config\";\n              static.configMap.name = \"nginx-static\";\n            };\n          };\n        };\n      };\n\n      # Define config maps with config for nginx\n      configMaps = {\n        nginx-config.data.\"nginx.conf\" = ''\n          user nginx nginx;\n          error_log /dev/stdout info;\n          pid /dev/null;\n          events {}\n          http {\n            access_log /dev/stdout;\n            server {\n              listen 80;\n              index index.html;\n              location / {\n                root /var/lib/html;\n              }\n            }\n          }\n        '';\n\n        nginx-static.data.\"index.html\" = ''\n          &lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello from NGINX&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\n        '';\n      };\n\n      # Define service for nginx\n      services.nginx.spec = {\n        selector = labels;\n        ports.http.port = 80;\n      };\n    };\n  };\n}\n</code></pre> <p>Then build with nixidy using <code>nixidy build .#prod</code></p> <pre><code>tree -l result/\n\u251c\u2500\u2500 apps\n\u2502   \u2514\u2500\u2500 Application-demo.yaml\n\u2514\u2500\u2500 demo\n    \u251c\u2500\u2500 ConfigMap-nginx-config.yaml\n    \u251c\u2500\u2500 ConfigMap-nginx-static.yaml\n    \u251c\u2500\u2500 Deployment-nginx.yaml\n    \u251c\u2500\u2500 Namespace-demo.yaml\n    \u2514\u2500\u2500 Service-nginx.yaml\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Declarative Cluster Management: Define your entire Kubernetes cluster state using the Nix language.</li> <li>NixOS-like Experience: Leverage the power and structure of the NixOS module system for your Kubernetes configurations.</li> <li>GitOps Ready: Generates plain YAML manifests, aligning with the \"Rendered Manifests Pattern\" for Argo CD.</li> <li>Strongly-Typed Configuration: Benefit from NixOS' type system for Kubernetes resources, catching errors early.</li> <li>Simplified Multi-Environment Management: Easily manage configurations for development, staging, production, etc.</li> <li>Helm &amp; Kustomize Integration: Seamlessly incorporate existing Helm charts and Kustomize overlays.</li> <li>Extensible: Generate typed Nix options for your Custom Resource Definitions (CRDs).</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Take a look at the getting started guide.</p>"},{"location":"#examples","title":"Examples","text":"<ul> <li>arnarg's cluster configuration</li> </ul>"},{"location":"#why-nixidy","title":"Why nixidy?","text":"<p>It's desirable to manage Kubernetes clusters in a declarative way using a git repository as a source of truth for manifests that should be deployed into the cluster. One popular solution that is often used to achieve this goal is Argo CD.</p> <p>Argo CD has a concept of applications. Each application has an entrypoint somewhere in your git repository that is either a Helm chart, kustomize application, jsonnet files or just a directory of YAML files. All the resources that are output when templating the helm chart, kustomizing the kustomize application or are defined in the YAML files in the directory, make up the application and are (usually) deployed into a single namespace.</p> <p>For those reasons these git repositories often need quite elaborate designs once many applications should be deployed, requiring use of application sets (generator for applications) or custom Helm charts just to render all the different applications of the repository.</p> <p>On top of that it can be quite obscure what exactly will be deployed by just looking at helm charts (along with all the values override, usually set for each environment) or the kustomize overlays (which often are many depending on number of environments/stages) without going in and just running <code>helm template</code> or <code>kubectl kustomize</code>.</p> <p>Having dealt with these design decisions and pains that come with the different approaches I'm starting to use The Rendered Manifests Pattern. While it's explained in way more detail in the linked blog post, basically it involves using your CI system to pre-render the helm charts or the kustomize overlays and commit all the rendered manifests to an environment branch (or go through a pull request review where you can review the exact changes to your environment). That way you can just point Argo CD to your different directories full of rendered YAML manifests without having to do any helm templating or kustomize rendering.</p>"},{"location":"#nixos-module-system","title":"NixOS' Module System","text":"<p>I have been a user and a fan of NixOS for many years and how its module system works to recursively merge all configuration options that are set in many different modules.</p> <p>I have not been a fan of helm's string templating of a whitespace-sensitive configuration language or kustomize's repetition (defining a <code>kustomization.yaml</code> file for each layer statically listing files to include, some are JSON patches some are not...).</p> <p>Therefore I made nixidy as an experiment to see if I can make something better (at least for myself). As all Argo CD applications are defined in a single configuration it can reference configuration options across applications and automatically generate an App of Apps bootstrapping all of them.</p>"},{"location":"#special-thanks","title":"Special Thanks","text":"<p>farcaller/nix-kube-generators is used internally to pull and render Helm charts and some functions are re-exposed in the lib passed to modules in nixidy.</p> <p>hall/kubenix project has code generation of nix module options for every standard kubernetes resource. Instead of doing this work in nixidy I import their generated resource options. The resource option generation scripts in nixidy are also a slight modification of kubenix's. Without their work this wouldn't be possible in nixidy.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Whether it's bug reports, feature requests, documentation improvements, or code contributions, please feel free to open an issue or pull request on our GitHub repository.</p>"},{"location":"#license","title":"License","text":"<p>nixidy is licensed under the MIT License.</p>"},{"location":"library/","title":"Libary Functions","text":"<p>The argument <code>lib</code> is passed to each module in nixidy. This is the standard nixpkgs library extended with the following functions.</p>"},{"location":"library/#libhelmdownloadhelmchart","title":"lib.helm.downloadHelmChart","text":"<p>Type: <code>downloadHelmChart :: AttrSet -&gt; Derivation</code></p> <p>Downloads a helm chart from a helm registry.</p> <p>This is re-exported directly from farcaller/nix-kube-generators.</p>"},{"location":"library/#libhelmbuildhelmchart","title":"lib.helm.buildHelmChart","text":"<p>Type: <code>buildHelmChart :: AttrSet -&gt; Derivation</code></p> <p>Templates a helm chart with provided values and creates a derivation with the output.</p> <p>This is re-exported directly from farcaller/nix-kube-generators.</p>"},{"location":"library/#libhelmgetchartvalues","title":"lib.helm.getChartValues","text":"<p>Type: <code>getChartValues :: Derivation -&gt; AttrSet</code></p> <p>Parse the default values file shipped with the helm chart.</p> <code>chart</code> <p>Derivation containing helm chart. Usually output of lib.helm.downloadHelmChart.</p> <p>Example:</p> <pre><code>getChartValues (lib.helm.downloadHelmChart {\n    repo = \"https://argoproj.github.io/argo-helm/\";\n    chart = \"argo-cd\";\n    version = \"5.51.4\";\n    chartHash = \"sha256-LOEJ5mYaHEA0RztDkgM9DGTA0P5eNd0SzSlwJIgpbWY=\";\n})\n=&gt; {\n  server.replicas = 1;\n  controller.replicas = 1;\n  # ...\n}\n</code></pre>"},{"location":"library/#libhelmmkchartattrs","title":"lib.helm.mkChartAttrs","text":"<p>Type: <code>mkChartAttrs :: Path -&gt; AttrSet</code></p> <p>Walk a directory tree and import all <code>default.nix</code> to download helm charts.</p> <p>The <code>default.nix</code> needs to have the following format:</p> ./charts/kubernetes-csi/csi-driver-nfs/default.nix<pre><code>{\n  repo = \"https://raw.githubusercontent.com/kubernetes-csi/csi-driver-nfs/master/charts\";\n  chart = \"csi-driver-nfs\";\n  version = \"4.7.0\";\n  chartHash = \"sha256-EU2qaZglUU3vxa41l1p/2yBscksIhYMr8kSgH8t0vL8=\";\n}\n</code></pre> <code>dir</code> <p>Path to a directory containing the correct directory structure described above.</p> <p>Example:</p> <pre><code>mkChartAttrs ./charts\n=&gt; {\n  kubernetes-csi = {\n    csi-driver-nfs = lib.helm.downloadHelmChart {\n      repo = \"https://raw.githubusercontent.com/kubernetes-csi/csi-driver-nfs/master/charts\";\n      chart = \"csi-driver-nfs\";\n      version = \"4.7.0\";\n      chartHash = \"sha256-EU2qaZglUU3vxa41l1p/2yBscksIhYMr8kSgH8t0vL8=\";\n    };\n  };\n}\n</code></pre>"},{"location":"library/#libkustomizebuildkustomization","title":"lib.kustomize.buildKustomization","text":"<p>Type: <code>buildKustomization :: AttrSet -&gt; Derivation</code></p> <p>Builds a kustomization and creates a derivation with the output.</p> structured function argument <p><code>name</code></p> <p>Name is only used for derivation name.</p> <code>src</code> <p>Derivation containing the kustomization entrypoint and all relative bases that it might reference.</p> <code>path</code> <p>Relative path from the base of <code>src</code> to the kustomization folder to render.</p> <code>namespace</code> <p>Override namespace in kustomization.yaml.</p> <p>Example:</p> <pre><code>buildKustomization {\n  name = \"argocd\";\n  src = pkgs.fetchFromGitHub {\n    owner = \"argoproj\";\n    repo = \"argo-cd\";\n    rev = \"v2.9.3\";\n    hash = \"sha256-GaY4Cw/LlSwy35umbB4epXt6ev8ya19UjHRwhDwilqU=\";\n  };\n  path = \"manifests/cluster-install\";\n  namespace = \"argocd\";\n}\n=&gt; /nix/store/7i52...7pww-kustomize-argocd\n</code></pre>"},{"location":"library/#libkubefromyaml","title":"lib.kube.fromYAML","text":"<p>Type: <code>fromYAML :: String -&gt; [AttrSet]</code></p> <p>Parses a YAML document string into a list of attribute sets.</p> <p>This is re-exported directly from farcaller/nix-kube-generators.</p> <code>yaml</code> <p>String with a yaml document.</p> <p>Example:</p> <pre><code>fromYAML ''\n  apiVersion: v1\n  kind: Namespace\n  metadata:\n    name: default\n  ---\n  apiVersion: v1\n  kind: Namespace\n  metadata:\n    name: kube-system\n''\n=&gt; [\n  {\n    apiVersion = \"v1\";\n    kind = \"Namespace\";\n    metadata.name = \"default\";\n  }\n  {\n    apiVersion = \"v1\";\n    kind = \"Namespace\";\n    metadata.name = \"kube-system\";\n  }\n]\n</code></pre>"},{"location":"library/#libkubefromoctal","title":"lib.kube.fromOctal","text":"<p>Type: <code>fromOctal :: String -&gt; Integer</code></p> <p>Parse an octal representation of a number and convert into a decimal number. This can be useful when having to represent permission bits in a resource as nix has no support for representing octal numbers.</p> <code>octal</code> <p>String representation of the octal number to parse.</p> <p>Example:</p> <pre><code>fromOctal \"0555\"\n=&gt; 365\n</code></pre>"},{"location":"library/#libkuberemovelabels","title":"lib.kube.removeLabels","text":"<p>Type: <code>removeLabels :: [String] -&gt; AttrSet -&gt; AttrSet</code></p> <p>Removes labels from a Kubernetes manifest.</p> <code>labels</code> <p>List of labels that should be removed</p> <code>manifest</code> <p>Kubernetes manifest</p> <p>Example:</p> <pre><code>removeLabels [\"helm.sh/chart\"] {\n  apiVersion = \"v1\";\n  kind = \"ConfigMap\";\n  metadata = {\n    name = \"argocd-cm\";\n    labels = {\n      \"app.kubernetes.io/name\" = \"argocd-cm\";\n      \"helm.sh/chart\" = \"argo-cd-5.51.6\";\n    };\n  };\n}\n=&gt; {\n  apiVersion = \"v1\";\n  kind = \"ConfigMap\";\n  metadata = {\n    name = \"argocd-cm\";\n    labels = {\n      \"app.kubernetes.io/name\" = \"argocd-cm\";\n    };\n  };\n}\n</code></pre>"},{"location":"options/","title":"Configuration Options","text":"<p>To see all available resources options, use the nixidy options search powered by N\u00fcschtOS.</p>"},{"location":"options/#applications","title":"applications","text":"<p>An application is a single Argo CD application that will be rendered by nixidy.</p> <p>The resources will be rendered into it's own directory and an Argo CD application created for it.</p> <p>Type: attribute set of (submodule)</p> <p>Default: <code>{ }</code></p> <p>Example:</p> <pre><code>{\n  nginx = {\n    namespace = \"nginx\";\n    resources = {\n      deployments = {\n        nginx = {\n          spec = {\n            replicas = 3;\n            selector = {\n              matchLabels = {\n                app = \"nginx\";\n              };\n            };\n            template = {\n              metadata = {\n                labels = {\n                  app = \"nginx\";\n                };\n              };\n              spec = {\n                containers = {\n                  nginx = {\n                    image = \"nginx:1.25.1\";\n                    imagePullPolicy = \"IfNotPresent\";\n                  };\n                };\n                securityContext = {\n                  fsGroup = 1000;\n                };\n              };\n            };\n          };\n        };\n      };\n      services = {\n        nginx = {\n          spec = {\n            ports = {\n              http = {\n                port = 80;\n              };\n            };\n            selector = {\n              app = \"nginx\";\n            };\n          };\n        };\n      };\n    };\n  };\n}\n</code></pre> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnameannotations","title":"applications.&lt;name&gt;.annotations","text":"<p>Annotations to add to the rendered ArgoCD application.</p> <p>Type: attribute set of string</p> <p>Default: <code>{ }</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamecompareoptionsignoreextraneous","title":"applications.&lt;name&gt;.compareOptions.ignoreExtraneous","text":"<p>Sets IgnoreExtraneous compare option for the application. Only setting it as <code>true</code> has any effect.</p> <p>Type: null or boolean</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamecompareoptionsincludemutationwebhook","title":"applications.&lt;name&gt;.compareOptions.includeMutationWebhook","text":"<p>Sets IncludeMutationWebhook compare option for the application. Only setting it as <code>true</code> has any effect.</p> <p>Type: null or boolean</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamecompareoptionsserversidediff","title":"applications.&lt;name&gt;.compareOptions.serverSideDiff","text":"<p>Sets ServerSideDiff compare option for the application. Leave as <code>null</code> for the default behavior.</p> <p>Type: null or boolean</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamecreatenamespace","title":"applications.&lt;name&gt;.createNamespace","text":"<p>Whether or not a namespace resource should be automatically created.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamedestinationserver","title":"applications.&lt;name&gt;.destination.server","text":"<p>The Kubernetes server that ArgoCD should deploy the application to.</p> <p>Type: string</p> <p>Default: <code>config.nixidy.defaults.destination.server</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleases","title":"applications.&lt;name&gt;.helm.releases","text":"<p>Helm releases to template and add to the rendered application's resources.</p> <p>Type: attribute set of (submodule)</p> <p>Default: <code>{ }</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/helm.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnamechart","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.chart","text":"<p>Derivation containing the helm chart for the release.</p> <p>Type: package or path</p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/helm.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnameextraopts","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.extraOpts","text":"<p>Extra options to pass to <code>helm template</code> that is run when rendering the helm chart.</p> <p>Type: list of string</p> <p>Default: <code>[ ]</code></p> <p>Example:</p> <pre><code>[\n  \"--no-hooks\"\n]\n</code></pre> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/helm.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnameincludecrds","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.includeCRDs","text":"<p>Whether or not to include CRDs in the helm release.</p> <p>Type: boolean</p> <p>Default: <code>true</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/helm.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnamename","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.name","text":"<p>Name of the helm release.</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/helm.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnamenamespace","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.namespace","text":"<p>Namespace for the release.</p> <p>Type: string</p> <p>Default: <code>config.applications.&lt;name&gt;.namespace</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/helm.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnametransformer","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.transformer","text":"<p>Function that will be applied to the list of rendered manifests after the helm templating.</p> <p>Type: function that evaluates to a(n) list of attribute set of anything</p> <p>Default: <code>config.nixidy.defaults.helm.transformer</code></p> <p>Example: <code>map (lib.kube.removeLabels [\"helm.sh/chart\"])</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/helm.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnamevalues","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.values","text":"<p>Values to pass to the helm chart when rendering it.</p> <p>Type: attribute set of anything</p> <p>Default: <code>{ }</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/helm.nix&gt;</li> </ul>"},{"location":"options/#applicationsnameignoredifferences","title":"applications.&lt;name&gt;.ignoreDifferences","text":"<p>IgnoreDifferences is a list of resources and their fields which should be ignored during comparison.</p> <p>More info here.</p> <p>Type: null or (attribute set of (submodule))</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnameignoredifferencesnamegroup","title":"applications.&lt;name&gt;.ignoreDifferences.&lt;name&gt;.group","text":"<p>Type: null or string</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnameignoredifferencesnamejqpathexpressions","title":"applications.&lt;name&gt;.ignoreDifferences.&lt;name&gt;.jqPathExpressions","text":"<p>Type: null or (list of string)</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnameignoredifferencesnamejsonpointers","title":"applications.&lt;name&gt;.ignoreDifferences.&lt;name&gt;.jsonPointers","text":"<p>Type: null or (list of string)</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnameignoredifferencesnamekind","title":"applications.&lt;name&gt;.ignoreDifferences.&lt;name&gt;.kind","text":"<p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnameignoredifferencesnamemanagedfieldsmanagers","title":"applications.&lt;name&gt;.ignoreDifferences.&lt;name&gt;.managedFieldsManagers","text":"<p>ManagedFieldsManagers is a list of trusted managers. Fields mutated by those managers will take precedence over the desired state defined in the SCM and won't be displayed in diffs</p> <p>Type: null or (list of string)</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnameignoredifferencesnamename","title":"applications.&lt;name&gt;.ignoreDifferences.&lt;name&gt;.name","text":"<p>Type: null or string</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnameignoredifferencesnamenamespace","title":"applications.&lt;name&gt;.ignoreDifferences.&lt;name&gt;.namespace","text":"<p>Type: null or string</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamekustomizeapplications","title":"applications.&lt;name&gt;.kustomize.applications","text":"<p>Kustomize applications to render and add to the rendered application's resources.</p> <p>Type: attribute set of (submodule)</p> <p>Default: <code>{ }</code></p> <p>Example:</p> <pre><code>{\n  argocd = {\n    namespace = \"argocd\";\n    # Equivalent to `github.com/argoproj/argo-cd/manifests/cluster-install?ref=v2.9.3`\n    # in kustomization.yaml.\n    kustomization = {\n      src = pkgs.fetchFromGitHub {\n        owner = \"argoproj\";\n        repo = \"argo-cd\";\n        rev = \"v2.9.3\";\n        hash = \"sha256-GaY4Cw/LlSwy35umbB4epXt6ev8ya19UjHRwhDwilqU=\";\n      };\n      path = \"manifests/cluster-install\";\n    };\n  };\n};\n</code></pre> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/kustomize.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamekustomizeapplicationsnamekustomizationpath","title":"applications.&lt;name&gt;.kustomize.applications.&lt;name&gt;.kustomization.path","text":"<p>Path relative to the base of <code>src</code> to the entrypoint kustomization directory.</p> <p>Type: string</p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/kustomize.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamekustomizeapplicationsnamekustomizationsrc","title":"applications.&lt;name&gt;.kustomize.applications.&lt;name&gt;.kustomization.src","text":"<p>Derivation containing all the kustomize bases and overlays.</p> <p>Type: package or path</p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/kustomize.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamekustomizeapplicationsnamename","title":"applications.&lt;name&gt;.kustomize.applications.&lt;name&gt;.name","text":"<p>Name of the kustomize application.</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/kustomize.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamekustomizeapplicationsnamenamespace","title":"applications.&lt;name&gt;.kustomize.applications.&lt;name&gt;.namespace","text":"<p>Namespace for the kustomize application.</p> <p>Type: string</p> <p>Default: <code>config.applications.&lt;name&gt;.namespace</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/kustomize.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamekustomizeapplicationsnametransformer","title":"applications.&lt;name&gt;.kustomize.applications.&lt;name&gt;.transformer","text":"<p>Function that will be applied to the list of rendered manifests from kustomize.</p> <p>Type: function that evaluates to a(n) list of attribute set of anything</p> <p>Default: <code>config.nixidy.defaults.kustomize.transformer</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/kustomize.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamename","title":"applications.&lt;name&gt;.name","text":"<p>Name of the application.</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamenamespace","title":"applications.&lt;name&gt;.namespace","text":"<p>Namespace to deploy application into (defaults to name).</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnameoutputpath","title":"applications.&lt;name&gt;.output.path","text":"<p>Name of the folder that contains all rendered resources for the application. Relative to the root of the repository.</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnameproject","title":"applications.&lt;name&gt;.project","text":"<p>ArgoCD project to make application a part of.</p> <p>Type: string</p> <p>Default: <code>\"default\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnameresources","title":"applications.&lt;name&gt;.resources","text":"<p>Kubernetes resources for the application.</p> <p>The entire list of available resource options is too large for the current documentation setup but can be searched in the nixidy options search powered by N\u00fcschtOS.</p> <p>Type: attribute set</p> <p>Default: <code>{ }</code></p> <p>Example:</p> <pre><code>{\n  deployments = {\n    nginx = {\n      spec = {\n        replicas = 3;\n        selector = {\n          matchLabels = {\n            app = \"nginx\";\n          };\n        };\n        template = {\n          metadata = {\n            labels = {\n              app = \"nginx\";\n            };\n          };\n          spec = {\n            containers = {\n              nginx = {\n                image = \"nginx:1.25.1\";\n                imagePullPolicy = \"IfNotPresent\";\n              };\n            };\n            securityContext = {\n              fsGroup = 1000;\n            };\n          };\n        };\n      };\n    };\n  };\n  services = {\n    nginx = {\n      spec = {\n        ports = {\n          http = {\n            port = 80;\n          };\n        };\n        selector = {\n          app = \"nginx\";\n        };\n      };\n    };\n  };\n}\n</code></pre> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicyautosyncenable","title":"applications.&lt;name&gt;.syncPolicy.autoSync.enable","text":"<p>Specifies if application should automatically sync.</p> <p>Type: boolean</p> <p>Default: <code>config.nixidy.defaults.syncPolicy.autoSync.enable</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicyautosyncprune","title":"applications.&lt;name&gt;.syncPolicy.autoSync.prune","text":"<p>Specifies if resources should be pruned during auto-syncing.</p> <p>Type: boolean</p> <p>Default: <code>config.nixidy.defaults.syncPolicy.autoSync.prune</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicyautosyncselfheal","title":"applications.&lt;name&gt;.syncPolicy.autoSync.selfHeal","text":"<p>Specifies if partial app sync should be executed when resources are changed only in target Kubernetes cluster and no git change detected.</p> <p>Type: boolean</p> <p>Default: <code>config.nixidy.defaults.syncPolicy.autoSync.selfHeal</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicysyncoptionsapplyoutofsynconly","title":"applications.&lt;name&gt;.syncPolicy.syncOptions.applyOutOfSyncOnly","text":"<p>Currently when syncing using auto sync Argo CD applies every object in the application. For applications containing thousands of objects this takes quite a long time and puts undue pressure on the api server. Turning on selective sync option which will sync only out-of-sync resources.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicysyncoptionsfailonsharedresource","title":"applications.&lt;name&gt;.syncPolicy.syncOptions.failOnSharedResource","text":"<p>By default, Argo CD will apply all manifests found in the git path configured in the Application regardless if the resources defined in the yamls are already applied by another Application. If the <code>failOnSharedResource</code> sync option is set, Argo CD will fail the sync whenever it finds a resource in the current Application that is already applied in the cluster by another Application.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicysyncoptionsprunelast","title":"applications.&lt;name&gt;.syncPolicy.syncOptions.pruneLast","text":"<p>This feature is to allow the ability for resource pruning to happen as a final, implicit wave of a sync operation, after the other resources have been deployed and become healthy, and after all other waves completed successfully.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicysyncoptionsreplace","title":"applications.&lt;name&gt;.syncPolicy.syncOptions.replace","text":"<p>By default, Argo CD executes <code>kubectl apply</code> operation to apply the configuration stored in Git. In some cases <code>kubectl apply</code> is not suitable. For example, resource spec might be too big and won't fit into <code>kubectl.kubernetes.io/last-applied-configuration</code> annotation that is added by kubectl apply.</p> <p>If the <code>replace = true;</code> sync option is set the Argo CD will use <code>kubectl replace</code> or <code>kubectl create</code> command to apply changes.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicysyncoptionsserversideapply","title":"applications.&lt;name&gt;.syncPolicy.syncOptions.serverSideApply","text":"<p>By default, Argo CD executes <code>kubectl apply</code> operation to apply the configuration stored in Git. This is a client side operation that relies on <code>kubectl.kubernetes.io/last-applied-configuration</code> annotation to store the previous resource state.</p> <p>If <code>serverSideApply = true;</code> sync option is set, Argo CD will use <code>kubectl apply --server-side</code> command to apply changes.</p> <p>More info here.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnameyamls","title":"applications.&lt;name&gt;.yamls","text":"<p>List of Kubernetes manifests declared in YAML strings. They will be parsed and added to the application's <code>resources</code> where they can be overwritten and modified.</p> <p>Can be useful for reading existing YAML files (i.e. <code>[(builtins.readFile ./deployment.yaml)]</code>).</p> <p>Type: list of string</p> <p>Default: <code>[ ]</code></p> <p>Example:</p> <pre><code>[\n  ''\n    apiVersion: v1\n    kind: Namespace\n    metadata:\n      name: default\n  ''\n]\n</code></pre> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/yamls.nix&gt;</li> </ul>"},{"location":"options/#nixidyappofappsname","title":"nixidy.appOfApps.name","text":"<p>Name of the application for bootstrapping all other applications (app of apps pattern).</p> <p>Type: string</p> <p>Default: <code>\"apps\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidyappofappsnamespace","title":"nixidy.appOfApps.namespace","text":"<p>Destination namespace for generated Argo CD Applications in the app of apps applications.</p> <p>Type: string</p> <p>Default: <code>\"argocd\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidyappofappsproject","title":"nixidy.appOfApps.project","text":"<p>The project of the generated bootstrap app for appOfApps</p> <p>Type: string</p> <p>Default: <code>\"default\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidyapplicationimports","title":"nixidy.applicationImports","text":"<p>List of modules to import into <code>applications.*</code> submodule (most useful for resource definition options).</p> <p>Type: list of (package or path or function that evaluates to a(n) (attribute set))</p> <p>Default: <code>[ ]</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#nixidybootstrapmanifestenable","title":"nixidy.bootstrapManifest.enable","text":"<p>Automatically include a <code>bootstrap.yaml</code> manifest in the generated output. This can be used to bootstrap the app of apps by running <code>kubectl apply -f bootstrap.yaml</code>.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/extra-files.nix&gt;</li> </ul>"},{"location":"options/#nixidybuildrevision","title":"nixidy.build.revision","text":"<p>The revision being built. Will be written to <code>.revision</code> in the environment destination directory.</p> <p>Type: null or string</p> <p>Default: <code>null</code></p> <p>Example: <code>if (self ? rev) then self.rev else self.dirtyRev</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidycharts","title":"nixidy.charts","text":"<p>Attrset of derivations containing helm charts. This will be passed as <code>charts</code> to every module.</p> <p>Type: attribute set of anything</p> <p>Default: <code>{ }</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidychartsdir","title":"nixidy.chartsDir","text":"<p>Path to a directory containing sub-directory structure that can be used to build a charts attrset. This will be passed as <code>charts</code> to every module.</p> <p>Type: null or path</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidydefaultsdestinationserver","title":"nixidy.defaults.destination.server","text":"<p>The Kubernetes server that ArgoCD should deploy all applications to.</p> <p>This is the default value for all applications if not explicitly set for the application.</p> <p>Type: string</p> <p>Default: <code>\"https://kubernetes.default.svc\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidydefaultshelmtransformer","title":"nixidy.defaults.helm.transformer","text":"<p>Function that will be applied to the list of rendered manifests after the helm templating. This option applies to all helm releases in all applications unless explicitly specified there.</p> <p>Type: function that evaluates to a(n) list of attribute set of anything</p> <p>Default: <code>res: res</code></p> <p>Example: <code>map (lib.kube.removeLabels [\"helm.sh/chart\"])</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidydefaultskustomizetransformer","title":"nixidy.defaults.kustomize.transformer","text":"<p>Function that will be applied to the list of rendered manifests after kustomize rendering. This option applies to all kustomize applications in all nixidy applications unless explicitly specified there.</p> <p>Type: function that evaluates to a(n) list of attribute set of anything</p> <p>Default: <code>res: res</code></p> <p>Example: <code>map (lib.kube.removeLabels [\"app.kubernetes.io/version\"])</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidydefaultssyncpolicyautosyncenable","title":"nixidy.defaults.syncPolicy.autoSync.enable","text":"<p>Specifies if applications should automatically sync.</p> <p>This is the default value for all applications if not explicitly set for the application.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidydefaultssyncpolicyautosyncprune","title":"nixidy.defaults.syncPolicy.autoSync.prune","text":"<p>Specifies if resources should be pruned during auto-syncing.</p> <p>This is the default value for all applications if not explicitly set for the application.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidydefaultssyncpolicyautosyncselfheal","title":"nixidy.defaults.syncPolicy.autoSync.selfHeal","text":"<p>Specifies if partial app sync should be executed when resources are changed only in target Kubernetes cluster and no git change detected.</p> <p>This is the default value for all applications if not explicitly set for the application.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidyextrafiles","title":"nixidy.extraFiles","text":"<p>Extra files to write in the generated stage.</p> <p>Type: attribute set of (submodule)</p> <p>Default: <code>{ }</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/extra-files.nix&gt;</li> </ul>"},{"location":"options/#nixidyextrafilesnamepath","title":"nixidy.extraFiles.&lt;name&gt;.path","text":"<p>Path of output file.</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/extra-files.nix&gt;</li> </ul>"},{"location":"options/#nixidyextrafilesnamesource","title":"nixidy.extraFiles.&lt;name&gt;.source","text":"<p>Path of the source file.</p> <p>Type: path</p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/extra-files.nix&gt;</li> </ul>"},{"location":"options/#nixidyextrafilesnametext","title":"nixidy.extraFiles.&lt;name&gt;.text","text":"<p>Text of the output file.</p> <p>Type: null or strings concatenated with \"\\n\"</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/extra-files.nix&gt;</li> </ul>"},{"location":"options/#nixidyk8sversion","title":"nixidy.k8sVersion","text":"<p>The Kubernetes version for generated resource options to use.</p> <p>Type: one of \"1.30\", \"1.31\", \"1.32\", \"1.33\"</p> <p>Default: <code>\"1.33\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#nixidytargetbranch","title":"nixidy.target.branch","text":"<p>The destination branch of the generated applications.</p> <p>Type: string</p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidytargetrepository","title":"nixidy.target.repository","text":"<p>The repository URL to put in all generated applications.</p> <p>Type: string</p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidytargetrootpath","title":"nixidy.target.rootPath","text":"<p>The root path of all generated applications in the repository.</p> <p>Type: string</p> <p>Default: <code>\"./\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"developer_guide/architecture/","title":"Architectural Overview","text":"<p>LLM Generated</p> <p>This entire document is generated by an LLM by feeding the output of files-to-prompt to Gemini.</p> <p>Nixidy is a tool designed to manage Kubernetes clusters declaratively using the Nix package manager and its language. It integrates with Argo CD by generating plain Kubernetes YAML manifests, adhering to the GitOps philosophy and the \"Rendered Manifests Pattern\".</p>"},{"location":"developer_guide/architecture/#core-concepts","title":"Core Concepts","text":"<ul> <li>Declarative Configuration with Nix: Users define their entire Kubernetes cluster state, including applications, resources, Helm charts, and Kustomize overlays, within Nix expressions.</li> <li>NixOS Module System: Nixidy leverages a module system similar to NixOS, allowing for structured, modular, and recursively merged configurations. This provides strong typing and discoverability for Kubernetes resource options.</li> <li>Manifest Generation: The primary output of Nixidy is a set of plain Kubernetes YAML manifests and ArgoCD <code>Application</code> custom resources. These are intended to be committed to a Git repository.</li> <li>Argo CD Integration: Nixidy generates manifests in a structure that is easily consumable by Argo CD, typically following an \"App of Apps\" pattern for bootstrapping.</li> <li>No Runtime Dependencies on Nix in Cluster: Nixidy is a build-time tool. The generated YAMLs are standard Kubernetes manifests that Argo CD can deploy without any Nix-specific components in the cluster.</li> <li>Flake-centric (but supports flake-less): While Nixidy can be used without Nix Flakes, its primary development and examples lean towards a Flake-based setup for managing dependencies and outputs.</li> </ul>"},{"location":"developer_guide/architecture/#key-architectural-components","title":"Key Architectural Components","text":"<p>Nixidy's architecture can be broken down into several key areas:</p> <ol> <li> <p>User Configuration (Nix Files):</p> <ul> <li>Entrypoint: Typically a <code>flake.nix</code> (for Flakes) or a <code>default.nix</code> (for non-Flakes).</li> <li>Environment Definition: Users define one or more \"environments\" (e.g., <code>dev</code>, <code>prod</code>) using <code>nixidy.lib.mkEnv</code> or <code>nixidy.lib.mkEnvs</code>. Each environment is a collection of Nixidy modules.<ul> <li>(Document 6: <code>make-env.nix</code>, Document 13: Getting Started)</li> </ul> </li> <li>Application Modules: Within these environment modules, users define <code>applications.&lt;appName&gt;.*</code> options to describe their desired state. This includes:<ul> <li>Kubernetes resources directly in Nix syntax (<code>applications.&lt;appName&gt;.resources</code>).</li> <li>Helm chart releases (<code>applications.&lt;appName&gt;.helm.releases</code>).</li> <li>Kustomize applications (<code>applications.&lt;appName&gt;.kustomize.applications</code>).</li> <li>Raw YAML strings (<code>applications.&lt;appName&gt;.yamls</code>).</li> <li>(Document 2: README example, Document 27: <code>applications.nix</code>, Document 32: <code>modules/applications/default.nix</code>)</li> </ul> </li> <li>Nixidy Library (<code>lib.*</code>): Nixidy provides a set of helper functions (e.g., <code>lib.helm.downloadHelmChart</code>, <code>lib.kube.fromYAML</code>) available to user modules for tasks like fetching charts or parsing YAML.<ul> <li>(Document 22: <code>lib/default.nix</code>, Document 23: <code>lib/helm.nix</code>, Document 24: <code>lib/kube.nix</code>, Document 25: <code>lib/kustomize.nix</code>)</li> </ul> </li> </ul> </li> <li> <p>Nixidy Core Engine:</p> <ul> <li>Module System: Located primarily in <code>./modules</code>.<ul> <li><code>modules/default.nix</code> (Document 29): Orchestrates the evaluation of user and internal Nixidy modules. It injects an extended <code>lib</code> (Nixpkgs lib + Nixidy lib) and other special arguments.</li> <li><code>modules/nixidy.nix</code> (Document 31): Defines global <code>nixidy.*</code> configurations like target Git repository details, default sync policies for ArgoCD applications, and App of Apps settings.</li> <li><code>modules/applications/*</code>: A collection of modules that define how applications are processed:<ul> <li><code>applications.nix</code> (Document 27): Defines the top-level <code>applications</code> option.</li> <li><code>default.nix</code> (Document 32): Defines the submodule for a single application, collecting all resources (from Nix, Helm, Kustomize, YAMLs) into <code>config.objects</code>.</li> <li><code>helm.nix</code> (Document 33), <code>kustomize.nix</code> (Document 34), <code>yamls.nix</code> (Document 37): Handle the specifics of rendering Helm charts, Kustomize overlays, and parsing raw YAMLs, respectively. They utilize functions from <code>nixidy.lib</code>.</li> <li><code>namespaced.nix</code> (Document 36): Sets default namespaces for namespaced Kubernetes resources.</li> </ul> </li> </ul> </li> <li>Build Logic (<code>modules/build.nix</code>, Document 28):<ul> <li>Takes the evaluated <code>config.applications.*.objects</code> (a list of Nix attribute sets representing Kubernetes resources).</li> <li>Generates the final output directory structure:<ul> <li>A directory for each application (e.g., <code>result/demo/</code>).</li> <li>YAML files for each resource within its application directory (e.g., <code>Deployment-nginx.yaml</code>). Uses <code>yq-go</code> for pretty-printing YAML.</li> <li>An <code>apps/</code> directory containing ArgoCD <code>Application</code> CRs for each user-defined application.</li> </ul> </li> <li>Produces Nix derivations for different purposes:<ul> <li><code>environmentPackage</code>: Contains all generated manifests for an environment.</li> <li><code>activationPackage</code>: Contains <code>environmentPackage</code> plus an <code>activate</code> script (for <code>nixidy switch</code>).</li> <li><code>bootstrapPackage</code>: Contains the \"App of Apps\" ArgoCD <code>Application</code> manifest (for <code>nixidy bootstrap</code>).</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>Nixidy CLI (<code>nixidy/nixidy</code>, Document 42):</p> <ul> <li>A Bash script that acts as a user-friendly wrapper around underlying <code>nix</code> commands (<code>nix build</code>, <code>nix eval</code>, <code>nix-build</code>, <code>nix-instantiate</code>).</li> <li>Commands:<ul> <li><code>nixidy build &lt;env&gt;</code>: Builds the <code>environmentPackage</code>.</li> <li><code>nixidy switch &lt;env&gt;</code>: Builds the <code>activationPackage</code> and runs its <code>activate</code> script to sync manifests to the local filesystem (defined by <code>nixidy.target.rootPath</code>).</li> <li><code>nixidy info &lt;env&gt;</code>: Displays metadata about the specified environment (repository, branch).</li> <li><code>nixidy bootstrap &lt;env&gt;</code>: Outputs the \"App of Apps\" ArgoCD <code>Application</code> manifest for initial cluster bootstrapping.</li> </ul> </li> <li>Handles both Flake-based and traditional Nix (attribute-based) invocations.<ul> <li>(Document 43: <code>nixidy.nix</code> package definition)</li> </ul> </li> </ul> </li> <li> <p>External Dependencies (Managed by Nix):</p> <ul> <li>Nixpkgs: The standard Nix package collection, providing tools like <code>bash</code>, <code>jq</code>, <code>kubectl</code>, <code>yq-go</code>, etc.<ul> <li>(Document 3: <code>default.nix</code> top-level)</li> </ul> </li> <li>Kubenix:<ul> <li>Primarily used for its pre-generated Nix modules that provide typed options for standard Kubernetes resources (e.g., <code>Deployment</code>, <code>Service</code>). Nixidy imports these options.</li> <li>Nixidy's CRD generator is also heavily inspired by Kubenix's.</li> <li>(Document 2: Special Thanks, Document 3, Document 5, Document 10, Document 29)</li> </ul> </li> <li>Nix-Kube-Generators (<code>kubelib</code>):<ul> <li>Provides the core Nix functions for rendering Helm charts and Kustomize overlays. Nixidy's <code>lib.helm</code> and <code>lib.kustomize</code> often wrap or re-export functions from <code>nix-kube-generators</code>.</li> <li>(Document 2: Special Thanks, Document 3, Document 5, Document 22, Document 23, Document 25)</li> </ul> </li> </ul> </li> <li> <p>CRD and Schema Generation:</p> <ul> <li><code>fromCRD</code> Generator (<code>pkgs/generators/crd.nix</code>, Document 44):<ul> <li>Allows users to generate Nixidy-compatible Nix modules from Kubernetes Custom Resource Definition (CRD) YAML files.</li> <li>Uses <code>crd2jsonschema.py</code> (Document 45) to preprocess CRDs into a JSON schema format.</li> <li>Then, <code>jsonschema.nix</code> (Document 47) converts this JSON schema into Nix options.</li> </ul> </li> <li>Generated Modules: The output is a Nix file (e.g., <code>modules/generated/argocd.nix</code> for ArgoCD CRDs, Document 38) that can be imported via <code>nixidy.applicationImports</code> to provide typed options for these CRDs.<ul> <li>(Document 18: Typed Resource Options)</li> </ul> </li> </ul> </li> <li> <p>Documentation System (<code>docs/</code>):</p> <ul> <li>Uses MkDocs with the Material theme.<ul> <li>(Document 12: <code>docs.nix</code>)</li> </ul> </li> <li>Documentation for configuration options, library functions, and user guides are generated/written.</li> <li>Option search is powered by NuschtOS.<ul> <li>(Document 8, 9, 10, 11)</li> </ul> </li> </ul> </li> <li> <p>Testing Framework (<code>modules/testing/</code>, <code>tests/</code>):</p> <ul> <li>Module Tests (<code>modules/testing/default.nix</code>, <code>eval.nix</code>, Documents 39, 40): A system for defining and running tests against Nixidy modules. Assertions are made on the evaluated Nix configuration.</li> <li>Lib Tests (<code>lib/tests.nix</code>, Document 26): Unit tests for functions in <code>nixidy.lib</code> using <code>nix-unit</code>.</li> <li>Example tests are in <code>tests/</code> (Documents 50-62, 70-72).</li> </ul> </li> <li> <p>GitHub Actions (<code>actions/</code>):</p> <ul> <li>Provides reusable GitHub Actions for CI/CD.<ul> <li><code>actions/build/action.yml</code> (Document 49): Wraps <code>nixidy build</code>.</li> <li><code>actions/switch/action.yml</code> (Document 48): Wraps <code>nixidy switch</code>.</li> <li>(Document 15: GitHub Actions user guide)</li> </ul> </li> </ul> </li> </ol>"},{"location":"developer_guide/architecture/#workflow-data-flow","title":"Workflow / Data Flow","text":"<ol> <li>Definition: The user defines their cluster configuration as Nix expressions using <code>nixidy.lib.mkEnv</code> and the Nixidy module system. This includes applications, their resources (Kubernetes objects, Helm charts, Kustomize overlays), namespaces, and ArgoCD settings.</li> <li>Evaluation &amp; Processing (Triggered by <code>nixidy</code> CLI):<ul> <li>The Nixidy CLI invokes Nix to evaluate the user's configuration.</li> <li>Nixidy's core modules process the defined applications:<ul> <li>Helm charts are templated via <code>nix-kube-generators</code>.</li> <li>Kustomize overlays are built using <code>kubectl kustomize</code> (via <code>nix-kube-generators</code>).</li> <li>Plain Nix resources and raw YAMLs are parsed.</li> <li>Resource options are validated against types (from Kubenix and generated CRD modules).</li> <li>Transformers (<code>lib.kube.*</code>) can be applied to modify rendered manifests.</li> </ul> </li> </ul> </li> <li>Manifest Generation:<ul> <li>The processed resources (now Nix attribute sets) are converted into Kubernetes YAML strings.</li> <li><code>yq-go</code> is used to format these YAMLs.</li> <li>The manifests are organized into a directory structure:<ul> <li>A root directory for the environment (e.g., <code>result/</code> or specified by <code>nixidy.target.rootPath</code>).</li> <li>Subdirectories for each application (e.g., <code>result/demo/</code>).</li> <li>An <code>apps/</code> subdirectory containing ArgoCD <code>Application</code> CRs that point to the respective application manifest directories.</li> </ul> </li> </ul> </li> <li>Deployment (GitOps via Argo CD):<ul> <li>The generated manifests in the <code>result/</code> directory (or the path configured with <code>nixidy switch</code>) are committed to a Git repository.</li> <li>Argo CD monitors this Git repository (or specific paths/branches within it).</li> <li>Argo CD applies the \"App of Apps\" manifest from the <code>apps/</code> directory, which in turn manages the deployment of individual applications from their respective manifest directories.</li> </ul> </li> </ol>"},{"location":"developer_guide/architecture/#architectural-diagram-conceptual","title":"Architectural Diagram (Conceptual)","text":"<pre><code>graph LR\n    subgraph User Input\n        A[Nix Configuration] -- Defines --&gt; EnvSetup\n    end\n\n    subgraph Nixidy Core\n        EnvSetup[nixidy.lib.mkEnv/.mkEnvs] -- Loads --&gt; NixidyModules[Nixidy Internal Modules]\n        NixidyModules -- Uses --&gt; NixidyLib[Nixidy Library]\n        NixidyLib -- Wraps --&gt; Kubelib[nix-kube-generators]\n        NixidyModules -- Uses --&gt; KubenixTypes[Kubenix Resource Types]\n        NixidyModules -- Uses --&gt; GeneratedCRDTypes[Generated CRD Types]\n\n        subgraph Resource Processing\n            direction LR\n            Helm[Helm Charts] --&gt; NixidyModules\n            Kustomize[Kustomize Overlays] --&gt; NixidyModules\n            NixResources[Direct Nix Resources] --&gt; NixidyModules\n            YAMLStrings[Raw YAML Strings] --&gt; NixidyModules\n        end\n\n        NixidyModules -- Processes &amp; Merges --&gt; AppConfig[Evaluated Application Config]\n        AppConfig -- Input to --&gt; BuildLogic[Build Logic]\n        BuildLogic -- Generates --&gt; OutputPkgs[\"environmentPackage &lt;br/&gt; activationPackage &lt;br/&gt; bootstrapPackage\"]\n    end\n\n    subgraph Nixidy CLI\n        CLI_Build[\"nixidy build &lt;env&gt;\"] -- Triggers --&gt; OutputPkgs\n        CLI_Switch[\"nixidy switch &lt;env&gt;\"] -- Triggers &amp; Executes --&gt; ActivateScript{activate script}\n        CLI_Info[\"nixidy info &lt;env&gt;\"] -- Reads --&gt; EnvSetup\n        CLI_Bootstrap[\"nixidy bootstrap &lt;env&gt;\"] -- Outputs --&gt; AppOfAppsYAML((App of Apps YAML))\n\n        OutputPkgs --&gt; ResultDir[./result]\n        ActivateScript -- Rsyncs --&gt; ResultDir\n        ResultDir --&gt; ArgoCD[Argo CD]\n    end\n\n    subgraph Tooling &amp; Extensibility\n        CRDs[CRD YAMLs] --&gt; CRDGen[CRD Generator]\n        CRDGen --&gt; GeneratedCRDTypes\n        UserDocs[User Guides] --&gt; DocsGen[Documentation Generator]\n        DocsGen --&gt; DocsSite((Static Docs Site))\n        NixidyModules --&gt; Tests[Testing Framework]\n        GitHubActions[GitHub Actions] -- Wraps --&gt; NixidyCLI[Nixidy CLI Commands]\n    end\n\n    A --&gt; NixidyCLI</code></pre> <p>This overview highlights Nixidy's reliance on the Nix ecosystem for configuration management and its role in producing standard, GitOps-friendly YAML manifests for Kubernetes deployment via Argo CD. Its modular design, coupled with dependencies like Kubenix and nix-kube-generators, allows it to offer a typed and declarative approach to Kubernetes management.</p>"},{"location":"user_guide/getting_started/","title":"Getting Started","text":""},{"location":"user_guide/getting_started/#initialize-repository","title":"Initialize Repository","text":"flakesflake-less <p>First a <code>flake.nix</code> needs to be created in the root of the repository.</p> flake.nix<pre><code>{\n  description = \"My ArgoCD configuration with nixidy.\";\n\n  inputs.nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n  inputs.flake-utils.url = \"github:numtide/flake-utils\";\n  inputs.nixidy.url = \"github:arnarg/nixidy\";\n\n  outputs = {\n    self,\n    nixpkgs,\n    flake-utils,\n    nixidy,\n  }: (flake-utils.lib.eachDefaultSystem (system: let\n    pkgs = import nixpkgs {\n      inherit system;\n    };\n  in {\n    # This declares the available nixidy envs.\n    nixidyEnvs = nixidy.lib.mkEnvs {\n      inherit pkgs;\n\n      envs = {\n        # Currently we only have the one dev env.\n        dev.modules = [./env/dev.nix];\n      };\n    };\n\n    # Handy to have nixidy cli available in the local\n    # flake too.\n    packages.nixidy = nixidy.packages.${system}.default;\n\n    # Useful development shell with nixidy in path.\n    # Run `nix develop` to enter.\n    devShells.default = pkgs.mkShell {\n      buildInputs = [nixidy.packages.${system}.default];\n    };\n  }));\n}\n</code></pre> <p>Info</p> <p>In the rest of the guide when running the <code>nixidy</code> cli (e.g. <code>nixidy build</code>) you can use <code>nix run .#nixidy -- build</code> or enter a nix shell with <code>nix develop</code> where <code>nixidy</code> will be available, with the <code>flake.nix</code> example above.</p> <p>The flake declares a single nixidy environment called <code>dev</code>. It includes a single nix module found at <code>./env/dev.nix</code>, so let's create that.</p> Dependency pinning <p>Instead of using nix channels, the recommended way to use nixidy without flakes is to use either npins or niv to lock dependency versions in your repository.</p> npinsniv <p>First initialize npins: <pre><code>npins init --bare\n</code></pre></p> <p>Then add nixidy: <pre><code>npins add github arnarg nixidy --branch main # or --at vx.x.x\n</code></pre></p> <p>First initialize niv: <pre><code>niv init --no-nixpkgs\n</code></pre></p> <p>Then add nixidy: <pre><code>niv add github arnarg/nixidy --branch main # or --rev vx.x.x\n</code></pre></p> <p>First a <code>default.nix</code> needs to be created in the root of the repository.</p> default.nix<pre><code>let\n  # With npins\n  sources = import ./npins;\n  # With niv\n  # sources = import ./nix/sources.nix;\n\n  # Import nixidy\n  nixidy = import sources.nixidy {};\nin\n  nixidy.lib.mkEnvs {\n    # This declares the available nixidy envs.\n    envs = {\n      # Currently we only have the one dev env.\n      dev.modules = [./env/dev.nix];\n    };\n  }\n</code></pre> <p>It's also a good idea to have <code>shell.nix</code> file in the root of the repository to have the necessary tools available.</p> shell.nix<pre><code>let\n  # With npins\n  sources = import ./npins;\n  # With niv\n  # sources = import ./nix/sources.nix;\n\n  # nixpkgs added with:\n  #   npins: `npins add --name nixpkgs channel nixos-unstable`\n  #   niv: `niv add github nixos/nixpkgs -b nixos-unstable`\n  nixpkgs = sources.nixpkgs;\n  pkgs = import nixpkgs {};\n\n  # Import nixidy\n  nixidy = import sources.nixidy {inherit nixpkgs;};\nin\n  pkgs.mkShellNoCC {\n    packages = with pkgs; [\n      # Add nixidy cli\n      nixidy.nixidy\n      # npins\n      npins\n      # or niv\n      niv\n    ];\n  }\n</code></pre> <p>Info</p> <p>In the rest of the guide when running the <code>nixidy</code> cli (e.g. <code>nixidy build</code>) you can run <code>nix-shell</code> to enter a nix shell where <code>nixidy</code> will be a avilable, with the <code>shell.nix</code> example above.</p> <p>Warning</p> <p>In the rest of the guide the <code>nixidy</code> commands will also use the flakes format (e.g. <code>nixidy build .#dev</code>), when using a flake-less setup the <code>.#</code> prefix should be removed (e.g. <code>nixidy build dev</code>).</p> <p>The <code>default.nix</code> file declares a single nixidy environment called <code>dev</code>. It includes a single nix module found at <code>./env/dev.nix</code>, so let's create that.</p> env/dev.nix<pre><code>{\n  # Set the target repository for the rendered manifests\n  # and applications.\n  # This should be replaced with yours, usually the same\n  # repository as the nixidy definitions.\n  nixidy.target.repository = \"https://github.com/arnarg/nixidy-demo.git\";\n\n  # Set the target branch the rendered manifests for _this_\n  # environment should be pushed to in the repository defined\n  # above.\n  nixidy.target.branch = \"main\";\n\n  # Set the target sub-directory to copy the generated\n  # manifests to when running `nixidy switch .#dev`.\n  nixidy.target.rootPath = \"./manifests/dev\";\n}\n</code></pre> <p>Now running <code>nixidy info .#dev</code> you can get the same info we just declared above. This verifies that things are set up correctly so far.</p> <pre><code>&gt;&gt; nixidy info .#dev\nRepository: https://github.com/arnarg/nixidy-demo.git\nBranch:     main\n</code></pre> <p>If we now attempt to build this new environment with <code>nixidy build .#dev</code> we can see that nothing is generated but an empty folder called <code>apps</code>.</p> <pre><code>&gt;&gt; tree result\nresult\n\u2514\u2500\u2500 apps/\n</code></pre> <p>This is because we have not declared any applications yet for this environment.</p>"},{"location":"user_guide/getting_started/#our-first-application","title":"Our first Application","text":"<p>Applications and their resources are defined under <code>applications.&lt;applicationName&gt;</code>.</p> env/dev.nix<pre><code>{\n  # Set the target repository for the rendered manifests\n  # and applications.\n  # This should be replaced with yours, usually the same\n  # repository as the nixidy definitions.\n  nixidy.target.repository = \"https://github.com/arnarg/nixidy-demo.git\";\n\n  # Set the target branch the rendered manifests for _this_\n  # environment should be pushed to in the repository defined\n  # above.\n  nixidy.target.branch = \"main\";\n\n  # Set the target sub-directory to copy the generated\n  # manifests to when running `nixidy switch .#dev`.\n  nixidy.target.rootPath = \"./manifests/dev\";\n\n  # Define an application called `demo`.\n  applications.demo = {\n    # All resources will be deployed into this namespace.\n    namespace = \"demo\";\n\n    # Automatically generate a namespace resource for the\n    # above set namespace\n    createNamespace = true;\n\n    resources = let\n      labels = {\n        \"app.kubernetes.io/name\" = \"nginx\";\n      };\n    in {\n      # Define a deployment for running an nginx server\n      deployments.nginx.spec = {\n        selector.matchLabels = labels;\n        template = {\n          metadata.labels = labels;\n          spec = {\n            securityContext.fsGroup = 1000;\n            containers.nginx = {\n              image = \"nginx:1.25.1\";\n              imagePullPolicy = \"IfNotPresent\";\n              volumeMounts = {\n                \"/etc/nginx\".name = \"config\";\n                \"/var/lib/html\".name = \"static\";\n              };\n            };\n            volumes = {\n              config.configMap.name = \"nginx-config\";\n              static.configMap.name = \"nginx-static\";\n            };\n          };\n        };\n      };\n\n      # Define config maps with config for nginx\n      configMaps = {\n        nginx-config.data.\"nginx.conf\" = ''\n          user nginx nginx;\n          error_log /dev/stdout info;\n          pid /dev/null;\n          events {}\n          http {\n            access_log /dev/stdout;\n            server {\n              listen 80;\n              index index.html;\n              location / {\n                root /var/lib/html;\n              }\n            }\n          }\n        '';\n\n        nginx-static.data.\"index.html\" = ''\n          &lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello from NGINX&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\n        '';\n      };\n\n      # Define service for nginx\n      services.nginx.spec = {\n        selector = labels;\n        ports.http.port = 80;\n      };\n    };\n  };\n}\n</code></pre> <p>Running <code>nixidy build .#dev</code> will produce the following files.</p> <pre><code>&gt;&gt; tree -l result/\n\u251c\u2500\u2500 apps\n\u2502   \u2514\u2500\u2500 Application-demo.yaml\n\u2514\u2500\u2500 demo\n    \u251c\u2500\u2500 ConfigMap-nginx-config.yaml\n    \u251c\u2500\u2500 ConfigMap-nginx-static.yaml\n    \u251c\u2500\u2500 Deployment-nginx.yaml\n    \u251c\u2500\u2500 Namespace-demo.yaml\n    \u2514\u2500\u2500 Service-nginx.yaml\n</code></pre> <p>And the contents of the Argo CD application automatically generated is the following:</p> apps/Application-demo.yaml<pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  # This is the name of the application (`applications.demo`).\n  name: demo\n  namespace: argocd\nspec:\n  destination:\n    # This is the destination namespace for the application\n    # specified with `applications.demo.namespace`.\n    namespace: demo\n    server: https://kubernetes.default.svc\n  project: default\n  source:\n    # This is the output path declared for the application with\n    # option `applications.&lt;applicationName&gt;.output.path`\n    # (defaults to the name) with `nixidy.target.rootPath`\n    # prefix.\n    path: ./manifests/dev/demo\n    # Repository specified in `nixidy.target.repository`.\n    repoURL: https://github.com/arnarg/nixidy-demo.git\n    # Branch specified in `nixidy.target.branch`.\n    targetRevision: main\n  syncPolicy:\n    automated:\n      prune: false\n      selfHeal: false\n</code></pre> <p>A directory with rendered resources is generated for each application declared with <code>applications.&lt;name&gt;</code> as well as an Argo CD application resource YAML file in <code>apps/</code>. What this provides is the option to bootstrap the whole rendered branch to a cluster by adding an application pointing to the <code>apps/</code> folder.</p> <p>See App of Apps Pattern.</p> <p>Running <code>nixidy switch .#dev</code> will create the <code>./manifests/dev</code> relative to the current working directory and sync the newly generated manifests into it.</p>"},{"location":"user_guide/getting_started/#bootstrapping-cluster","title":"Bootstrapping Cluster","text":"<p>After creating a git repository that is specified in <code>nixidy.target.repository</code> and pushing the generated manifests (e.g. by running <code>nixidy switch .#dev</code>) to the branch specified in <code>nixidy.target.branch</code>, your cluster can be bootstrapped.</p> <p>Make sure you have access to the Kubernetes API and Argo CD is installed and running on your cluster (refer to Argo CD's getting started guide for that).</p> <p>For quick bootstrapping you can run the command <code>nixidy bootstrap</code> to output an initial <code>Application</code> that will trigger a deployment of all other applications.</p> <pre><code>&gt;&gt; nixidy bootstrap .#dev\n---\napiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: apps\n  namespace: argocd\nspec:\n  destination:\n    namespace: argocd\n    server: https://kubernetes.default.svc\n  project: default\n  source:\n    path: ./manifests/dev/apps\n    repoURL: https://github.com/arnarg/nixidy-demo.git\n    targetRevision: main\n  syncPolicy:\n    automated:\n      prune: true\n      selfHeal: true\n</code></pre> <p>To actually deploy it, run <code>nixidy bootstrap .#dev | kubectl apply -f -</code> (this assumes that the argocd namespace already exists in the cluster).</p> <p>Alternatively, create a new application in the Argo CD Web GUI by specifying the <code>manifests/dev/apps</code> path.</p>"},{"location":"user_guide/getting_started/#next-steps","title":"Next Steps","text":"<p>Now that the cluster is running the applications specified in your nixidy config, you might want to build your applications on top of helm charts or have Github Actions generate the manifests.</p>"},{"location":"user_guide/git_strategies/","title":"Git Strategies","text":"<p>When it comes to planning out how to structure the git repositories for your environments some options are available.</p>"},{"location":"user_guide/git_strategies/#monorepo","title":"Monorepo","text":"<p>With this strategy everything happens on the <code>main</code>/<code>master</code> branch. With every change to nixidy modules should result in a rebuild and the resulting manifests will be put in a sub-directory on the same branch.</p> <p></p> <p>The biggest gain from using this strategy is fast iteration locally as any change made to a nixidy module can be previewed by running <code>nixidy switch .#&lt;env&gt;</code> and then followed by <code>git diff</code> to see what has actually changed in the generated manifests.</p> <p>This strategy does require more complicated access control mechanism such as CODEOWNER file to make sure not everyone can change the generated manifests.</p>"},{"location":"user_guide/git_strategies/#setup","title":"Setup","text":"<p>In a module that's common to all the environment the target repository and branch needs to be set.</p> modules/default.nix<pre><code>{\n  # Set the target repository for the rendered manifests\n  # and applications.\n  # This should be replaced with yours.\n  nixidy.target.repository = \"https://github.com/arnarg/nixidy-demo.git\";\n\n  # Set the target branch the rendered manifests for every\n  # environment should be pushed to in the repository defined\n  # above.\n  nixidy.target.branch = \"main\";\n}\n</code></pre> <p>And in a module that's specific to each environment the target root path needs to be set.</p> env/dev.nix<pre><code>{\n  # Set the target sub-directory to copy the generated\n  # manifests to when running `nixidy switch .#dev`.\n  nixidy.target.rootPath = \"./manifests/dev\";\n}\n</code></pre> <p>Tip</p> <p>When using <code>mkEnvs</code> from nixidy, each environment's <code>rootPath</code> is automatically set to <code>./manifests/${dev}</code>.</p>"},{"location":"user_guide/git_strategies/#environment-branches","title":"Environment branches","text":"<p>With this strategy generated manifests are committed and pushed to separate environment specific branches. As these branches will not share any git history with the <code>main</code> branch or other environment branches (this is not git flow) they need to be created as orphan branches.</p> <p></p> <p>The biggest gain from this strategy is that it's simpler to implement access control compared to the monorepo, the branches can be setup with basic branch protection rules.</p>"},{"location":"user_guide/git_strategies/#setup_1","title":"Setup","text":"<p>In a module that's common to all the environments the target repository needs to be set. Unless you want the root path to differ between the environment's that can also be set here.</p> modules/default.nix<pre><code>{\n  # Set the target repository for the rendered manifests\n  # and applications.\n  # This should be replaced with yours.\n  nixidy.target.repository = \"https://github.com/arnarg/nixidy-demo.git\";\n\n  # The generated manifests should be at the root of\n  # each environment branch.\n  nixidy.target.rootPath = \"./\";\n}\n</code></pre> <p>And in a module that's specific to each environment the target branch needs to be set.</p> env/dev.nix<pre><code>{\n  # Set the target branch the rendered manifests for _this_\n  # environment should be pushed to in the repository defined\n  # above.\n  nixidy.target.branch = \"env/dev\";\n}\n</code></pre> <p>Info</p> <p>The environment branches need to be created manually and they need to be created as orphan branches.</p> <pre><code>git checkout --orphan env/dev\necho \"# env/dev\" &gt; README.md\ngit add README.md\ngit commit -m \"Initial commmit\"\ngit push -u origin env/dev\n</code></pre>"},{"location":"user_guide/git_strategies/#environment-repositories","title":"Environment repositories","text":"<p>With this strategy generated manifests are committed and pushed to separate repositories entirely.</p> <p></p> <p>The biggest gain from this strategy is that it's possible to go even further with access control from the environment branches.</p>"},{"location":"user_guide/git_strategies/#setup_2","title":"Setup","text":"<p>In a module that's common to all the branches only the root path should be set, unless that should differ between the environments.</p> modules/default.nix<pre><code>{\n  # The generated manifests should be at the root of\n  # each environment repository.\n  nixidy.target.rootPath = \"./\";\n}\n</code></pre> <p>And in a module that's specific to each environment the target repository and target branch needs to be set.</p> env/dev.nix<pre><code>{\n  # Set the target repository for the rendered manifests\n  # and applications.\n  # This should be replaced with yours.\n  nixidy.target.repository = \"https://github.com/arnarg/nixidy-demo-dev.git\";\n\n  # Set the target branch the rendered manifests for _this_\n  # environment should be pushed to in the repository defined\n  # above.\n  nixidy.target.branch = \"main\";\n}\n</code></pre>"},{"location":"user_guide/github_actions/","title":"GitHub Actions","text":"<p>Nixidy offers two GitHub Actions to build and switch to an environment.</p>"},{"location":"user_guide/github_actions/#arnargnixidyactionsbuild","title":"arnarg/nixidy/actions/build","text":"<p>This action will run <code>nixidy build</code> on a specified environment. It will not produce a <code>result</code> symlink and instead will have the output path in it's output <code>out-path</code>.</p>"},{"location":"user_guide/github_actions/#example","title":"Example","text":"<pre><code>name: Generate Kubernetes manifests\n\non:\n  push:\n    branches:\n      - main\n    paths-ignore:\n      - manifests/**\n\njobs:\n  generate:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v4\n\n    - uses: cachix/install-nix-action@v31\n      with:\n        # The `arnarg/nixidy/actions/build` action depends\n        # on nix flakes to run the actual nixidy cli.\n        # Therefore the following setting is required even\n        # when using nixidy with non-flakes.\n        extra_nix_config: |\n          extra-experimental-features = nix-command flakes\n\n    - uses: arnarg/nixidy/actions/build@main\n      id: build\n      with:\n        environment: .#dev\n        # Without flakes:\n        # environment: dev\n\n    - shell: bash\n      run: |\n        rsync --recursive --delete '${{steps.build.outputs.out-path}}/' manifests\n\n    - uses: EndBug/add-and-commit@v9\n      id: commit\n      with:\n        default_author: github_actions\n        message: \"chore: promote to dev ${{github.sha}}\"\n        fetch: false\n        new_branch: promote/env/dev\n        push: --set-upstream origin promote/env/dev --force\n\n    - uses: thomaseizinger/create-pull-request@1.4.0\n      if: ${{ steps.commit.outputs.pushed == 'true' }}\n      with:\n        github_token: ${{github.token}}\n        head: promote/env/dev\n        base: main\n        title: \"chore: promote to dev ${{github.sha}}\"\n</code></pre>"},{"location":"user_guide/github_actions/#arnargnixidyactionsswitch","title":"arnarg/nixidy/actions/switch","text":"<p>This action will run <code>nixidy switch</code> on a specified environment.</p>"},{"location":"user_guide/github_actions/#example_1","title":"Example","text":"<pre><code>name: Generate Kubernetes manifests\n\non:\n  push:\n    branches:\n      - main\n    paths-ignore:\n      - manifests/**\n\njobs:\n  generate:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v4\n\n    - uses: cachix/install-nix-action@v31\n      with:\n        # The `arnarg/nixidy/actions/switch` action depends\n        # on nix flakes to run the actual nixidy cli.\n        # Therefore the following setting is required even\n        # when using nixidy with non-flakes.\n        extra_nix_config: |\n          extra-experimental-features = nix-command flakes\n\n    - uses: arnarg/nixidy/actions/switch@main\n      with:\n        environment: .#dev\n        # Without flakes:\n        # environment: dev\n\n    - uses: EndBug/add-and-commit@v9\n      id: commit\n      with:\n        default_author: github_actions\n        message: \"chore: promote to dev ${{github.sha}}\"\n        fetch: false\n        new_branch: promote/env/dev\n        push: --set-upstream origin promote/env/dev --force\n\n    - uses: thomaseizinger/create-pull-request@1.4.0\n      if: ${{ steps.commit.outputs.pushed == 'true' }}\n      with:\n        github_token: ${{github.token}}\n        head: promote/env/dev\n        base: main\n        title: \"chore: promote to dev ${{github.sha}}\"\n</code></pre>"},{"location":"user_guide/helm_charts/","title":"Using Helm Charts","text":"<p>For better or for worse majority of software that's deployable to Kubernetes is packaged using Helm by developers or its community. It would be a waste not to use them and having to define all of its manifest yourself in nixidy.</p>"},{"location":"user_guide/helm_charts/#adding-a-helm-release-as-part-of-an-application","title":"Adding a Helm release as part of an application","text":"<p>Nixidy supports rendering Helm charts as part of applications. This can be done by specifying <code>applications.&lt;applicationName&gt;.helm.releases.&lt;releaseName&gt;</code>.</p>"},{"location":"user_guide/helm_charts/#example","title":"Example","text":"<pre><code>{lib, ...}: {\n  applications.traefik = {\n    namespace = \"traefik\";\n    createNamespace = true;\n\n    helm.releases.traefik = {\n      # Use `lib.helm.downloadHelmChart` to fetch\n      # the Helm Chart to use.\n      chart = lib.helm.downloadHelmChart {\n        repo = \"https://traefik.github.io/charts/\";\n        chart = \"traefik\";\n        version = \"25.0.0\";\n        chartHash = \"sha256-ua8KnUB6MxY7APqrrzaKKSOLwSjDYkk9tfVkb1bqkVM=\";\n      };\n\n      # Example values to pass to the Helm Chart.\n      values = {\n        ingressClass.enabled = true;\n      };\n    };\n  };\n}\n</code></pre>"},{"location":"user_guide/helm_charts/#patching-manifests-rendered-by-helm","title":"Patching manifests rendered by Helm","text":"<p>In some cases the Helm Chart doesn't support changing certain aspects of the final manifests. These can be modified to nixidy by overriding certain fields.</p>"},{"location":"user_guide/helm_charts/#example_1","title":"Example","text":"<pre><code>{lib, ...}: {\n  applications.traefik = {\n    namespace = \"traefik\";\n    createNamespace = true;\n\n    helm.releases.traefik = {\n      # Use `lib.helm.downloadHelmChart` to fetch\n      # the Helm Chart to use.\n      chart = lib.helm.downloadHelmChart {\n        repo = \"https://traefik.github.io/charts/\";\n        chart = \"traefik\";\n        version = \"25.0.0\";\n        chartHash = \"sha256-ua8KnUB6MxY7APqrrzaKKSOLwSjDYkk9tfVkb1bqkVM=\";\n      };\n\n      # Example values to pass to the Helm Chart.\n      values = {\n        ingressClass.enabled = true;\n      };\n    };\n\n    resources = {\n      # Add a label to the traefik pod and change\n      # the image.\n      deployments.traefik.spec.template = {\n        metadata.labels.my-custom-label = \"my-custom-values\";\n        spec.containers.traefik.image = lib.mkForce \"my-registry.io/patched-traefik:v3.0.0\";\n      };\n    };\n  };\n}\n</code></pre>"},{"location":"user_guide/transformers/","title":"Transformers","text":"<p>Nixidy supports adding a transformers to Helm releases and Kustomize applications. A transformer is only a function that takes in a list of Kubernetes manifests in attribute sets and returns the same (<code>[AttrSet] -&gt; [AttrSet]</code>). It is called after the manifests have been rendered and parsed into nix but before they're transformed into the nixidy form (<code>&lt;group&gt;.&lt;version&gt;.&lt;kind&gt;.&lt;name&gt;</code>) and can be used to modify the resources.</p> <p>Transformers can be set globally in <code>nixidy.defaults.helm.transformer</code> for Helm releases and <code>nixidy.defaults.kustomize.transformer</code> for kustomize applications.</p>"},{"location":"user_guide/transformers/#remove-version-specific-labels","title":"Remove Version Specific Labels","text":"<p>It's very common that helm charts will add the labels <code>helm.sh/chart</code> and <code>app.kubernetes.io/version</code> to all resources it renders. This can produce very big diffs when they're updated and nixidy renders them and commits the manifests to a git branch. The changes in these labels are not very relevant and will mostly just be noise to distract from the actual relevant changes of the rendered output.</p> <p>A transformer can be used to filter out these labels.</p> <pre><code>{\n  applications.argocd.helm.releases.argocd = {\n    # ...\n\n    # Remove the following labels from all manifests\n    transformer = map (lib.kube.removeLabels [\n      \"app.kubernetes.io/version\"\n      \"helm.sh/chart\"\n    ]);\n  }\n}\n</code></pre> <p>Here we use map to call <code>lib.kube.removeLabels</code> on each manifest in the list to remove the specified labels. The example uses function currying, this is equivalent to <code>manifests: map (m: lib.kube.removeLabels [\"...\"] m) manifests</code>.</p>"},{"location":"user_guide/typed_resources/","title":"Typed Resource Options","text":"<p>Kubenix has done a great work with generating nix options definitions from official JSON schemas and nixidy builds on top of this.</p> <p>All core Kubernetes resources are imported by default in nixidy along with Argo CD's <code>Application</code> and <code>AppProject</code>. Every resource can be defined under <code>applications.&lt;applicationName&gt;.resources.&lt;group&gt;.&lt;version&gt;.&lt;kind&gt;</code> but is also offered as an alias <code>applications.&lt;applicationName&gt;.resources.&lt;attrName&gt;</code> where <code>&lt;attrName&gt;</code> is the plural form of the kind in camelCase.</p> <p>For example:</p> <ul> <li><code>resources.core.v1.Service</code> -&gt; <code>resources.services</code></li> <li><code>resources.\"networking.k8s.io\".v1.NetworkPolicy</code> -&gt; <code>resources.networkPolicies</code></li> </ul> <p>The lack of availability of typed resource options only hinders the ability to define the resources in nix. Any manifests that are rendered from a Helm Chart or defined in <code>applications.&lt;applicationName&gt;.yamls</code> and do not have defined resource options for that group, version and kind will go straight to the output for the application and can not be patched by nixidy.</p>"},{"location":"user_guide/typed_resources/#generating-your-own-resource-options-from-crds","title":"Generating your own resource options from CRDs","text":"<p>Thankfully a code generator for generating resource options from CRDs is provided by nixidy (this is based heavily on kubenix's code generator).</p> flakesflake-less <p>As an example, to generate resource options for Cilium's <code>CiliumNetworkPolicy</code> and <code>CiliumClusterwideNetworkPolicy</code> the following can be defined in <code>flake.nix</code>.</p> flake.nix<pre><code>{\n  description = \"My ArgoCD configuration with nixidy.\";\n\n  inputs.nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n  inputs.flake-utils.url = \"github:numtide/flake-utils\";\n\n  inputs.nixidy = {\n    url = \"github:arnarg/nixidy\";\n    inputs.nixpkgs.follows = \"nixpkgs\";\n  };\n\n  outputs = {\n    self,\n    nixpkgs,\n    flake-utils,\n    nixidy,\n  }: (flake-utils.lib.eachDefaultSystem (system: let\n    pkgs = import nixpkgs {\n      inherit system;\n    };\n  in {\n    packages = {\n      generators.cilium = nixidy.packages.${system}.generators.fromCRD {\n        name = \"cilium\";\n        src = pkgs.fetchFromGitHub {\n          owner = \"cilium\";\n          repo = \"cilium\";\n          rev = \"v1.15.6\";\n          hash = \"sha256-oC6pjtiS8HvqzzRQsE+2bm6JP7Y3cbupXxCKSvP6/kU=\";\n        };\n        crds = [\n          \"pkg/k8s/apis/cilium.io/client/crds/v2/ciliumnetworkpolicies.yaml\"\n          \"pkg/k8s/apis/cilium.io/client/crds/v2/ciliumclusterwidenetworkpolicies.yaml\"\n        ];\n      };\n    };\n  }));\n}\n</code></pre> <p>Then running <code>nix build .#generators.cilium</code> will produce a nix file that can be copied into place in your repository. After that the generated file has to be added to <code>nixidy.applicationImports</code> in your nixidy modules.</p> <p>As an example, to generate resource options for Cilium's <code>CiliumNetworkPolicy</code> and <code>CiliumClusterwideNetworkPolicy</code> the following can be defined in <code>generate.nix</code>.</p> generate.nix<pre><code>let\n  # With npins\n  sources = import ./npins;\n  # With niv\n  # sources = import ./nix/sources.nix;\n\n  # nixpkgs added with:\n  #   npins: `npins add --name nixpkgs channel nixos-unstable`\n  #   niv: `niv add github nixos/nixpkgs -b nixos-unstable`\n  nixpkgs = sources.nixpkgs;\n  pkgs = import nixpkgs {};\n\n  # Import nixidy\n  nixidy = import sources.nixidy {inherit nixpkgs;};\nin\n  {\n    cilium = nixidy.generators.fromCRD {\n      name = \"cilium\";\n      src = pkgs.fetchFromGitHub {\n        owner = \"cilium\";\n        repo = \"cilium\";\n        rev = \"v1.15.6\";\n        hash = \"sha256-oC6pjtiS8HvqzzRQsE+2bm6JP7Y3cbupXxCKSvP6/kU=\";\n      };\n      crds = [\n        \"pkg/k8s/apis/cilium.io/client/crds/v2/ciliumnetworkpolicies.yaml\"\n        \"pkg/k8s/apis/cilium.io/client/crds/v2/ciliumclusterwidenetworkpolicies.yaml\"\n      ];\n    };\n  }\n</code></pre> <p>Then running <code>nix-build generate.nix -A cilium</code> will produce a nix file that can be copied into place in your repository. After that the generated file has to be added to <code>nixidy.applicationImports</code> in your nixidy modules.</p> env/dev.nix<pre><code>{\n  nixidy.applicationImports = [\n    ./generated/cilium.nix\n  ];\n}\n</code></pre>"},{"location":"user_guide/typed_resources/#resolving-naming-conflicts","title":"Resolving Naming Conflicts","text":"<p>Sometimes, multiple Custom Resource Definitions from different sources might define the same resource <code>kind</code>. This can lead to conflicts in the generated attribute names. For instance, if two different operators both define a CRD with the kind <code>Database</code>, they would both try to generate options for <code>resources.databases</code>.</p> <p>To resolve this, the <code>fromCRD</code> function accepts a <code>namePrefix</code> argument. This prefix will be added to the generated attribute name, making it unique.</p> <p>For example, if you have two operators that both provide a <code>Database</code> CRD, you can distinguish them like this:</p> <pre><code>{\n  # For postgres-operator\n  postgres = nixidy.generators.fromCRD {\n    name = \"postgres-operator\";\n    namePrefix = \"postgres\";\n    # ...\n  };\n\n  # For mysql-operator\n  mysql = nixidy.generators.fromCRD {\n    name = \"mysql-operator\";\n    namePrefix = \"mysql\";\n    # ...\n  };\n}\n</code></pre> <p>This will generate <code>resources.postgresDatabases</code> and <code>resources.mysqlDatabases</code> respectively, avoiding any conflicts.</p> <p>If the heuristics for attribute name generation still create conflicts, for example within the same chart, or if you wish to further customize the name for ergonomics, <code>fromCRD</code> also accepts an <code>attrNameOverrides</code> argument which takes precedence over all other methods.</p> <p>This argument is a mapping from the CRD's name (<code>&lt;plural&gt;.&lt;group&gt;</code>) to the desired attribute name. For example:</p> <pre><code>{\n  keycloak = nixidy.generators.fromCRD {\n    name = \"keycloak\";\n    src = pkgs.fetchFromGitHub {\n      owner = \"crossplane-contrib\";\n      repo = \"provider-keycloak\";\n      ...\n    };\n    crds = [\n      # This CRD conflicts with Kubernetes builtin Binding\n      \"package/crds/authenticationflow.keycloak.crossplane.io_bindings.yaml\"\n      # These CRDs have identical plural references\n      \"package/crds/group.keycloak.crossplane.io_groups.yaml\"\n      \"package/crds/user.keycloak.crossplane.io_groups.yaml\"\n    ];\n    namePrefix = \"keycloak\";\n    attrNameOverrides.\"groups.user.keycloak.crossplane.io\" = \"keycloakUserGroups\";\n  };\n}\n</code></pre> <p>will expose <code>keycloakBindings</code>, <code>keycloakGroups</code>, and <code>keycloakUserGroups</code> under an application's <code>resources</code>.</p>"},{"location":"user_guide/using_nixhelm/","title":"Using nixhelm","text":"<p>nixhelm is a collection of Helm Charts that can be used with nix-kube-generators and as a result also nixidy. The charts are automatically updated to the most recent version by CI regularly.</p> flakesflake-less <p>To use with nixidy, pass the nixhelm derivation attribute set to nixidy's <code>mkEnv</code> builder like so.</p> flake.nix<pre><code>{\n  description = \"My ArgoCD configuration with nixidy.\";\n\n  inputs.nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n  inputs.flake-utils.url = \"github:numtide/flake-utils\";\n\n  inputs.nixidy = {\n    url = \"github:arnarg/nixidy\";\n    inputs.nixpkgs.follows = \"nixpkgs\";\n  };\n\n  inputs.nixhelm = {\n    url = \"github:farcaller/nixhelm\";\n    inputs.nixpkgs.follows = \"nixpkgs\";\n  };\n\n  outputs = {\n    self,\n    nixpkgs,\n    flake-utils,\n    nixidy,\n    nixhelm,\n  }: (flake-utils.lib.eachDefaultSystem (system: let\n    pkgs = import nixpkgs {\n      inherit system;\n    };\n  in {\n    nixidyEnvs.dev = nixidy.lib.mkEnv {\n      inherit pkgs;\n\n      # Pass nixhelm to all nixidy modules.\n      charts = nixhelm.chartsDerivations.${system};\n\n      modules = [./env/dev.nix];\n    };\n  }));\n}\n</code></pre> <p>To use with nixidy, pass the nixhelm <code>charts/</code> directory to nixidy in a module like so:</p> default.nix<pre><code>let\n  # With npins\n  sources = import ./npins;\n  # With niv\n  # sources = import ./nix/sources.nix;\n\n  # nixhelm added with:\n  #   npins: `npins add github farcaller nixhelm --branch master`\n  #   niv: `niv add github farcaller/nixhelm --branch master`\n  nixhelm = sources.nixhelm;\n\n  # Import nixidy\n  nixidy = import sources.nixidy {};\nin\n  nixidy.lib.mkEnvs {\n    # These modules get passed to every env.\n    modules = [\n      ({lib, ...}: {\n        # nixhelm is a flake so we can't just import it\n        # like we do in flakes (as an input).\n        # Thankfully the directory structure in nixhelm\n        # is compatible with the one expected by\n        # `lib.helm.mkChartAttrs`.\n        nixidy.charts = lib.helm.mkChartAttrs \"${nixhelm}/charts\";\n      })\n    ];\n\n    # This declares the available nixidy envs.\n    envs = {\n      # Currently we only have the one dev env.\n      dev.modules = [./env/dev.nix];\n    };\n  }\n</code></pre> <p>And then the argument <code>charts</code> will be passed to every module in nixidy.</p> ./env/dev.nix<pre><code>{\n  charts,\n  ...\n}: {\n  applications.traefik = {\n    namespace = \"traefik\";\n    createNamespace = true;\n\n    helm.releases.traefik = {\n      # Use the traefik helm chart from nixhelm.\n      chart = charts.traefik.traefik;\n\n      # Example values to pass to the Helm Chart.\n      values = {\n        ingressClass.enabled = true;\n      };\n    };\n  };\n}\n</code></pre>"},{"location":"user_guide/using_nixhelm/#provide-your-own-charts-not-available-in-nixhelm","title":"Provide your own charts not available in nixhelm","text":"<p>Not all charts are available in nixhelm and in such cases you can contribute an initial version to them or setup a specific folder structure locally to merge with the <code>charts</code> argument passed to modules.</p> <p>With the nixidy option <code>nixidy.chartsDir</code> that folder will be walked recursively and look for <code>default.nix</code> files that will build up the charts attribute set.</p> ./charts/kubernetes-csi/csi-driver-nfs/default.nix<pre><code>{\n  repo = \"https://raw.githubusercontent.com/kubernetes-csi/csi-driver-nfs/master/charts\";\n  chart = \"csi-driver-nfs\";\n  version = \"4.7.0\";\n  chartHash = \"sha256-EU2qaZglUU3vxa41l1p/2yBscksIhYMr8kSgH8t0vL8=\";\n}\n</code></pre> <p>And then in your nixidy modules you pass that <code>./charts</code> folder to <code>nixidy.chartsDir</code>.</p> ./env/dev.nix<pre><code>{charts, ...}: {\n  # Point nixidy to a directory with charts to add to\n  # the charts attribute set.\n  nixidy.chartsDir = ../charts;\n\n  # Use the nfs chart in an application.\n  applications.csi-driver-nfs = {\n    namespace = \"kube-system\";\n\n    helm.releases.csi-driver-nfs = {\n      chart = charts.kubernetes-csi.csi-driver-nfs;\n\n      # Pass some values overrides to the chart.\n      values = {};\n    };\n  };\n}\n</code></pre>"}]}