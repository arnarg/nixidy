{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"nixidy","text":"<p>Kubernetes GitOps with nix and Argo CD.</p>"},{"location":"#special-thanks","title":"Special Thanks","text":"<p>farcaller/nix-kube-generators is used internally to pull and render Helm charts and some functions are re-exposed in the lib passed to modules in nixidy.</p>"},{"location":"library/","title":"Libary Functions","text":"<p>The argument <code>lib</code> is passed to each module in nixidy. This is a standard nixpkgs library extended with the following functions.</p>"},{"location":"library/#libresourcesfrommanifests","title":"lib.resources.fromManifests","text":"<p>Type: <code>fromManifests :: [AttrSet] -&gt; AttrSet</code></p> <p>Convert a list of kubernetes manifests (already parsed from YAML/JSON) to the resources format used in nixidy.</p> <code>manifests</code> <p>List of kubernetes manifests in nix AttrSet.</p> <p>Example:</p> <pre><code>fromManifests [\n  {\n    apiVersion = \"v1\";\n    kind = \"Namespace\";\n    metadata.name = \"default\";\n  }\n  {\n    apiVersion = \"v1\";\n    kind = \"ConfigMap\";\n    metadata = {\n      name = \"config\";\n      namespace = \"default\";\n    };\n    data = {\n      key1 = \"val1\";\n      key2 = \"val2\";\n    };\n  }\n]\n=&gt; {\n  v1 = {\n    Namespace.default = {};\n    ConfigMap.config = {\n      metadata.namespace = \"default\";\n      data = {\n        key1 = \"val1\";\n        key2 = \"val2\";\n      };\n    };\n  };\n}\n</code></pre>"},{"location":"library/#libresourcesfrommanifestyamls","title":"lib.resources.fromManifestYAMLs","text":"<p>Type: <code>fromManifestYAMLs :: [String] -&gt; AttrSet</code></p> <p>Convert a list of kubernetes manifests in YAML to the resources format used in nixidy.</p> <code>yamls</code> <p>List of kubernetes manifests in YAML.</p> <p>Example:</p> <pre><code>fromManifestYAMLs [\n  ''\n    apiVersion: v1\n    kind: Namespace\n    metadata:\n      name: default\n''\n''\n    apiVersion: v1\n    kind: ConfigMap\n    metadata:\n      name: config\n      namespace: default\n    data:\n      key1: val1\n      key2: val2\n''\n]\n=&gt; {\n  v1 = {\n    Namespace.default = {};\n    ConfigMap.config = {\n      metadata.namespace = \"default\";\n      data = {\n        key1 = \"val1\";\n        key2 = \"val2\";\n      };\n    };\n  };\n}\n</code></pre>"},{"location":"library/#libresourcesfrommanifestfiles","title":"lib.resources.fromManifestFiles","text":"<p>Type: <code>fromManifestFiles :: [Derivation] -&gt; AttrSet</code></p> <p>Read and convert a list of kubernetes manifests in files to the resources format used in nixidy.</p> <code>files</code> <p>List of derivations where the output is a single file containing kubernetes manifests in YAML.</p> <p>Example:</p> <pre><code>fromManifestFiles [\n  ./namespace.yaml\n  ./configmap.yaml\n]\n=&gt; {\n  v1 = {\n    Namespace.default = {};\n    ConfigMap.config = {\n      metadata.namespace = \"default\";\n      data = {\n        key1 = \"val1\";\n        key2 = \"val2\";\n      };\n    };\n  };\n}\n</code></pre>"},{"location":"library/#libresourcesfromkustomization","title":"lib.resources.fromKustomization","text":"<p>Type: <code>fromKustomization :: AttrSet -&gt; AttrSet</code></p> <p>Render a kustomization and convert the resources to the resources format used in nixidy.</p> structured function argument <p><code>name</code></p> <p>Name is only used for derivation name.</p> <code>src</code> <p>Derivation containing the kustomization entrypoint and all relative bases that it might reference.</p> <code>path</code> <p>Relative path from the base of <code>src</code> to the kustomization folder to render.</p> <code>namespace</code> <p>Override namespace in kustomization.yaml.</p> <p>Example:</p> <pre><code>fromKustomization {\n  name = \"argocd\";\n  src = pkgs.fetchFromGitHub {\n    owner = \"argoproj\";\n    repo = \"argo-cd\";\n    rev = \"v2.9.3\";\n    hash = \"sha256-GaY4Cw/LlSwy35umbB4epXt6ev8ya19UjHRwhDwilqU=\";\n  };\n  path = \"manifests/cluster-install\";\n  namespace = \"argocd\";\n}\n=&gt; {\n  v1 = {\n    Namespace.argocd = {};\n  };\n  # ...\n}\n</code></pre>"},{"location":"library/#libresourcesfromhelmchart","title":"lib.resources.fromHelmChart","text":"<p>Type: <code>fromHelmChart :: AttrSet -&gt; AttrSet</code></p> <p>Render a helm chart and convert the resources to the resources format used in nixidy. This function uses nix-kube-generators' <code>buildHelmChart</code> to do the helm templating.</p> <code>args</code> <p>Function argument</p> <p>Example:</p> <pre><code>fromHelmChart {\n  name = \"argocd\";\n  chart = lib.helm.downloadHelmChart {\n    repo = \"https://argoproj.github.io/argo-helm/\";\n    chart = \"argo-cd\";\n    version = \"5.51.4\";\n    chartHash = \"sha256-LOEJ5mYaHEA0RztDkgM9DGTA0P5eNd0SzSlwJIgpbWY=\";\n  };\n  namespace = \"argocd\";\n  values = {\n    server.replicas = 2;\n  };\n}\n=&gt; {\n  v1 = {\n    Namespace.argocd = {};\n  };\n  # ...\n}\n</code></pre>"},{"location":"library/#libhelmdownloadhelmchart","title":"lib.helm.downloadHelmChart","text":"<p>Type: <code>downloadHelmChart :: AttrSet -&gt; Derivation</code></p> <p>Downloads a helm chart from a helm registry.</p> <p>This is re-exported directly from farcaller/nix-kube-generators.</p>"},{"location":"library/#libhelmbuildhelmchart","title":"lib.helm.buildHelmChart","text":"<p>Type: <code>buildHelmChart :: AttrSet -&gt; Derivation</code></p> <p>Templates a helm chart with provided values and creates a derivation with the output.</p> <p>This is re-exported directly from farcaller/nix-kube-generators.</p>"},{"location":"library/#libhelmgetchartvalues","title":"lib.helm.getChartValues","text":"<p>Type: <code>getChartValues :: Derivation -&gt; AttrSet</code></p> <p>Parse the default values file shipped with the helm chart.</p> <code>chart</code> <p>Derivation containing helm chart. Usually output of lib.helm.downloadHelmChart.</p> <p>Example:</p> <pre><code>getChartValues (lib.helm.downloadHelmChart {\n    repo = \"https://argoproj.github.io/argo-helm/\";\n    chart = \"argo-cd\";\n    version = \"5.51.4\";\n    chartHash = \"sha256-LOEJ5mYaHEA0RztDkgM9DGTA0P5eNd0SzSlwJIgpbWY=\";\n})\n=&gt; {\n  server.replicas = 1;\n  controller.replicas = 1;\n  # ...\n}\n</code></pre>"},{"location":"library/#libkustomizebuildkustomization","title":"lib.kustomize.buildKustomization","text":"<p>Type: <code>buildKustomization :: AttrSet -&gt; Derivation</code></p> <p>Builds a kustomization and creates a derivation with the output.</p> structured function argument <p><code>name</code></p> <p>Name is only used for derivation name.</p> <code>src</code> <p>Derivation containing the kustomization entrypoint and all relative bases that it might reference.</p> <code>path</code> <p>Relative path from the base of <code>src</code> to the kustomization folder to render.</p> <code>namespace</code> <p>Override namespace in kustomization.yaml.</p> <p>Example:</p> <pre><code>buildKustomization {\n  name = \"argocd\";\n  src = pkgs.fetchFromGitHub {\n    owner = \"argoproj\";\n    repo = \"argo-cd\";\n    rev = \"v2.9.3\";\n    hash = \"sha256-GaY4Cw/LlSwy35umbB4epXt6ev8ya19UjHRwhDwilqU=\";\n  };\n  path = \"manifests/cluster-install\";\n  namespace = \"argocd\";\n}\n=&gt; /nix/store/7i52...7pww-kustomize-argocd\n</code></pre>"},{"location":"library/#libkubefromyaml","title":"lib.kube.fromYAML","text":"<p>Type: <code>fromYAML :: String -&gt; [AttrSet]</code></p> <p>Parses a YAML document string into a list of attribute sets.</p> <p>This is re-exported directly from farcaller/nix-kube-generators.</p> <code>yaml</code> <p>String with a yaml document.</p> <p>Example:</p> <pre><code>fromYAML ''\n  apiVersion: v1\n  kind: Namespace\n  metadata:\n    name: default\n  ---\n  apiVersion: v1\n  kind: Namespace\n  metadata:\n    name: kube-system\n''\n=&gt; [\n  {\n    apiVersion = \"v1\";\n    kind = \"Namespace\";\n    metadata.name = \"default\";\n  }\n  {\n    apiVersion = \"v1\";\n    kind = \"Namespace\";\n    metadata.name = \"kube-system\";\n  }\n]\n</code></pre>"},{"location":"library/#libkubenamespace","title":"lib.kube.namespace","text":"<p>Type: <code>namespace :: String -&gt; AttrSet -&gt; AttrSet</code></p> <p>Create a Kubernetes namespace manifest. This will create a manifest in Kubernetes format so if you want to use it for application's resources it should be then parsed with lib.resources.fromManifests.</p> <code>name</code> <p>Name of the namespace manifest to create.</p> structured function argument <p><code>annotations</code></p> <p>Optional annotations to add to the namespace manifest. This should be an attribute set.</p> <code>labels</code> <p>Optional labels to add to the namespace manifest. This should be an attribute set.</p> <p>Example:</p> <pre><code>namespace \"default\" {\n  labels = {\n    \"pod-security.kubernetes.io/enforce\" = \"privileged\";\n  };\n}\n=&gt; {\n  apiVersion = \"v1\";\n  kind = \"Namespace\";\n  metadata = {\n    name = \"default\";\n    labels = {\n      \"pod-security.kubernetes.io/enforce\" = \"privileged\";\n    };\n  };\n}\n</code></pre>"},{"location":"library/#libkubeconfigmap","title":"lib.kube.configMap","text":"<p>Type: <code>configMap :: String -&gt; AttrSet -&gt; AttrSet</code></p> <p>Create a Kubernetes config map manifest. This will create a manifest in Kubernetes format so if you want to use it for application's resources it should be then parsed with lib.resources.fromManifests.</p> <code>name</code> <p>Name of the config map manifest to create.</p> structured function argument <p><code>data</code></p> <p>Attribute set of data to put in the config map.</p> <code>namespace</code> <p>Optional namespace to add to the config map manifest.</p> <code>annotations</code> <p>Optional annotations to add to the namespace manifest. This should be an attribute set.</p> <code>labels</code> <p>Optional labels to add to the namespace manifest. This should be an attribute set.</p> <p>Example:</p> <pre><code>configMap \"my-config\" {\n  namespace = \"default\";\n  data.\"data.txt\" = \"Hello world!\";\n}\n=&gt; {\n  apiVersion = \"v1\";\n  kind = \"ConfigMap\";\n  metadata = {\n    name = \"my-config\";\n    namespace = \"default\";\n  };\n  data = {\n    \"data.txt\" = \"Hello world!\";\n  };\n}\n</code></pre>"},{"location":"library/#libkubesecret","title":"lib.kube.secret","text":"<p>Type: <code>configMap :: String -&gt; AttrSet -&gt; AttrSet</code></p> <p>Create a Kubernetes secret manifest. This will create a manifest in Kubernetes format so if you want to use it for application's resources it should be then parsed with lib.resources.fromManifests.</p> <p>Danger</p> <p>Due to the nature of nixidy this resource will be rendered to YAML and stored in cleartext in git.</p> <p>Using this resource for actual secret data is discouraged.</p> <code>name</code> <p>Name of the secret manifest to create</p> structured function argument <p><code>data</code></p> <p>Attribute set of data to put in the config map. Values should be base64 encoded.</p> <code>stringData</code> <p>Attribute set of data to put in the config map. Values should be in cleartext.</p> <code>namespace</code> <p>Optional namespace to add to the config map manifest.</p> <code>annotations</code> <p>Optional annotations to add to the namespace manifest. This should be an attribute set.</p> <code>labels</code> <p>Optional labels to add to the namespace manifest. This should be an attribute set.</p> <p>Example:</p> <pre><code>secret \"my-secret\" {\n  namespace = \"default\";\n  stringData.\"data.txt\" = \"Hello world!\";\n}\n=&gt; {\n  apiVersion = \"v1\";\n  kind = \"Secret\";\n  metadata = {\n    name = \"my-secret\";\n    namespace = \"default\";\n  };\n  stringData = {\n    \"data.txt\" = \"Hello world!\";\n  };\n}\n</code></pre>"},{"location":"library/#libkubeservice","title":"lib.kube.service","text":"<p>Type: <code>service :: String -&gt; AttrSet -&gt; AttrSet</code></p> <p>Create a Kubernetes service manifest. This will create a manifest in Kubernetes format so if you want to use it for application's resources it should be then parsed with lib.resources.fromManifests.</p> <code>name</code> <p>Name of the service manifest to create.</p> structured function argument <p><code>type</code></p> <p>Type of service to create. Defaults to <code>ClusterIP</code>.</p> <code>selector</code> <p>Label selector to match pods that this service should target. This should be an attribute set.</p> <code>ports</code> <p>Ports this service should have. This should be an attribute set (see example).</p> <code>namespace</code> <p>Optional namespace to add to the config map manifest.</p> <code>annotations</code> <p>Optional annotations to add to the namespace manifest. This should be an attribute set.</p> <code>labels</code> <p>Optional labels to add to the namespace manifest. This should be an attribute set.</p> <p>Example:</p> <pre><code>service \"nginx\" {\n  namespace = \"default\";\n  selector.app = \"nginx\";\n  ports.http = {\n    port = 80;\n  };\n}\n=&gt; {\n  apiVersion = \"v1\";\n  kind = \"Service\";\n  metadata = {\n    name = \"nginx\";\n    namespace = \"default\";\n  };\n  spec = {\n    type = \"ClusterIP\"; # Default\n    selector.app = \"nginx\";\n    ports = [\n      {\n        name = \"http\";\n        port = 80;\n        protocol = \"TCP\"; # Default\n      }\n    ];\n  };\n}\n</code></pre>"},{"location":"options/","title":"Configuration Options","text":""},{"location":"options/#applications","title":"applications","text":"<p>An application is a single Argo CD application that will be rendered by nixidy.</p> <p>The resources will be rendered into it's own directory and an Argo CD application created for it.</p> <p>Type: attribute set of (submodule)</p> <p>Default: <code>{ }</code></p> <p>Example:</p> <pre><code>{\n  argocd = {\n    namespace = \"argocd\";\n    resources = {\n      v1 = {\n        Namespace = {\n          argocd = { };\n        };\n      };\n    };\n  };\n}\n</code></pre> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamecreatenamespace","title":"applications.&lt;name&gt;.createNamespace","text":"<p>Whether or not a namespace resource should be automatically created.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleases","title":"applications.&lt;name&gt;.helm.releases","text":"<p>Helm releases to template and add to the rendered application's resources.</p> <p>Type: attribute set of (submodule)</p> <p>Default: <code>{ }</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnamechart","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.chart","text":"<p>Derivation containing the helm chart for the release.</p> <p>Type: package</p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnameincludecrds","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.includeCRDs","text":"<p>Whether or not to include CRDs in the helm release.</p> <p>Type: boolean</p> <p>Default: <code>true</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnamename","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.name","text":"<p>Name of the helm release.</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnamenamespace","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.namespace","text":"<p>Namespace for the release. When set to <code>null</code> it will use the application's namespace.</p> <p>Type: null or string</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnamevalues","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.values","text":"<p>Values to pass to the helm chart when rendering it.</p> <p>Type: attribute set of anything</p> <p>Default: <code>{ }</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamemanifests","title":"applications.&lt;name&gt;.manifests","text":"<p>List of Kubernetes manifests in nix attribute sets. They will be parsed and added to the application's <code>resources</code> where they can be overwritten and modified.</p> <p>Can be useful for using helper functions in <code>lib.kube</code>.</p> <p>Type: list of attribute set of anything</p> <p>Default: <code>[ ]</code></p> <p>Example:</p> <pre><code>[\n  {\n    apiVersion = \"v1\";\n    kind = \"Namespace\";\n    metadata = {\n      name = \"default\";\n    };\n  }\n]\n</code></pre> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamename","title":"applications.&lt;name&gt;.name","text":"<p>Name of the application.</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamenamespace","title":"applications.&lt;name&gt;.namespace","text":"<p>Namespace to deploy application into (defaults to name).</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnameoutputpath","title":"applications.&lt;name&gt;.output.path","text":"<p>Name of the folder that contains all rendered resources for the application. Relative to the root of the repository.</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnameproject","title":"applications.&lt;name&gt;.project","text":"<p>ArgoCD project to make application a part of.</p> <p>Type: string</p> <p>Default: <code>\"default\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnameresources","title":"applications.&lt;name&gt;.resources","text":"<p>Resources that make up the application.</p> <p>They should be declared in the form <code>&lt;apiVersion&gt;.&lt;kind&gt;.&lt;name&gt;</code>.</p> <p>For example the following namespace resource:</p> <pre><code>apiVersion: v1\nkind: Namespace\nmetadata:\nname: argocd\nlabels:\npod-security.kubernetes.io/enforce: privileged\n</code></pre> <p>Would be declared in like this:</p> <pre><code>{\n  v1.Namespace.argocd = {\n    metadata.labels.\"pod-security.kubernetes.io/enforce\" = \"privileged\";\n  };\n}\n</code></pre> <p>Type: attribute set of attribute set of attribute set of anything</p> <p>Default: <code>{ }</code></p> <p>Example:</p> <pre><code>{\n  v1 = {\n    ConfigMap = {\n      argocd-cmd-params-cm = {\n        data = {\n          \"server.insecure\" = \"true\";\n        };\n        metadata = {\n          namespace = \"argocd\";\n        };\n      };\n    };\n    Namespace = {\n      argocd = { };\n    };\n  };\n}\n</code></pre> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicyautomatedprune","title":"applications.&lt;name&gt;.syncPolicy.automated.prune","text":"<p>Specifies if resources should be pruned during auto-syncing.</p> <p>Defaults to <code>config.nixidy.defaultSyncPolicy.automated.prune</code>.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicyautomatedselfheal","title":"applications.&lt;name&gt;.syncPolicy.automated.selfHeal","text":"<p>Specifies if partial app sync should be executed when resources are changed only in target Kubernetes cluster and no git change detected.</p> <p>Defaults to <code>config.nixidy.defaultSyncPolicy.automated.selfHeal</code>.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnameyamls","title":"applications.&lt;name&gt;.yamls","text":"<p>List of Kubernetes manifests declared in YAML strings. They will be parsed and added to the application's <code>resources</code> where they can be overwritten and modified.</p> <p>Can be useful for reading existing YAML files (i.e. <code>[(builtins.readFile ./deployment.yaml)]</code>).</p> <p>Type: list of string</p> <p>Default: <code>[ ]</code></p> <p>Example:</p> <pre><code>[\n  ''\n    apiVersion: v1\n    kind: Namespace\n    metadata:\n      name: default\n''\n]\n</code></pre> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#nixidyappofappsname","title":"nixidy.appOfApps.name","text":"<p>Name of the application for bootstrapping all other applications (app of apps pattern).</p> <p>Type: string</p> <p>Default: <code>\"apps\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidyappofappsnamespace","title":"nixidy.appOfApps.namespace","text":"<p>Destination namespace for generated Argo CD Applications in the app of apps applications.</p> <p>Type: string</p> <p>Default: <code>\"argocd\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidydefaultsyncpolicyautomatedprune","title":"nixidy.defaultSyncPolicy.automated.prune","text":"<p>Specifies if resources should be pruned during auto-syncing. This is the default value for all applications if not explicitly set.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidydefaultsyncpolicyautomatedselfheal","title":"nixidy.defaultSyncPolicy.automated.selfHeal","text":"<p>Specifies if partial app sync should be executed when resources are changed only in target Kubernetes cluster and no git change detected. This is the default value for all applications if not explicitly set.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidyextrafiles","title":"nixidy.extraFiles","text":"<p>Extra files to write in the generated stage.</p> <p>Type: attribute set of (submodule)</p> <p>Default: <code>{ }</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidyextrafilesnamepath","title":"nixidy.extraFiles.&lt;name&gt;.path","text":"<p>Path of output file.</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidyextrafilesnametext","title":"nixidy.extraFiles.&lt;name&gt;.text","text":"<p>Text of the output file.</p> <p>Type: strings concatenated with \"\\n\"</p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidytargetrepository","title":"nixidy.target.repository","text":"<p>The repository URL to put in all generated applications.</p> <p>Type: string</p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidytargetrevision","title":"nixidy.target.revision","text":"<p>The target revision to put in all generated applications.</p> <p>Type: string</p> <p>Default: <code>\"HEAD\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"}]}