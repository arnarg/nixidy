{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"nixidy","text":"<p>Kubernetes GitOps with nix and Argo CD.</p> <p>Kind of sounds like Nix CD.</p>"},{"location":"#why","title":"Why?","text":"<p>It's desirable to manage Kubernetes clusters in a declarative way using a git repository as a source of truth for manifests that should be deployed into the cluster. One popular solution that is often used to achieve this goal is Argo CD.</p> <p>Argo CD has a concept of applications. Each application has an entrypoint somewhere in your git repository that is either a Helm chart, kustomize application, jsonnet files or just a directory of YAML files. All the resources that are output when templating the helm chart, kustomizing the kustomize application or are defined in the YAML files in the directory, make up the application and are (usually) deployed into a single namespace.</p> <p>For those reasons these git repositories often need quite elaborate designs once many applications should be deployed, requiring use of application sets (generator for applications) or custom Helm charts just to render all the different applications of the repository.</p> <p>On top of that it can be quite obscure what exactly will be deployed by just looking at helm charts (along with all the values override, usually set for each environment) or the kustomize overlays (which often are many depending on number of environments/stages) without going in and just running <code>helm template</code> or <code>kubectl kustomize</code>.</p> <p>Having dealt with these design decisions and pains that come with the different approaches I'm starting to use The Rendered Manifests Pattern. While it's explained in way more detail in the linked blog post, basically it involves using your CI system to pre-render the helm charts or the kustomize overlays and commit all the rendered manifests to an environment branch (or go through a pull request review where you can review the exact changes to your environment). That way you can just point Argo CD to your different directories full of rendered YAML manifests without having to do any helm templating or kustomize rendering.</p>"},{"location":"#nixos-module-system","title":"NixOS' Module System","text":"<p>I have been a user and a fan of NixOS for many years and how its module system works to recursively merge all configuration options that are set in many different modules.</p> <p>I have not been a fan of helm's string templating of a whitespace-sensitive configuration language or kustomize's repitition (defining a <code>kustomization.yaml</code> file for each layer statically listing files to include, some are json patches some are not...).</p> <p>Therefore I made nixidy as an experiment to see if I can make something better (at least for myself). As all Argo CD applications are defined in a single configuration it can reference configuration options across applications and automatically generate an App of Apps bootstrapping all of them.</p>"},{"location":"#demo","title":"Demo","text":"<p>See nixidy-demo.</p>"},{"location":"#non-goals","title":"Non Goals","text":""},{"location":"#typed-resource-definitions","title":"Typed Resource Definitions","text":"<p>nixidy does not concern itself with defining typed options for every possible Kubernetes resource like is done with kubenix. This approach requires automatic generation from JSON schemas of all supported resources, and needs to be updated for every new release of Kubernetes.</p> <p>That also means that it will explicitly need to support every different CRD from applications it wants to deploy.</p> <p>Instead it allows for outputing any structure as long as it's under <code>&lt;apiVersion&gt;.&lt;kind&gt;.&lt;name&gt;</code> and let Argo CD surface the error if the data is not a valid Kubernetes manifest.</p>"},{"location":"#special-thanks","title":"Special Thanks","text":"<p>farcaller/nix-kube-generators is used internally to pull and render Helm charts and some functions are re-exposed in the lib passed to modules in nixidy.</p>"},{"location":"library/","title":"Libary Functions","text":"<p>The argument <code>lib</code> is passed to each module in nixidy. This is a standard nixpkgs library extended with the following functions.</p>"},{"location":"library/#libresourcesfrommanifests","title":"lib.resources.fromManifests","text":"<p>Type: <code>fromManifests :: [AttrSet] -&gt; AttrSet</code></p> <p>Convert a list of kubernetes manifests (already parsed from YAML/JSON) to the resources format used in nixidy.</p> <code>manifests</code> <p>List of kubernetes manifests in nix AttrSet.</p> <p>Example:</p> <pre><code>fromManifests [\n  {\n    apiVersion = \"v1\";\n    kind = \"Namespace\";\n    metadata.name = \"default\";\n  }\n  {\n    apiVersion = \"v1\";\n    kind = \"ConfigMap\";\n    metadata = {\n      name = \"config\";\n      namespace = \"default\";\n    };\n    data = {\n      key1 = \"val1\";\n      key2 = \"val2\";\n    };\n  }\n]\n=&gt; {\n  v1 = {\n    Namespace.default = {};\n    ConfigMap.config = {\n      metadata.namespace = \"default\";\n      data = {\n        key1 = \"val1\";\n        key2 = \"val2\";\n      };\n    };\n  };\n}\n</code></pre>"},{"location":"library/#libresourcesfrommanifestyamls","title":"lib.resources.fromManifestYAMLs","text":"<p>Type: <code>fromManifestYAMLs :: [String] -&gt; AttrSet</code></p> <p>Convert a list of kubernetes manifests in YAML to the resources format used in nixidy.</p> <code>yamls</code> <p>List of kubernetes manifests in YAML.</p> <p>Example:</p> <pre><code>fromManifestYAMLs [\n  ''\n    apiVersion: v1\n    kind: Namespace\n    metadata:\n      name: default\n''\n''\n    apiVersion: v1\n    kind: ConfigMap\n    metadata:\n      name: config\n      namespace: default\n    data:\n      key1: val1\n      key2: val2\n''\n]\n=&gt; {\n  v1 = {\n    Namespace.default = {};\n    ConfigMap.config = {\n      metadata.namespace = \"default\";\n      data = {\n        key1 = \"val1\";\n        key2 = \"val2\";\n      };\n    };\n  };\n}\n</code></pre>"},{"location":"library/#libresourcesfrommanifestfiles","title":"lib.resources.fromManifestFiles","text":"<p>Type: <code>fromManifestFiles :: [Derivation] -&gt; AttrSet</code></p> <p>Read and convert a list of kubernetes manifests in files to the resources format used in nixidy.</p> <code>files</code> <p>List of derivations where the output is a single file containing kubernetes manifests in YAML.</p> <p>Example:</p> <pre><code>fromManifestFiles [\n  ./namespace.yaml\n  ./configmap.yaml\n]\n=&gt; {\n  v1 = {\n    Namespace.default = {};\n    ConfigMap.config = {\n      metadata.namespace = \"default\";\n      data = {\n        key1 = \"val1\";\n        key2 = \"val2\";\n      };\n    };\n  };\n}\n</code></pre>"},{"location":"library/#libresourcesfromkustomization","title":"lib.resources.fromKustomization","text":"<p>Type: <code>fromKustomization :: AttrSet -&gt; AttrSet</code></p> <p>Render a kustomization and convert the resources to the resources format used in nixidy.</p> structured function argument <p><code>name</code></p> <p>Name is only used for derivation name.</p> <code>src</code> <p>Derivation containing the kustomization entrypoint and all relative bases that it might reference.</p> <code>path</code> <p>Relative path from the base of <code>src</code> to the kustomization folder to render.</p> <code>namespace</code> <p>Override namespace in kustomization.yaml.</p> <p>Example:</p> <pre><code>fromKustomization {\n  name = \"argocd\";\n  src = pkgs.fetchFromGitHub {\n    owner = \"argoproj\";\n    repo = \"argo-cd\";\n    rev = \"v2.9.3\";\n    hash = \"sha256-GaY4Cw/LlSwy35umbB4epXt6ev8ya19UjHRwhDwilqU=\";\n  };\n  path = \"manifests/cluster-install\";\n  namespace = \"argocd\";\n}\n=&gt; {\n  v1 = {\n    Namespace.argocd = {};\n  };\n  # ...\n}\n</code></pre>"},{"location":"library/#libresourcesfromhelmchart","title":"lib.resources.fromHelmChart","text":"<p>Type: <code>fromHelmChart :: AttrSet -&gt; AttrSet</code></p> <p>Render a helm chart and convert the resources to the resources format used in nixidy. This function uses nix-kube-generators' <code>buildHelmChart</code> to do the helm templating.</p> <code>args</code> <p>Function argument</p> <p>Example:</p> <pre><code>fromHelmChart {\n  name = \"argocd\";\n  chart = lib.helm.downloadHelmChart {\n    repo = \"https://argoproj.github.io/argo-helm/\";\n    chart = \"argo-cd\";\n    version = \"5.51.4\";\n    chartHash = \"sha256-LOEJ5mYaHEA0RztDkgM9DGTA0P5eNd0SzSlwJIgpbWY=\";\n  };\n  namespace = \"argocd\";\n  values = {\n    server.replicas = 2;\n  };\n}\n=&gt; {\n  v1 = {\n    Namespace.argocd = {};\n  };\n  # ...\n}\n</code></pre>"},{"location":"library/#libhelmdownloadhelmchart","title":"lib.helm.downloadHelmChart","text":"<p>Type: <code>downloadHelmChart :: AttrSet -&gt; Derivation</code></p> <p>Downloads a helm chart from a helm registry.</p> <p>This is re-exported directly from farcaller/nix-kube-generators.</p>"},{"location":"library/#libhelmbuildhelmchart","title":"lib.helm.buildHelmChart","text":"<p>Type: <code>buildHelmChart :: AttrSet -&gt; Derivation</code></p> <p>Templates a helm chart with provided values and creates a derivation with the output.</p> <p>This is re-exported directly from farcaller/nix-kube-generators.</p>"},{"location":"library/#libhelmgetchartvalues","title":"lib.helm.getChartValues","text":"<p>Type: <code>getChartValues :: Derivation -&gt; AttrSet</code></p> <p>Parse the default values file shipped with the helm chart.</p> <code>chart</code> <p>Derivation containing helm chart. Usually output of lib.helm.downloadHelmChart.</p> <p>Example:</p> <pre><code>getChartValues (lib.helm.downloadHelmChart {\n    repo = \"https://argoproj.github.io/argo-helm/\";\n    chart = \"argo-cd\";\n    version = \"5.51.4\";\n    chartHash = \"sha256-LOEJ5mYaHEA0RztDkgM9DGTA0P5eNd0SzSlwJIgpbWY=\";\n})\n=&gt; {\n  server.replicas = 1;\n  controller.replicas = 1;\n  # ...\n}\n</code></pre>"},{"location":"library/#libkustomizebuildkustomization","title":"lib.kustomize.buildKustomization","text":"<p>Type: <code>buildKustomization :: AttrSet -&gt; Derivation</code></p> <p>Builds a kustomization and creates a derivation with the output.</p> structured function argument <p><code>name</code></p> <p>Name is only used for derivation name.</p> <code>src</code> <p>Derivation containing the kustomization entrypoint and all relative bases that it might reference.</p> <code>path</code> <p>Relative path from the base of <code>src</code> to the kustomization folder to render.</p> <code>namespace</code> <p>Override namespace in kustomization.yaml.</p> <p>Example:</p> <pre><code>buildKustomization {\n  name = \"argocd\";\n  src = pkgs.fetchFromGitHub {\n    owner = \"argoproj\";\n    repo = \"argo-cd\";\n    rev = \"v2.9.3\";\n    hash = \"sha256-GaY4Cw/LlSwy35umbB4epXt6ev8ya19UjHRwhDwilqU=\";\n  };\n  path = \"manifests/cluster-install\";\n  namespace = \"argocd\";\n}\n=&gt; /nix/store/7i52...7pww-kustomize-argocd\n</code></pre>"},{"location":"library/#libkubefromyaml","title":"lib.kube.fromYAML","text":"<p>Type: <code>fromYAML :: String -&gt; [AttrSet]</code></p> <p>Parses a YAML document string into a list of attribute sets.</p> <p>This is re-exported directly from farcaller/nix-kube-generators.</p> <code>yaml</code> <p>String with a yaml document.</p> <p>Example:</p> <pre><code>fromYAML ''\n  apiVersion: v1\n  kind: Namespace\n  metadata:\n    name: default\n  ---\n  apiVersion: v1\n  kind: Namespace\n  metadata:\n    name: kube-system\n''\n=&gt; [\n  {\n    apiVersion = \"v1\";\n    kind = \"Namespace\";\n    metadata.name = \"default\";\n  }\n  {\n    apiVersion = \"v1\";\n    kind = \"Namespace\";\n    metadata.name = \"kube-system\";\n  }\n]\n</code></pre>"},{"location":"library/#libkuberemovelabels","title":"lib.kube.removeLabels","text":"<p>Type: <code>removeLabels :: [String] -&gt; AttrSet -&gt; AttrSet</code></p> <p>Removes labels from a Kubernetes manifest.</p> <code>labels</code> <p>List of labels that should be removed</p> <code>manifest</code> <p>Kubernetes manifest</p> <p>Example:</p> <pre><code>removeLabels [\"helm.sh/chart\"] {\n  apiVersion = \"v1\";\n  kind = \"ConfigMap\";\n  metadata = {\n    name = \"argocd-cm\";\n    labels = {\n      \"app.kubernetes.io/name\" = \"argocd-cm\";\n      \"helm.sh/chart\" = \"argo-cd-5.51.6\";\n    };\n  };\n}\n=&gt; {\n  apiVersion = \"v1\";\n  kind = \"ConfigMap\";\n  metadata = {\n    name = \"argocd-cm\";\n    labels = {\n      \"app.kubernetes.io/name\" = \"argocd-cm\";\n    };\n  };\n}\n</code></pre>"},{"location":"library/#libkubenamespace","title":"lib.kube.namespace","text":"<p>Type: <code>namespace :: String -&gt; AttrSet -&gt; AttrSet</code></p> <p>Create a Kubernetes namespace manifest. This will create a manifest in Kubernetes format so if you want to use it for application's resources it should be then parsed with lib.resources.fromManifests.</p> <code>name</code> <p>Name of the namespace manifest to create.</p> structured function argument <p><code>annotations</code></p> <p>Optional annotations to add to the namespace manifest. This should be an attribute set.</p> <code>labels</code> <p>Optional labels to add to the namespace manifest. This should be an attribute set.</p> <p>Example:</p> <pre><code>namespace \"default\" {\n  labels = {\n    \"pod-security.kubernetes.io/enforce\" = \"privileged\";\n  };\n}\n=&gt; {\n  apiVersion = \"v1\";\n  kind = \"Namespace\";\n  metadata = {\n    name = \"default\";\n    labels = {\n      \"pod-security.kubernetes.io/enforce\" = \"privileged\";\n    };\n  };\n}\n</code></pre>"},{"location":"library/#libkubeconfigmap","title":"lib.kube.configMap","text":"<p>Type: <code>configMap :: String -&gt; AttrSet -&gt; AttrSet</code></p> <p>Create a Kubernetes config map manifest. This will create a manifest in Kubernetes format so if you want to use it for application's resources it should be then parsed with lib.resources.fromManifests.</p> <code>name</code> <p>Name of the config map manifest to create.</p> structured function argument <p><code>data</code></p> <p>Attribute set of data to put in the config map.</p> <code>namespace</code> <p>Optional namespace to add to the config map manifest.</p> <code>annotations</code> <p>Optional annotations to add to the namespace manifest. This should be an attribute set.</p> <code>labels</code> <p>Optional labels to add to the namespace manifest. This should be an attribute set.</p> <p>Example:</p> <pre><code>configMap \"my-config\" {\n  namespace = \"default\";\n  data.\"data.txt\" = \"Hello world!\";\n}\n=&gt; {\n  apiVersion = \"v1\";\n  kind = \"ConfigMap\";\n  metadata = {\n    name = \"my-config\";\n    namespace = \"default\";\n  };\n  data = {\n    \"data.txt\" = \"Hello world!\";\n  };\n}\n</code></pre>"},{"location":"library/#libkubesecret","title":"lib.kube.secret","text":"<p>Type: <code>configMap :: String -&gt; AttrSet -&gt; AttrSet</code></p> <p>Create a Kubernetes secret manifest. This will create a manifest in Kubernetes format so if you want to use it for application's resources it should be then parsed with lib.resources.fromManifests.</p> <p>Danger</p> <p>Due to the nature of nixidy this resource will be rendered to YAML and stored in cleartext in git.</p> <p>Using this resource for actual secret data is discouraged.</p> <code>name</code> <p>Name of the secret manifest to create</p> structured function argument <p><code>data</code></p> <p>Attribute set of data to put in the config map. Values should be base64 encoded.</p> <code>stringData</code> <p>Attribute set of data to put in the config map. Values should be in cleartext.</p> <code>namespace</code> <p>Optional namespace to add to the config map manifest.</p> <code>annotations</code> <p>Optional annotations to add to the namespace manifest. This should be an attribute set.</p> <code>labels</code> <p>Optional labels to add to the namespace manifest. This should be an attribute set.</p> <p>Example:</p> <pre><code>secret \"my-secret\" {\n  namespace = \"default\";\n  stringData.\"data.txt\" = \"Hello world!\";\n}\n=&gt; {\n  apiVersion = \"v1\";\n  kind = \"Secret\";\n  metadata = {\n    name = \"my-secret\";\n    namespace = \"default\";\n  };\n  stringData = {\n    \"data.txt\" = \"Hello world!\";\n  };\n}\n</code></pre>"},{"location":"library/#libkubeservice","title":"lib.kube.service","text":"<p>Type: <code>service :: String -&gt; AttrSet -&gt; AttrSet</code></p> <p>Create a Kubernetes service manifest. This will create a manifest in Kubernetes format so if you want to use it for application's resources it should be then parsed with lib.resources.fromManifests.</p> <code>name</code> <p>Name of the service manifest to create.</p> structured function argument <p><code>type</code></p> <p>Type of service to create. Defaults to <code>ClusterIP</code>.</p> <code>selector</code> <p>Label selector to match pods that this service should target. This should be an attribute set.</p> <code>ports</code> <p>Ports this service should have. This should be an attribute set (see example).</p> <code>namespace</code> <p>Optional namespace to add to the config map manifest.</p> <code>annotations</code> <p>Optional annotations to add to the namespace manifest. This should be an attribute set.</p> <code>labels</code> <p>Optional labels to add to the namespace manifest. This should be an attribute set.</p> <p>Example:</p> <pre><code>service \"nginx\" {\n  namespace = \"default\";\n  selector.app = \"nginx\";\n  ports.http = {\n    port = 80;\n  };\n}\n=&gt; {\n  apiVersion = \"v1\";\n  kind = \"Service\";\n  metadata = {\n    name = \"nginx\";\n    namespace = \"default\";\n  };\n  spec = {\n    type = \"ClusterIP\"; # Default\n    selector.app = \"nginx\";\n    ports = [\n      {\n        name = \"http\";\n        port = 80;\n        protocol = \"TCP\"; # Default\n      }\n    ];\n  };\n}\n</code></pre>"},{"location":"options/","title":"Configuration Options","text":""},{"location":"options/#applications","title":"applications","text":"<p>An application is a single Argo CD application that will be rendered by nixidy.</p> <p>The resources will be rendered into it's own directory and an Argo CD application created for it.</p> <p>Type: attribute set of (submodule)</p> <p>Default: <code>{ }</code></p> <p>Example:</p> <pre><code>{\n  argocd = {\n    namespace = \"argocd\";\n    resources = {\n      v1 = {\n        Namespace = {\n          argocd = { };\n        };\n      };\n    };\n  };\n}\n</code></pre> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamecreatenamespace","title":"applications.&lt;name&gt;.createNamespace","text":"<p>Whether or not a namespace resource should be automatically created.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleases","title":"applications.&lt;name&gt;.helm.releases","text":"<p>Helm releases to template and add to the rendered application's resources.</p> <p>Type: attribute set of (submodule)</p> <p>Default: <code>{ }</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnamechart","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.chart","text":"<p>Derivation containing the helm chart for the release.</p> <p>Type: package</p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnameincludecrds","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.includeCRDs","text":"<p>Whether or not to include CRDs in the helm release.</p> <p>Type: boolean</p> <p>Default: <code>true</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnamename","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.name","text":"<p>Name of the helm release.</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnamenamespace","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.namespace","text":"<p>Namespace for the release.</p> <p>Type: string</p> <p>Default: <code>config.applications.&lt;name&gt;.namespace</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnametransformer","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.transformer","text":"<p>Function that will be applied to the list of rendered manifests after the helm templating.</p> <p>Type: function that evaluates to a(n) list of attribute set of anything</p> <p>Default: <code>config.nixidy.defaults.helm.transformer</code></p> <p>Example: <code>map (lib.kube.removeLabels [\"helm.sh/chart\"])</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnamevalues","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.values","text":"<p>Values to pass to the helm chart when rendering it.</p> <p>Type: attribute set of anything</p> <p>Default: <code>{ }</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamekustomizeapplications","title":"applications.&lt;name&gt;.kustomize.applications","text":"<p>Kustomize applications to render and add to the rendered application's resources.</p> <p>Type: attribute set of (submodule)</p> <p>Default: <code>{ }</code></p> <p>Example:</p> <pre><code>{\n  argocd = {\n    namespace = \"argocd\";\n    # Equivalent to `github.com/argoproj/argo-cd/manifests/cluster-install?ref=v2.9.3`\n    # in kustomization.yaml.\n    kustomization = {\n      src = pkgs.fetchFromGitHub {\n        owner = \"argoproj\";\n        repo = \"argo-cd\";\n        rev = \"v2.9.3\";\n        hash = \"sha256-GaY4Cw/LlSwy35umbB4epXt6ev8ya19UjHRwhDwilqU=\";\n      };\n      path = \"manifests/cluster-install\";\n    };\n  };\n};\n</code></pre> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamekustomizeapplicationsnamekustomizationpath","title":"applications.&lt;name&gt;.kustomize.applications.&lt;name&gt;.kustomization.path","text":"<p>Path relative to the base of <code>src</code> to the entrypoint kustomization directory.</p> <p>Type: string</p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamekustomizeapplicationsnamekustomizationsrc","title":"applications.&lt;name&gt;.kustomize.applications.&lt;name&gt;.kustomization.src","text":"<p>Derivation containing all the kustomize bases and overlays.</p> <p>Type: package</p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamekustomizeapplicationsnamename","title":"applications.&lt;name&gt;.kustomize.applications.&lt;name&gt;.name","text":"<p>Name of the kustomize application.</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamekustomizeapplicationsnamenamespace","title":"applications.&lt;name&gt;.kustomize.applications.&lt;name&gt;.namespace","text":"<p>Namespace for the kustomize application.</p> <p>Type: string</p> <p>Default: <code>config.applications.&lt;name&gt;.namespace</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamekustomizeapplicationsnametransformer","title":"applications.&lt;name&gt;.kustomize.applications.&lt;name&gt;.transformer","text":"<p>Function that will be applied to the list of rendered manifest from kustomize.</p> <p>Type: function that evaluates to a(n) list of attribute set of anything</p> <p>Default: <code>res: res</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamemanifests","title":"applications.&lt;name&gt;.manifests","text":"<p>List of Kubernetes manifests in nix attribute sets. They will be parsed and added to the application's <code>resources</code> where they can be overwritten and modified.</p> <p>Can be useful for using helper functions in <code>lib.kube</code>.</p> <p>Type: list of attribute set of anything</p> <p>Default: <code>[ ]</code></p> <p>Example:</p> <pre><code>[\n  {\n    apiVersion = \"v1\";\n    kind = \"Namespace\";\n    metadata = {\n      name = \"default\";\n    };\n  }\n]\n</code></pre> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamename","title":"applications.&lt;name&gt;.name","text":"<p>Name of the application.</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamenamespace","title":"applications.&lt;name&gt;.namespace","text":"<p>Namespace to deploy application into (defaults to name).</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnameoutputpath","title":"applications.&lt;name&gt;.output.path","text":"<p>Name of the folder that contains all rendered resources for the application. Relative to the root of the repository.</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnameproject","title":"applications.&lt;name&gt;.project","text":"<p>ArgoCD project to make application a part of.</p> <p>Type: string</p> <p>Default: <code>\"default\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnameresources","title":"applications.&lt;name&gt;.resources","text":"<p>Resources that make up the application.</p> <p>They should be declared in the form <code>&lt;apiVersion&gt;.&lt;kind&gt;.&lt;name&gt;</code>.</p> <p>For example the following namespace resource:</p> <pre><code>apiVersion: v1\nkind: Namespace\nmetadata:\nname: argocd\nlabels:\npod-security.kubernetes.io/enforce: privileged\n</code></pre> <p>Would be declared in like this:</p> <pre><code>{\n  v1.Namespace.argocd = {\n    metadata.labels.\"pod-security.kubernetes.io/enforce\" = \"privileged\";\n  };\n}\n</code></pre> <p>Type: attribute set of attribute set of attribute set of anything</p> <p>Default: <code>{ }</code></p> <p>Example:</p> <pre><code>{\n  v1 = {\n    ConfigMap = {\n      argocd-cmd-params-cm = {\n        data = {\n          \"server.insecure\" = \"true\";\n        };\n        metadata = {\n          namespace = \"argocd\";\n        };\n      };\n    };\n    Namespace = {\n      argocd = { };\n    };\n  };\n}\n</code></pre> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicyautomatedprune","title":"applications.&lt;name&gt;.syncPolicy.automated.prune","text":"<p>Specifies if resources should be pruned during auto-syncing.</p> <p>Type: boolean</p> <p>Default: <code>config.nixidy.defaults.syncPolicy.automated.prune</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicyautomatedselfheal","title":"applications.&lt;name&gt;.syncPolicy.automated.selfHeal","text":"<p>Specifies if partial app sync should be executed when resources are changed only in target Kubernetes cluster and no git change detected.</p> <p>Type: boolean</p> <p>Default: <code>config.nixidy.defaults.syncPolicy.automated.selfHeal</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnameyamls","title":"applications.&lt;name&gt;.yamls","text":"<p>List of Kubernetes manifests declared in YAML strings. They will be parsed and added to the application's <code>resources</code> where they can be overwritten and modified.</p> <p>Can be useful for reading existing YAML files (i.e. <code>[(builtins.readFile ./deployment.yaml)]</code>).</p> <p>Type: list of string</p> <p>Default: <code>[ ]</code></p> <p>Example:</p> <pre><code>[\n  ''\n    apiVersion: v1\n    kind: Namespace\n    metadata:\n      name: default\n''\n]\n</code></pre> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#nixidyappofappsname","title":"nixidy.appOfApps.name","text":"<p>Name of the application for bootstrapping all other applications (app of apps pattern).</p> <p>Type: string</p> <p>Default: <code>\"apps\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidyappofappsnamespace","title":"nixidy.appOfApps.namespace","text":"<p>Destination namespace for generated Argo CD Applications in the app of apps applications.</p> <p>Type: string</p> <p>Default: <code>\"argocd\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidydefaultshelmtransformer","title":"nixidy.defaults.helm.transformer","text":"<p>Function that will be applied to the list of rendered manifests after the helm templating. This option applies to all helm releases in all applications unless explicitly specified there.</p> <p>Type: function that evaluates to a(n) list of attribute set of anything</p> <p>Default: <code>res: res</code></p> <p>Example: <code>map (lib.kube.removeLabels [\"helm.sh/chart\"])</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidydefaultssyncpolicyautomatedprune","title":"nixidy.defaults.syncPolicy.automated.prune","text":"<p>Specifies if resources should be pruned during auto-syncing. This is the default value for all applications if not explicitly set.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidydefaultssyncpolicyautomatedselfheal","title":"nixidy.defaults.syncPolicy.automated.selfHeal","text":"<p>Specifies if partial app sync should be executed when resources are changed only in target Kubernetes cluster and no git change detected. This is the default value for all applications if not explicitly set.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidyextrafiles","title":"nixidy.extraFiles","text":"<p>Extra files to write in the generated stage.</p> <p>Type: attribute set of (submodule)</p> <p>Default: <code>{ }</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidyextrafilesnamepath","title":"nixidy.extraFiles.&lt;name&gt;.path","text":"<p>Path of output file.</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidyextrafilesnametext","title":"nixidy.extraFiles.&lt;name&gt;.text","text":"<p>Text of the output file.</p> <p>Type: strings concatenated with \"\\n\"</p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidytargetbranch","title":"nixidy.target.branch","text":"<p>The destination branch of the generated applications.</p> <p>Type: string</p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidytargetrepository","title":"nixidy.target.repository","text":"<p>The repository URL to put in all generated applications.</p> <p>Type: string</p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"user_guide/getting_started/","title":"Getting Started","text":"<p>Nixidy only supports Nix Flakes so that needs to be enabled.</p>"},{"location":"user_guide/getting_started/#initialize-repository","title":"Initialize Repository","text":"<p>First a <code>flake.nix</code> needs to be created in the root of the repository.</p> flake.nix<pre><code>{\n  description = \"My ArgoCD configuration with nixidy.\";\n\n  inputs.nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n  inputs.flake-utils.url = \"github:numtide/flake-utils\";\n  inputs.nixidy.url = \"github:arnarg/nixidy\";\n\n  outputs = {\n    self,\n    nixpkgs,\n    flake-utils,\n    nixidy,\n  }: (flake-utils.lib.eachDefaultSystem (system: let\n    pkgs = import nixpkgs {\n      inherit system;\n    };\n  in {\n    # This declares the available nixidy envs.\n    nixidyEnvs = nixidy.lib.mkEnvs {\n      inherit pkgs;\n\n      envs = {\n        # Currently we only have the one dev env.\n        dev.modules = [./env/dev.nix];\n      };\n    };\n\n    # Handy to have nixidy cli available in the local\n    # flake too.\n    packages.nixidy = nixidy.packages.${system}.default;\n\n    # Useful development shell with nixidy in path.\n    # Run `nix develop` to enter.\n    devShells.default = pkgs.mkShell {\n      buildInputs = [nixidy.packages.${system}.default];\n    };\n  }));\n}\n</code></pre> <p>The flake declares a single nixidy environment called <code>dev</code>. It includes a single nix module found at <code>./env/dev.nix</code>, so let's create that.</p> env/dev.nix<pre><code>{\n  # Set the target repository for the rendered manifests\n  # and applications.\n  # This should be replaced with yours, usually the same\n  # repository as the nixidy definitions.\n  nixidy.target.repository = \"https://github.com/arnarg/nixidy-demo.git\";\n\n  # Set the target branch the rendered manifests for _this_\n  # environment should be pushed to in the repository defined\n  # above.\n  # When using `mkEnvs` function in flake.nix it wil automatically\n  # set this to `\"env/${name}\"`.\n  nixidy.target.branch = \"env/dev\";\n}\n</code></pre> <p>Now runnig <code>nix run .#nixidy -- info .#dev</code> (or simply <code>nixidy info .#dev</code> if run in nix shell using <code>nix develop</code>) you can get the same info we just declared above. This verifies that things are set up correctly so far.</p> <pre><code>&gt;&gt; nix run .#nixidy -- info .#dev\nRepository: https://github.com/arnarg/nixidy-demo.git\nBranch:     env/dev\n</code></pre> <p>If we now attempt to build this new environment with <code>nix run .#nixidy -- build .#dev</code> we can see that nothing is generated but an empty folder called <code>apps</code>.</p> <pre><code>&gt;&gt; tree result\nresult\n\u2514\u2500\u2500 apps/\n</code></pre> <p>This is because we have not declared any applications yet for this environment.</p>"},{"location":"user_guide/getting_started/#our-first-application","title":"Our first Application","text":"<p>While nixidy allows you to declare all of the application's resources directly in nix it would be a waste to not be able to use Helm charts and Kustomize applications that already exists and are often officially maintained by project maintainers.</p> <p>The application's declaration is very similar whichever option you go with.</p> HelmKustomize env/dev.nix<pre><code>{lib, ...}: {\n  # Options explained in the section above.\n  nixidy.target.repository = \"https://github.com/arnarg/nixidy-demo.git\";\n  nixidy.target.branch = \"env/dev\";\n\n  # Argo CD application using the Helm chart from argo-helm.\n  applications.argocd = {\n    # Declare the destination namespace for the application.\n    namespace = \"argocd\";\n\n    # Instruct nixidy to automatically create a `Namespace`\n    # manifest in the rendered manifests for namespace\n    # selected above.\n    createNamespace = true;\n\n    # Specify Helm chart with values to template with.\n    helm.releases.argocd = {\n      # Using `downloadHelmChart` we can download\n      # the helm chart using nix.\n      # The value for `chartHash` needs to be updated\n      # with each version.\n      chart = lib.helm.downloadHelmChart {\n        repo = \"https://argoproj.github.io/argo-helm/\";\n        chart = \"argo-cd\";\n        version = \"5.51.6\";\n        chartHash = \"sha256-3kRkzOQdYa5JkrBV/+iJK3FP+LDFY1J8L20aPhcEMkY=\";\n      };\n\n      # Specify values to pass to the chart.\n      values = {\n        # Run argocd-server with 2 replicas.\n        # This is an option in the chart's `values.yaml`\n        # usually declared like this:\n        # \n        # server:\n        #   replicas: 2\n        server.replicas = 2;\n      };\n    };\n  };\n}\n</code></pre> env/dev.nix<pre><code>{pkgs, ...}: {\n  # Options explained in the section above.\n  nixidy.target.repository = \"https://github.com/arnarg/nixidy-demo.git\";\n  nixidy.target.branch = \"env/dev\";\n\n  # Argo CD application using the official kustomize application\n  # from Argo CD git repository.\n  applications.argocd = {\n    # Declare the destination namespace for the application.\n    namespace = \"argocd\";\n\n    # Instruct nixidy to automatically create a `Namespace`\n    # manifest in the rendered manifests for namespace\n    # selected above.\n    createNamespace = true;\n\n    # Specify Kustomize application to render.\n    kustomize.applications.argocd = {\n      # Equivalent to `github.com/argoproj/argo-cd/manifests/cluster-install?ref=v2.9.3`\n      # in kustomization.yaml.\n      kustomization = {\n        src = pkgs.fetchFromGitHub {\n          owner = \"argoproj\";\n          repo = \"argo-cd\";\n          rev = \"v2.9.3\";\n          hash = \"sha256-GaY4Cw/LlSwy35umbB4epXt6ev8ya19UjHRwhDwilqU=\";\n        };\n        path = \"manifests/cluster-install\";\n      };\n    };\n  };\n}\n</code></pre> <p>In both cases the following output will be generated:</p> <pre><code>tree -l result\n\u251c\u2500\u2500 apps\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 Application-argocd.yaml\n\u2514\u2500\u2500 argocd\n    \u251c\u2500\u2500 ClusterRole-argocd-application-controller.yaml\n    \u251c\u2500\u2500 ClusterRole-argocd-server.yaml\n    \u251c\u2500\u2500 ClusterRoleBinding-argocd-application-controller.yaml\n    \u251c\u2500\u2500 ClusterRoleBinding-argocd-server.yaml\n    \u251c\u2500\u2500 ConfigMap-argocd-cmd-params-cm.yaml\n    \u2514\u2500\u2500 ...\n</code></pre> <p>And the contents of the Argo CD application automatically generated is the following:</p> apps/Application-argocd.yaml<pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n# This is the name of the application (`applications.argocd`).\nname: argocd namespace: argocd\nspec:\ndestination:\n# This is the destination namespace for the application\n# specified with `applications.argocd.namespace`.\nnamespace: argocd\nserver: https://kubernetes.default.svc\nproject: default\nsource:\n# This is the output path declared for the application with\n# option `applications.output.path` (defaults to the name).\npath: argocd\n# Repository specified in `nixidy.target.repository`.\nrepoURL: https://github.com/arnarg/nixidy-demo.git\n# Branch specified in `nixidy.target.branch`.\ntargetRevision: env/dev\nsyncPolicy:\nautomated:\nprune: false\nselfHeal: false\n</code></pre> <p>A directory with rendered resources is generated for each application declared with <code>applications.&lt;name&gt;</code> as well as an Argo CD application resource YAML file in <code>apps/</code>. What this provides is the option to bootstrap the whole rendered branch to a cluster by adding an application pointing to the <code>apps/</code> folder.</p> <p>See App of Apps Pattern.</p>"},{"location":"user_guide/more_environments/","title":"More Environments","text":"<p>So far we've initialized the repository with <code>flake.nix</code> and a single environment with all options set in a single file (<code>env/dev.nix</code>). Next we'll want to add a <code>test</code> environment.</p>"},{"location":"user_guide/more_environments/#modularizing-the-configuration","title":"Modularizing the Configuration","text":"<p>Adding a test environment is as simple as copying <code>env/dev.nix</code> to <code>env/test.nix</code>, renaming the target branch and adding that to <code>flake.nix</code> under <code>envs.test.modules</code>. This however will involve a lot of code duplication and the environment will need to be maintained completely separately.</p> <p>Instead we should modularize the configuration into re-usable modules that can allow slight modification between environments (number of replicas, ingress domain, etc.).</p> <p>To start this migration a <code>modules/default.nix</code> should be created.</p> HelmKustomize modules/default.nix<pre><code>{lib, ...}: {\n  # This option should be common across all environments so we\n  # can declare it here.\n  nixidy.target.repository = \"https://github.com/arnarg/nixidy-demo.git\";\n\n  # Argo CD application using the Helm chart from argo-helm.\n  applications.argocd = {\n    # Declare the destination namespace for the application.\n    namespace = \"argocd\";\n\n    # Instruct nixidy to automatically create a `Namespace`\n    # manifest in the rendered manifests for namespace\n    # selected above.\n    createNamespace = true;\n\n    # Specify Helm chart with values to template with.\n    helm.releases.argocd = {\n      # Using `downloadHelmChart` we can download\n      # the helm chart using nix.\n      # The value for `chartHash` needs to be updated\n      # with each version.\n      chart = lib.helm.downloadHelmChart {\n        repo = \"https://argoproj.github.io/argo-helm/\";\n        chart = \"argo-cd\";\n        version = \"5.51.6\";\n        chartHash = \"sha256-3kRkzOQdYa5JkrBV/+iJK3FP+LDFY1J8L20aPhcEMkY=\";\n      };\n\n      # Specify values to pass to the chart.\n      values = {\n        # Run argocd-server with 2 replicas.\n        # This is an option in the chart's `values.yaml`\n        # usually declared like this:\n        # \n        # server:\n        #   replicas: 2\n        server.replicas = 2;\n      };\n    };\n  };\n}\n</code></pre> modules/default.nix<pre><code>{pkgs, ...}: {\n  # This option should be common across all environments so we\n  # can declare it here.\n  nixidy.target.repository = \"https://github.com/arnarg/nixidy-demo.git\";\n\n  # Argo CD application using the official kustomize application\n  # from Argo CD git repository.\n  applications.argocd = {\n    # Declare the destination namespace for the application.\n    namespace = \"argocd\";\n\n    # Instruct nixidy to automatically create a `Namespace`\n    # manifest in the rendered manifests for namespace\n    # selected above.\n    createNamespace = true;\n\n    # Specify Kustomize application to render.\n    kustomize.applications.argocd = {\n      # Equivalent to `github.com/argoproj/argo-cd/manifests/cluster-install?ref=v2.9.3`\n      # in kustomization.yaml.\n      kustomization = {\n        src = pkgs.fetchFromGitHub {\n          owner = \"argoproj\";\n          repo = \"argo-cd\";\n          rev = \"v2.9.3\";\n          hash = \"sha256-GaY4Cw/LlSwy35umbB4epXt6ev8ya19UjHRwhDwilqU=\";\n        };\n        path = \"manifests/cluster-install\";\n      };\n    };\n  };\n}\n</code></pre> <p>And in <code>flake.nix</code> we can now set it to use <code>modules/default.nix</code> as a common module like the following:</p> flake.nix<pre><code>{\n  description = \"My ArgoCD configuration with nixidy.\";\n\n  inputs.nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n  inputs.flake-utils.url = \"github:numtide/flake-utils\";\n  inputs.nixidy.url = \"github:arnarg/nixidy\";\n\n  outputs = {\n    self,\n    nixpkgs,\n    flake-utils,\n    nixidy,\n  }: (flake-utils.lib.eachDefaultSystem (system: let\n    pkgs = import nixpkgs {\n      inherit system;\n    };\n  in {\n    # This declares the available nixidy envs.\n    nixidyEnvs = nixidy.lib.mkEnvs {\n      inherit pkgs;\n\n      # Modules to include in all envs.\n      modules = [./modules];\n\n      envs = {\n        dev.modules = [./env/dev.nix];\n        test.modules = [./env/test.nix];\n      };\n    };\n  }));\n}\n</code></pre> <p>Both environment specific files now only declare the target branch:</p> env/dev.nix<pre><code>{\n  nixidy.target.branch = \"env/dev\";\n}\n</code></pre> env/test.nix<pre><code>{\n  nixidy.target.branch = \"env/test\";\n}\n</code></pre>"},{"location":"user_guide/more_environments/#abstracting-options-on-top-of-applications","title":"Abstracting Options on top of Applications","text":"<p>Now we have all common configuration in a module that is used across all environments and the next step is to also add traefik as an ingress controller. Oh! and we also want to create an ingress for Argo CD Web UI using the ingress controller. Also, come to think of it, We also don't want to run 2 replicas of argocd-server in the dev environment to save on resources.</p> <p>Reaching these goals is simple enough by overriding the few needed options directly in the env specific configuration, for example:</p> env/dev.nix<pre><code>{lib, ...}: {\n  # ...\n\n  applications.argocd.helm.releases.argocd.values = {\n    # Actually we want 1 replica only in dev.\n    server.replicas = lib.mkForce 1;\n  };\n}\n</code></pre> <p>But this requires knowing the implementation details of the application and introduces tight coupling and things become hard to change for the argocd application.</p> <p>Instead things should ideally be broken apart further and create an extra configuration interface on top. To achieve this we want to break the common modules into more files, or a module per application but with a common entrypoint.</p>"},{"location":"user_guide/more_environments/#traefik","title":"Traefik","text":"<p>Let's start by creating a module for traefik:</p> modules/traefik.nix<pre><code>{\n  lib,\n  config,\n  ...\n}: {\n  options.networking.traefik = with lib; {\n    enable = mkEnableOption \"traefik ingress controller\";\n    # Exposing some options that _could_ be set directly\n    # in the values option below can be useful for discoverability\n    # and being able to reference in other modules\n    ingressClass = {\n      enable = mkOption {\n        type = types.bool;\n        default = true;\n        description = ''\n          Whether or not an ingress class for traefik should be created automatically.\n        '';\n      };\n      name = mkOption {\n        type = types.str;\n        default = \"traefik\";\n        description = ''\n          The name of the ingress class for traefik that should be created automatically.\n        '';\n      };\n    };\n    # To not limit the consumers of this module allowing for\n    # setting the helm values directly is useful in certain\n    # situations\n    values = mkOption {\n      type = types.attrsOf types.anything;\n      default = {};\n      description = ''\n        Value overrides that will be passed to the helm chart.\n      '';\n    };\n  };\n\n  # Only create the application if traefik is enabled\n  config = lib.mkIf config.networking.traefik.enable {\n    applications.traefik = {\n      namespace = \"traefik\";\n      createNamespace = true;\n\n      helm.releases.traefik = {\n        chart = lib.helm.downloadHelmChart {\n          repo = \"https://traefik.github.io/charts/\";\n          chart = \"traefik\";\n          version = \"25.0.0\";\n          chartHash = \"sha256-ua8KnUB6MxY7APqrrzaKKSOLwSjDYkk9tfVkb1bqkVM=\";\n        };\n\n        # Here we merge default values with provided\n        # values from `config.networking.traefik.values`.\n        values = lib.recursiveUpdate {\n          ingressClass = {\n            enabled = config.networking.traefik.ingressClass.enable;\n            name = config.networking.traefik.ingressClass.name;\n          };\n        } config.networking.traefik.values;\n      };\n    };\n  };\n}\n</code></pre> <p>Here we have declared extra configuration options that can be set in other modules. By setting <code>networking.traefik.enable = true;</code> the <code>traefik</code> application will be added, otherwise not. By setting <code>networking.traefik.ingressClass.enable = false;</code> the application will not contain an ingress class for traefik, and so on.</p>"},{"location":"user_guide/more_environments/#argo-cd","title":"Argo CD","text":"<p>Now let's create a specific module for Argo CD:</p> modules/argocd.nix<pre><code>{\n  lib,\n  config,\n  ...\n}: {\n  options.services.argocd = with lib; {\n    enable = mkEnableOption \"argocd\";\n    # Configuration options for the ingress\n    ingress = {\n      enable = mkEnableOption \"argocd ingress\";\n      host = mkOption {\n        type = types.nullOr types.str;\n        default = null;\n        description = ''\n          Hostname to use in the Ingress for argocd-server.\n        '';\n      };\n      ingressClassName = mkOption {\n        type = types.str;\n        default = \"\";\n        description = ''\n          The ingress class to use in the Ingress for argocd-server.\n        '';\n      };\n    };\n    # Configuration option for setting the replicas for\n    # argocd-server\n    replicas = mkOption {\n      type = types.int;\n      default = 2;\n      description = ''\n        Number of replicas of the argocd-server deployment.\n      '';\n    };\n    # To not limit the consumers of this module allowing for\n    # setting the helm values directly is useful in certain\n    # situations\n    values = mkOption {\n      type = types.attrsOf types.anything;\n      default = {};\n      description = ''\n        Value overrides that will be passed to the helm chart.\n      '';\n    };\n  };\n\n  # Only create the application if argocd is enabled\n  config = lib.mkIf config.services.argocd.enable {\n    applications.argocd = {\n      namespace = \"argocd\";\n      createNamespace = true;\n\n      helm.releases.argocd = {\n        chart = lib.helm.downloadHelmChart {\n          repo = \"https://argoproj.github.io/argo-helm/\";\n          chart = \"argo-cd\";\n          version = \"5.51.6\";\n          chartHash = \"sha256-3kRkzOQdYa5JkrBV/+iJK3FP+LDFY1J8L20aPhcEMkY=\";\n        };\n\n        # Here we merge default values with provided\n        # values from `config.services.argocd.values`.\n        values = lib.recursiveUpdate {\n          # Set number of replicas by using service option\n          server.replicas = config.services.argocd.replicas;\n          # Create an ingress with the configured hostname\n          server.ingress = {\n            enabled = config.services.argocd.ingress.enable;\n            ingressClassName = config.services.argocd.ingress.ingressClassName;\n            hosts =\n              if !isNull config.services.argocd.ingress.host\n              then [config.services.argocd.ingress.host]\n              else [];\n          };\n        } config.services.argocd.values;\n      };\n    };\n  };\n}\n</code></pre> <p>Like with the traefik module you can now set <code>services.argocd.enable = true;</code> to enable the argocd application and <code>services.argocd.ingress.enable = true;</code> to create an ingress.</p>"},{"location":"user_guide/more_environments/#putting-it-all-together","title":"Putting it all together","text":"<p>Now with argocd and traefik declared in their own modules we will need to import them in the base <code>modules/default.nix</code>:</p> modules/default.nix<pre><code>{lib, config, ...}: {\n  # Here we import the modules we created above.\n  # This will make all the configuration options\n  # available to other modules.\n  imports = [\n    ./argocd.nix\n    ./traefik.nix\n  ];\n\n  # This option should be common across all environments so we\n  # can declare it here.\n  nixidy.target.repository = \"https://github.com/arnarg/nixidy-demo.git\";\n\n  # Traefik should be enable by default.\n  networking.traefik.enable = lib.mkDefault true;\n\n  # Argo CD should be enabled by default.\n  services.argocd = {\n    enable = lib.mkDefault true;\n\n    ingress = {\n      # An ingress for Argo CD Web UI should\n      # be created if traefik is also enabled.\n      enable = lib.mkDefault config.networking.traefik.enable;\n\n      # The ingress should use Treafik's ingress\n      # class.\n      ingressClassName = lib.mkDefault config.networking.traefik.ingressClass.name;\n    };\n  };\n}\n</code></pre> <p>This will import the two application modules and set some defaults by using <code>mkDefault</code> (this function sets the value as a default value but still allows overriding it in other modules). Notably we have set it up in a way that will automatically enable the ingress for Argo CD Web UI if traefik is also enabled, which is also enabled in this file but can be still be disabled in another module.</p> <p>Now in order to achieve the goals we set out to achieve in the beginning of this section, the following options are set in the environments' configurations:</p> env/dev.nix<pre><code>{\n  nixidy.target.branch = \"env/dev\";\n\n  # We want to set the hostname for ArgoCD Web UI\n  services.argocd.ingress.host = \"argocd.dev.domain.com\";\n\n  # We only want 1 replica of argocd server\n  services.argocd.replicas = 1;\n}\n</code></pre> env/test.nix<pre><code>{\n  nixidy.target.branch = \"env/test\";\n\n  # We want to set the hostname for ArgoCD Web UI\n  services.argocd.ingress.host = \"argocd.test.domain.com\";\n}\n</code></pre> <p>Now the following manifests are generated:</p> <pre><code>&gt;&gt; tree -l result\nresult\n\u251c\u2500\u2500 apps\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Application-argocd.yaml\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 Application-traefik.yaml\n\u251c\u2500\u2500 argocd\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 ClusterRole-argocd-application-controller.yaml\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 ClusterRole-argocd-notifications-controller.yaml\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 ClusterRole-argocd-repo-server.yaml\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 ClusterRole-argocd-server.yaml\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 ClusterRoleBinding-argocd-application-controller.yaml\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 traefik\n    \u251c\u2500\u2500 ClusterRoleBinding-traefik-traefik.yaml\n    \u251c\u2500\u2500 ClusterRole-traefik-traefik.yaml\n    \u251c\u2500\u2500 CustomResourceDefinition-ingressroutes-traefik-containo-us.yaml\n    \u251c\u2500\u2500 CustomResourceDefinition-ingressroutes-traefik-io.yaml\n    \u251c\u2500\u2500 CustomResourceDefinition-ingressroutetcps-traefik-containo-us.yaml\n    \u2514\u2500\u2500 ...\n</code></pre>"}]}