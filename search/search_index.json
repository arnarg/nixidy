{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"nixidy","text":"<p>Kubernetes GitOps with nix and Argo CD.</p> <p>Kind of sounds like Nix CD.</p>"},{"location":"#what-is-it","title":"What is it?","text":"<p>Manage an entire Kubernetes cluster like it's NixOS, then have CI generate plain YAML manifests for ArgoCD.</p> <pre><code>{\n  applications.demo = {\n    namespace = \"demo\";\n\n    # Automatically generate a namespace resource with the\n    # above set namespace\n    createNamespace = true;\n\n    resources = let\n      labels = {\n        \"app.kubernetes.io/name\" = \"nginx\";\n      };\n    in {\n      # Define a deployment for running an nginx server\n      deployments.nginx.spec = {\n        selector.matchLabels = labels;\n        template = {\n          metadata.labels = labels;\n          spec = {\n            securityContext.fsGroup = 1000;\n            containers.nginx = {\n              image = \"nginx:1.25.1\";\n              imagePullPolicy = \"IfNotPresent\";\n              volumeMounts = {\n                \"/etc/nginx\".name = \"config\";\n                \"/var/lib/html\".name = \"static\";\n              };\n            };\n            volumes = {\n              config.configMap.name = \"nginx-config\";\n              static.configMap.name = \"nginx-static\";\n            };\n          };\n        };\n      };\n\n      # Define config maps with config for nginx\n      configMaps = {\n        nginx-config.data.\"nginx.conf\" = ''\n          user nginx nginx;\n          error_log /dev/stdout info;\n          pid /dev/null;\n          events {}\n          http {\n            access_log /dev/stdout;\n            server {\n              listen 80;\n              index index.html;\n              location / {\n                root /var/lib/html;\n              }\n            }\n          }\n        '';\n\n        nginx-static.data.\"index.html\" = ''\n          &lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello from NGINX&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\n        '';\n      };\n\n      # Define service for nginx\n      services.nginx.spec = {\n        selector = labels;\n        ports.http.port = 80;\n      };\n    };\n  };\n}\n</code></pre> <p>Then build with nixidy using <code>nixidy build .#prod</code></p> <pre><code>tree -l result/\n\u251c\u2500\u2500 apps\n\u2502   \u2514\u2500\u2500 Application-demo.yaml\n\u2514\u2500\u2500 demo\n    \u251c\u2500\u2500 ConfigMap-nginx-config.yaml\n    \u251c\u2500\u2500 ConfigMap-nginx-static.yaml\n    \u251c\u2500\u2500 Deployment-nginx.yaml\n    \u251c\u2500\u2500 Namespace-demo.yaml\n    \u2514\u2500\u2500 Service-nginx.yaml\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Take a look at the getting started guide.</p>"},{"location":"#examples","title":"Examples","text":"<ul> <li>arnarg's cluster configuration</li> </ul>"},{"location":"#why","title":"Why?","text":"<p>It's desirable to manage Kubernetes clusters in a declarative way using a git repository as a source of truth for manifests that should be deployed into the cluster. One popular solution that is often used to achieve this goal is Argo CD.</p> <p>Argo CD has a concept of applications. Each application has an entrypoint somewhere in your git repository that is either a Helm chart, kustomize application, jsonnet files or just a directory of YAML files. All the resources that are output when templating the helm chart, kustomizing the kustomize application or are defined in the YAML files in the directory, make up the application and are (usually) deployed into a single namespace.</p> <p>For those reasons these git repositories often need quite elaborate designs once many applications should be deployed, requiring use of application sets (generator for applications) or custom Helm charts just to render all the different applications of the repository.</p> <p>On top of that it can be quite obscure what exactly will be deployed by just looking at helm charts (along with all the values override, usually set for each environment) or the kustomize overlays (which often are many depending on number of environments/stages) without going in and just running <code>helm template</code> or <code>kubectl kustomize</code>.</p> <p>Having dealt with these design decisions and pains that come with the different approaches I'm starting to use The Rendered Manifests Pattern. While it's explained in way more detail in the linked blog post, basically it involves using your CI system to pre-render the helm charts or the kustomize overlays and commit all the rendered manifests to an environment branch (or go through a pull request review where you can review the exact changes to your environment). That way you can just point Argo CD to your different directories full of rendered YAML manifests without having to do any helm templating or kustomize rendering.</p>"},{"location":"#nixos-module-system","title":"NixOS' Module System","text":"<p>I have been a user and a fan of NixOS for many years and how its module system works to recursively merge all configuration options that are set in many different modules.</p> <p>I have not been a fan of helm's string templating of a whitespace-sensitive configuration language or kustomize's repetition (defining a <code>kustomization.yaml</code> file for each layer statically listing files to include, some are JSON patches some are not...).</p> <p>Therefore I made nixidy as an experiment to see if I can make something better (at least for myself). As all Argo CD applications are defined in a single configuration it can reference configuration options across applications and automatically generate an App of Apps bootstrapping all of them.</p>"},{"location":"#special-thanks","title":"Special Thanks","text":"<p>farcaller/nix-kube-generators is used internally to pull and render Helm charts and some functions are re-exposed in the lib passed to modules in nixidy.</p> <p>hall/kubenix project has code generation of nix module options for every standard kubernetes resource. Instead of doing this work in nixidy I import their generated resource options. The resource option generation scripts in nixidy are also a slight modification of kubenix's. Without their work this wouldn't be possible in nixidy.</p>"},{"location":"library/","title":"Libary Functions","text":"<p>The argument <code>lib</code> is passed to each module in nixidy. This is the standard nixpkgs library extended with the following functions.</p>"},{"location":"library/#libhelmdownloadhelmchart","title":"lib.helm.downloadHelmChart","text":"<p>Type: <code>downloadHelmChart :: AttrSet -&gt; Derivation</code></p> <p>Downloads a helm chart from a helm registry.</p> <p>This is re-exported directly from farcaller/nix-kube-generators.</p>"},{"location":"library/#libhelmbuildhelmchart","title":"lib.helm.buildHelmChart","text":"<p>Type: <code>buildHelmChart :: AttrSet -&gt; Derivation</code></p> <p>Templates a helm chart with provided values and creates a derivation with the output.</p> <p>This is re-exported directly from farcaller/nix-kube-generators.</p>"},{"location":"library/#libhelmgetchartvalues","title":"lib.helm.getChartValues","text":"<p>Type: <code>getChartValues :: Derivation -&gt; AttrSet</code></p> <p>Parse the default values file shipped with the helm chart.</p> <code>chart</code> <p>Derivation containing helm chart. Usually output of lib.helm.downloadHelmChart.</p> <p>Example:</p> <pre><code>getChartValues (lib.helm.downloadHelmChart {\n    repo = \"https://argoproj.github.io/argo-helm/\";\n    chart = \"argo-cd\";\n    version = \"5.51.4\";\n    chartHash = \"sha256-LOEJ5mYaHEA0RztDkgM9DGTA0P5eNd0SzSlwJIgpbWY=\";\n})\n=&gt; {\n  server.replicas = 1;\n  controller.replicas = 1;\n  # ...\n}\n</code></pre>"},{"location":"library/#libhelmmkchartattrs","title":"lib.helm.mkChartAttrs","text":"<p>Type: <code>mkChartAttrs :: Path -&gt; AttrSet</code></p> <p>Walk a directory tree and import all <code>default.nix</code> to download helm charts.</p> <p>The <code>default.nix</code> needs to have the following format:</p> ./charts/kubernetes-csi/csi-driver-nfs/default.nix<pre><code>{\n  repo = \"https://raw.githubusercontent.com/kubernetes-csi/csi-driver-nfs/master/charts\";\n  chart = \"csi-driver-nfs\";\n  version = \"4.7.0\";\n  chartHash = \"sha256-EU2qaZglUU3vxa41l1p/2yBscksIhYMr8kSgH8t0vL8=\";\n}\n</code></pre> <code>dir</code> <p>Path to a directory containing the correct directory structure described above.</p> <p>Example:</p> <pre><code>mkChartAttrs ./charts\n=&gt; {\n  kubernetes-csi = {\n    csi-driver-nfs = lib.helm.downloadHelmChart {\n      repo = \"https://raw.githubusercontent.com/kubernetes-csi/csi-driver-nfs/master/charts\";\n      chart = \"csi-driver-nfs\";\n      version = \"4.7.0\";\n      chartHash = \"sha256-EU2qaZglUU3vxa41l1p/2yBscksIhYMr8kSgH8t0vL8=\";\n    };\n  };\n}\n</code></pre>"},{"location":"library/#libkustomizebuildkustomization","title":"lib.kustomize.buildKustomization","text":"<p>Type: <code>buildKustomization :: AttrSet -&gt; Derivation</code></p> <p>Builds a kustomization and creates a derivation with the output.</p> structured function argument <p><code>name</code></p> <p>Name is only used for derivation name.</p> <code>src</code> <p>Derivation containing the kustomization entrypoint and all relative bases that it might reference.</p> <code>path</code> <p>Relative path from the base of <code>src</code> to the kustomization folder to render.</p> <code>namespace</code> <p>Override namespace in kustomization.yaml.</p> <p>Example:</p> <pre><code>buildKustomization {\n  name = \"argocd\";\n  src = pkgs.fetchFromGitHub {\n    owner = \"argoproj\";\n    repo = \"argo-cd\";\n    rev = \"v2.9.3\";\n    hash = \"sha256-GaY4Cw/LlSwy35umbB4epXt6ev8ya19UjHRwhDwilqU=\";\n  };\n  path = \"manifests/cluster-install\";\n  namespace = \"argocd\";\n}\n=&gt; /nix/store/7i52...7pww-kustomize-argocd\n</code></pre>"},{"location":"library/#libkubefromyaml","title":"lib.kube.fromYAML","text":"<p>Type: <code>fromYAML :: String -&gt; [AttrSet]</code></p> <p>Parses a YAML document string into a list of attribute sets.</p> <p>This is re-exported directly from farcaller/nix-kube-generators.</p> <code>yaml</code> <p>String with a yaml document.</p> <p>Example:</p> <pre><code>fromYAML ''\n  apiVersion: v1\n  kind: Namespace\n  metadata:\n    name: default\n  ---\n  apiVersion: v1\n  kind: Namespace\n  metadata:\n    name: kube-system\n''\n=&gt; [\n  {\n    apiVersion = \"v1\";\n    kind = \"Namespace\";\n    metadata.name = \"default\";\n  }\n  {\n    apiVersion = \"v1\";\n    kind = \"Namespace\";\n    metadata.name = \"kube-system\";\n  }\n]\n</code></pre>"},{"location":"library/#libkubefromoctal","title":"lib.kube.fromOctal","text":"<p>Type: <code>fromOctal :: String -&gt; Integer</code></p> <p>Parse an octal representation of a number and convert into a decimal number. This can be useful when having to represent permission bits in a resource as nix has no support for representing octal numbers.</p> <code>octal</code> <p>String representation of the octal number to parse.</p> <p>Example:</p> <pre><code>fromOctal \"0555\"\n=&gt; 365\n</code></pre>"},{"location":"library/#libkuberemovelabels","title":"lib.kube.removeLabels","text":"<p>Type: <code>removeLabels :: [String] -&gt; AttrSet -&gt; AttrSet</code></p> <p>Removes labels from a Kubernetes manifest.</p> <code>labels</code> <p>List of labels that should be removed</p> <code>manifest</code> <p>Kubernetes manifest</p> <p>Example:</p> <pre><code>removeLabels [\"helm.sh/chart\"] {\n  apiVersion = \"v1\";\n  kind = \"ConfigMap\";\n  metadata = {\n    name = \"argocd-cm\";\n    labels = {\n      \"app.kubernetes.io/name\" = \"argocd-cm\";\n      \"helm.sh/chart\" = \"argo-cd-5.51.6\";\n    };\n  };\n}\n=&gt; {\n  apiVersion = \"v1\";\n  kind = \"ConfigMap\";\n  metadata = {\n    name = \"argocd-cm\";\n    labels = {\n      \"app.kubernetes.io/name\" = \"argocd-cm\";\n    };\n  };\n}\n</code></pre>"},{"location":"options/","title":"Configuration Options","text":"<p>To see all available resources options, use the nixidy options search powered by N\u00fcschtOS.</p>"},{"location":"options/#applications","title":"applications","text":"<p>An application is a single Argo CD application that will be rendered by nixidy.</p> <p>The resources will be rendered into it's own directory and an Argo CD application created for it.</p> <p>Type: attribute set of (submodule)</p> <p>Default: <code>{ }</code></p> <p>Example:</p> <pre><code>{\n  nginx = {\n    namespace = \"nginx\";\n    resources = {\n      deployments = {\n        nginx = {\n          spec = {\n            replicas = 3;\n            selector = {\n              matchLabels = {\n                app = \"nginx\";\n              };\n            };\n            template = {\n              metadata = {\n                labels = {\n                  app = \"nginx\";\n                };\n              };\n              spec = {\n                containers = {\n                  nginx = {\n                    image = \"nginx:1.25.1\";\n                    imagePullPolicy = \"IfNotPresent\";\n                  };\n                };\n                securityContext = {\n                  fsGroup = 1000;\n                };\n              };\n            };\n          };\n        };\n      };\n      services = {\n        nginx = {\n          spec = {\n            ports = {\n              http = {\n                port = 80;\n              };\n            };\n            selector = {\n              app = \"nginx\";\n            };\n          };\n        };\n      };\n    };\n  };\n}\n</code></pre> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnameannotations","title":"applications.&lt;name&gt;.annotations","text":"<p>Annotations to add to the rendered ArgoCD application.</p> <p>Type: attribute set of string</p> <p>Default: <code>{ }</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamecompareoptionsignoreextraneous","title":"applications.&lt;name&gt;.compareOptions.ignoreExtraneous","text":"<p>Sets IgnoreExtraneous compare option for the application. Only setting it as <code>true</code> has any effect.</p> <p>Type: null or boolean</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamecompareoptionsincludemutationwebhook","title":"applications.&lt;name&gt;.compareOptions.includeMutationWebhook","text":"<p>Sets IncludeMutationWebhook compare option for the application. Only setting it as <code>true</code> has any effect.</p> <p>Type: null or boolean</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamecompareoptionsserversidediff","title":"applications.&lt;name&gt;.compareOptions.serverSideDiff","text":"<p>Sets ServerSideDiff compare option for the application. Leave as <code>null</code> for the default behavior.</p> <p>Type: null or boolean</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamecreatenamespace","title":"applications.&lt;name&gt;.createNamespace","text":"<p>Whether or not a namespace resource should be automatically created.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamedestinationserver","title":"applications.&lt;name&gt;.destination.server","text":"<p>The Kubernetes server that ArgoCD should deploy the application to.</p> <p>Type: string</p> <p>Default: <code>config.nixidy.defaults.destination.server</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleases","title":"applications.&lt;name&gt;.helm.releases","text":"<p>Helm releases to template and add to the rendered application's resources.</p> <p>Type: attribute set of (submodule)</p> <p>Default: <code>{ }</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/helm.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnamechart","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.chart","text":"<p>Derivation containing the helm chart for the release.</p> <p>Type: package or path</p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/helm.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnameextraopts","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.extraOpts","text":"<p>Extra options to pass to <code>helm template</code> that is run when rendering the helm chart.</p> <p>Type: list of string</p> <p>Default: <code>[ ]</code></p> <p>Example:</p> <pre><code>[\n  \"--no-hooks\"\n]\n</code></pre> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/helm.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnameincludecrds","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.includeCRDs","text":"<p>Whether or not to include CRDs in the helm release.</p> <p>Type: boolean</p> <p>Default: <code>true</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/helm.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnamename","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.name","text":"<p>Name of the helm release.</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/helm.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnamenamespace","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.namespace","text":"<p>Namespace for the release.</p> <p>Type: string</p> <p>Default: <code>config.applications.&lt;name&gt;.namespace</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/helm.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnametransformer","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.transformer","text":"<p>Function that will be applied to the list of rendered manifests after the helm templating.</p> <p>Type: function that evaluates to a(n) list of attribute set of anything</p> <p>Default: <code>config.nixidy.defaults.helm.transformer</code></p> <p>Example: <code>map (lib.kube.removeLabels [\"helm.sh/chart\"])</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/helm.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnamevalues","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.values","text":"<p>Values to pass to the helm chart when rendering it.</p> <p>Type: attribute set of anything</p> <p>Default: <code>{ }</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/helm.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamekustomizeapplications","title":"applications.&lt;name&gt;.kustomize.applications","text":"<p>Kustomize applications to render and add to the rendered application's resources.</p> <p>Type: attribute set of (submodule)</p> <p>Default: <code>{ }</code></p> <p>Example:</p> <pre><code>{\n  argocd = {\n    namespace = \"argocd\";\n    # Equivalent to `github.com/argoproj/argo-cd/manifests/cluster-install?ref=v2.9.3`\n    # in kustomization.yaml.\n    kustomization = {\n      src = pkgs.fetchFromGitHub {\n        owner = \"argoproj\";\n        repo = \"argo-cd\";\n        rev = \"v2.9.3\";\n        hash = \"sha256-GaY4Cw/LlSwy35umbB4epXt6ev8ya19UjHRwhDwilqU=\";\n      };\n      path = \"manifests/cluster-install\";\n    };\n  };\n};\n</code></pre> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/kustomize.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamekustomizeapplicationsnamekustomizationpath","title":"applications.&lt;name&gt;.kustomize.applications.&lt;name&gt;.kustomization.path","text":"<p>Path relative to the base of <code>src</code> to the entrypoint kustomization directory.</p> <p>Type: string</p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/kustomize.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamekustomizeapplicationsnamekustomizationsrc","title":"applications.&lt;name&gt;.kustomize.applications.&lt;name&gt;.kustomization.src","text":"<p>Derivation containing all the kustomize bases and overlays.</p> <p>Type: package or path</p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/kustomize.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamekustomizeapplicationsnamename","title":"applications.&lt;name&gt;.kustomize.applications.&lt;name&gt;.name","text":"<p>Name of the kustomize application.</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/kustomize.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamekustomizeapplicationsnamenamespace","title":"applications.&lt;name&gt;.kustomize.applications.&lt;name&gt;.namespace","text":"<p>Namespace for the kustomize application.</p> <p>Type: string</p> <p>Default: <code>config.applications.&lt;name&gt;.namespace</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/kustomize.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamekustomizeapplicationsnametransformer","title":"applications.&lt;name&gt;.kustomize.applications.&lt;name&gt;.transformer","text":"<p>Function that will be applied to the list of rendered manifests from kustomize.</p> <p>Type: function that evaluates to a(n) list of attribute set of anything</p> <p>Default: <code>config.nixidy.defaults.kustomize.transformer</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/kustomize.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamename","title":"applications.&lt;name&gt;.name","text":"<p>Name of the application.</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamenamespace","title":"applications.&lt;name&gt;.namespace","text":"<p>Namespace to deploy application into (defaults to name).</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnameoutputpath","title":"applications.&lt;name&gt;.output.path","text":"<p>Name of the folder that contains all rendered resources for the application. Relative to the root of the repository.</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnameproject","title":"applications.&lt;name&gt;.project","text":"<p>ArgoCD project to make application a part of.</p> <p>Type: string</p> <p>Default: <code>\"default\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnameresources","title":"applications.&lt;name&gt;.resources","text":"<p>Kubernetes resources for the application.</p> <p>The entire list of available resource options is too large for the current documentation setup but can be searched in the nixidy options search powered by N\u00fcschtOS.</p> <p>Type: attribute set</p> <p>Default: <code>{ }</code></p> <p>Example:</p> <pre><code>{\n  deployments = {\n    nginx = {\n      spec = {\n        replicas = 3;\n        selector = {\n          matchLabels = {\n            app = \"nginx\";\n          };\n        };\n        template = {\n          metadata = {\n            labels = {\n              app = \"nginx\";\n            };\n          };\n          spec = {\n            containers = {\n              nginx = {\n                image = \"nginx:1.25.1\";\n                imagePullPolicy = \"IfNotPresent\";\n              };\n            };\n            securityContext = {\n              fsGroup = 1000;\n            };\n          };\n        };\n      };\n    };\n  };\n  services = {\n    nginx = {\n      spec = {\n        ports = {\n          http = {\n            port = 80;\n          };\n        };\n        selector = {\n          app = \"nginx\";\n        };\n      };\n    };\n  };\n}\n</code></pre> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicyautosyncenabled","title":"applications.&lt;name&gt;.syncPolicy.autoSync.enabled","text":"<p>Specifies if application should automatically sync.</p> <p>Type: boolean</p> <p>Default: <code>config.nixidy.defaults.syncPolicy.autoSync.enabled</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicyautosyncprune","title":"applications.&lt;name&gt;.syncPolicy.autoSync.prune","text":"<p>Specifies if resources should be pruned during auto-syncing.</p> <p>Type: boolean</p> <p>Default: <code>config.nixidy.defaults.syncPolicy.autoSync.prune</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicyautosyncselfheal","title":"applications.&lt;name&gt;.syncPolicy.autoSync.selfHeal","text":"<p>Specifies if partial app sync should be executed when resources are changed only in target Kubernetes cluster and no git change detected.</p> <p>Type: boolean</p> <p>Default: <code>config.nixidy.defaults.syncPolicy.autoSync.selfHeal</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicysyncoptionsapplyoutofsynconly","title":"applications.&lt;name&gt;.syncPolicy.syncOptions.applyOutOfSyncOnly","text":"<p>Currently when syncing using auto sync Argo CD applies every object in the application. For applications containing thousands of objects this takes quite a long time and puts undue pressure on the api server. Turning on selective sync option which will sync only out-of-sync resources.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicysyncoptionsfailonsharedresource","title":"applications.&lt;name&gt;.syncPolicy.syncOptions.failOnSharedResource","text":"<p>By default, Argo CD will apply all manifests found in the git path configured in the Application regardless if the resources defined in the yamls are already applied by another Application. If the <code>failOnSharedResource</code> sync option is set, Argo CD will fail the sync whenever it finds a resource in the current Application that is already applied in the cluster by another Application.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicysyncoptionsprunelast","title":"applications.&lt;name&gt;.syncPolicy.syncOptions.pruneLast","text":"<p>This feature is to allow the ability for resource pruning to happen as a final, implicit wave of a sync operation, after the other resources have been deployed and become healthy, and after all other waves completed successfully.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicysyncoptionsreplace","title":"applications.&lt;name&gt;.syncPolicy.syncOptions.replace","text":"<p>By default, Argo CD executes <code>kubectl apply</code> operation to apply the configuration stored in Git. In some cases <code>kubectl apply</code> is not suitable. For example, resource spec might be too big and won't fit into <code>kubectl.kubernetes.io/last-applied-configuration</code> annotation that is added by kubectl apply.</p> <p>If the <code>replace = true;</code> sync option is set the Argo CD will use <code>kubectl replace</code> or <code>kubectl create</code> command to apply changes.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicysyncoptionsserversideapply","title":"applications.&lt;name&gt;.syncPolicy.syncOptions.serverSideApply","text":"<p>By default, Argo CD executes <code>kubectl apply</code> operation to apply the configuration stored in Git. This is a client side operation that relies on <code>kubectl.kubernetes.io/last-applied-configuration</code> annotation to store the previous resource state.</p> <p>If <code>serverSideApply = true;</code> sync option is set, Argo CD will use <code>kubectl apply --server-side</code> command to apply changes.</p> <p>More info here.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnameyamls","title":"applications.&lt;name&gt;.yamls","text":"<p>List of Kubernetes manifests declared in YAML strings. They will be parsed and added to the application's <code>resources</code> where they can be overwritten and modified.</p> <p>Can be useful for reading existing YAML files (i.e. <code>[(builtins.readFile ./deployment.yaml)]</code>).</p> <p>Type: list of string</p> <p>Default: <code>[ ]</code></p> <p>Example:</p> <pre><code>[\n  ''\n    apiVersion: v1\n    kind: Namespace\n    metadata:\n      name: default\n  ''\n]\n</code></pre> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/yamls.nix&gt;</li> </ul>"},{"location":"options/#nixidyappofappsname","title":"nixidy.appOfApps.name","text":"<p>Name of the application for bootstrapping all other applications (app of apps pattern).</p> <p>Type: string</p> <p>Default: <code>\"apps\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidyappofappsnamespace","title":"nixidy.appOfApps.namespace","text":"<p>Destination namespace for generated Argo CD Applications in the app of apps applications.</p> <p>Type: string</p> <p>Default: <code>\"argocd\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidyappofappsproject","title":"nixidy.appOfApps.project","text":"<p>The project of the generated bootstrap app for appOfApps</p> <p>Type: string</p> <p>Default: <code>\"default\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidybuildrevision","title":"nixidy.build.revision","text":"<p>The revision being built. Will be written to <code>.revision</code> in the environment destination directory.</p> <p>Type: null or string</p> <p>Default: <code>null</code></p> <p>Example: <code>if (self ? rev) then self.rev else self.dirtyRev</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidycharts","title":"nixidy.charts","text":"<p>Attrset of derivations containing helm charts. This will be passed as <code>charts</code> to every module.</p> <p>Type: attribute set of anything</p> <p>Default: <code>{ }</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidychartsdir","title":"nixidy.chartsDir","text":"<p>Path to a directory containing sub-directory structure that can be used to build a charts attrset. This will be passed as <code>charts</code> to every module.</p> <p>Type: null or path</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidydefaultsdestinationserver","title":"nixidy.defaults.destination.server","text":"<p>The Kubernetes server that ArgoCD should deploy all applications to.</p> <p>This is the default value for all applications if not explicitly set for the application.</p> <p>Type: string</p> <p>Default: <code>\"https://kubernetes.default.svc\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidydefaultshelmtransformer","title":"nixidy.defaults.helm.transformer","text":"<p>Function that will be applied to the list of rendered manifests after the helm templating. This option applies to all helm releases in all applications unless explicitly specified there.</p> <p>Type: function that evaluates to a(n) list of attribute set of anything</p> <p>Default: <code>res: res</code></p> <p>Example: <code>map (lib.kube.removeLabels [\"helm.sh/chart\"])</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidydefaultskustomizetransformer","title":"nixidy.defaults.kustomize.transformer","text":"<p>Function that will be applied to the list of rendered manifests after kustomize rendering. This option applies to all kustomize applications in all nixidy applications unless explicitly specified there.</p> <p>Type: function that evaluates to a(n) list of attribute set of anything</p> <p>Default: <code>res: res</code></p> <p>Example: <code>map (lib.kube.removeLabels [\"app.kubernetes.io/version\"])</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidydefaultssyncpolicyautosyncenabled","title":"nixidy.defaults.syncPolicy.autoSync.enabled","text":"<p>Specifies if applications should automatically sync.</p> <p>This is the default value for all applications if not explicitly set for the application.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidydefaultssyncpolicyautosyncprune","title":"nixidy.defaults.syncPolicy.autoSync.prune","text":"<p>Specifies if resources should be pruned during auto-syncing.</p> <p>This is the default value for all applications if not explicitly set for the application.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidydefaultssyncpolicyautosyncselfheal","title":"nixidy.defaults.syncPolicy.autoSync.selfHeal","text":"<p>Specifies if partial app sync should be executed when resources are changed only in target Kubernetes cluster and no git change detected.</p> <p>This is the default value for all applications if not explicitly set for the application.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidyextrafiles","title":"nixidy.extraFiles","text":"<p>Extra files to write in the generated stage.</p> <p>Type: attribute set of (submodule)</p> <p>Default: <code>{ }</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidyextrafilesnamepath","title":"nixidy.extraFiles.&lt;name&gt;.path","text":"<p>Path of output file.</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidyextrafilesnametext","title":"nixidy.extraFiles.&lt;name&gt;.text","text":"<p>Text of the output file.</p> <p>Type: strings concatenated with \"\\n\"</p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidyresourceimports","title":"nixidy.resourceImports","text":"<p>List of modules to import for resource defintion options.</p> <p>Type: list of (package or path or function that evaluates to a(n) (attribute set))</p> <p>Default: <code>[ ]</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#nixidytargetbranch","title":"nixidy.target.branch","text":"<p>The destination branch of the generated applications.</p> <p>Type: string</p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidytargetrepository","title":"nixidy.target.repository","text":"<p>The repository URL to put in all generated applications.</p> <p>Type: string</p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidytargetrootpath","title":"nixidy.target.rootPath","text":"<p>The root path of all generated applications in the repository.</p> <p>Type: string</p> <p>Default: <code>\"./\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"user_guide/getting_started/","title":"Getting Started","text":""},{"location":"user_guide/getting_started/#initialize-repository","title":"Initialize Repository","text":"flakesflake-less <p>First a <code>flake.nix</code> needs to be created in the root of the repository.</p> flake.nix<pre><code>{\n  description = \"My ArgoCD configuration with nixidy.\";\n\n  inputs.nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n  inputs.flake-utils.url = \"github:numtide/flake-utils\";\n  inputs.nixidy.url = \"github:arnarg/nixidy\";\n\n  outputs = {\n    self,\n    nixpkgs,\n    flake-utils,\n    nixidy,\n  }: (flake-utils.lib.eachDefaultSystem (system: let\n    pkgs = import nixpkgs {\n      inherit system;\n    };\n  in {\n    # This declares the available nixidy envs.\n    nixidyEnvs = nixidy.lib.mkEnvs {\n      inherit pkgs;\n\n      envs = {\n        # Currently we only have the one dev env.\n        dev.modules = [./env/dev.nix];\n      };\n    };\n\n    # Handy to have nixidy cli available in the local\n    # flake too.\n    packages.nixidy = nixidy.packages.${system}.default;\n\n    # Useful development shell with nixidy in path.\n    # Run `nix develop` to enter.\n    devShells.default = pkgs.mkShell {\n      buildInputs = [nixidy.packages.${system}.default];\n    };\n  }));\n}\n</code></pre> <p>Info</p> <p>In the rest of the guide when running the <code>nixidy</code> cli (e.g. <code>nixidy build</code>) you can use <code>nix run .#nixidy -- build</code> or enter a nix shell with <code>nix develop</code> where <code>nixidy</code> will be available, with the <code>flake.nix</code> example above.</p> <p>The flake declares a single nixidy environment called <code>dev</code>. It includes a single nix module found at <code>./env/dev.nix</code>, so let's create that.</p> Dependency pinning <p>Instead of using nix channels, the recommended way to use nixidy without flakes is to use either npins or niv to lock dependency versions in your repository.</p> npinsniv <p>First initialize npins: <pre><code>npins init --bare\n</code></pre></p> <p>Then add nixidy: <pre><code>npins add github arnarg nixidy --branch main # or --at vx.x.x\n</code></pre></p> <p>First initialize niv: <pre><code>niv init --no-nixpkgs\n</code></pre></p> <p>Then add nixidy: <pre><code>niv add github arnarg/nixidy --branch main # or --rev vx.x.x\n</code></pre></p> <p>First a <code>default.nix</code> needs to be created in the root of the repository.</p> default.nix<pre><code>let\n  # With npins\n  sources = import ./npins;\n  # With niv\n  # sources = import ./nix/sources.nix;\n\n  # Import nixidy\n  nixidy = import sources.nixidy {};\nin\n  nixidy.lib.mkEnvs {\n    # This declares the available nixidy envs.\n    envs = {\n      # Currently we only have the one dev env.\n      dev.modules = [./env/dev.nix];\n    };\n  }\n</code></pre> <p>It's also a good idea to have <code>shell.nix</code> file in the root of the repository to have the necessary tools available.</p> shell.nix<pre><code>let\n  # With npins\n  sources = import ./npins;\n  # With niv\n  # sources = import ./nix/sources.nix;\n\n  # nixpkgs added with:\n  #   npins: `npins add --name nixpkgs channel nixos-unstable`\n  #   niv: `niv add github nixos/nixpkgs -b nixos-unstable`\n  nixpkgs = sources.nixpkgs;\n  pkgs = import nixpkgs {};\n\n  # Import nixidy\n  nixidy = import sources.nixidy {inherit nixpkgs;};\nin\n  pkgs.mkShellNoCC {\n    packages = with pkgs; [\n      # Add nixidy cli\n      nixidy.nixidy\n      # npins\n      npins\n      # or niv\n      niv\n    ];\n  }\n</code></pre> <p>Info</p> <p>In the rest of the guide when running the <code>nixidy</code> cli (e.g. <code>nixidy build</code>) you can run <code>nix-shell</code> to enter a nix shell where <code>nixidy</code> will be a avilable, with the <code>shell.nix</code> example above.</p> <p>Warning</p> <p>In the rest of the guide the <code>nixidy</code> commands will also use the flakes format (e.g. <code>nixidy build .#dev</code>), when using a flake-less setup the <code>.#</code> prefix should be removed (e.g. <code>nixidy build dev</code>).</p> <p>The <code>default.nix</code> file declares a single nixidy environment called <code>dev</code>. It includes a single nix module found at <code>./env/dev.nix</code>, so let's create that.</p> env/dev.nix<pre><code>{\n  # Set the target repository for the rendered manifests\n  # and applications.\n  # This should be replaced with yours, usually the same\n  # repository as the nixidy definitions.\n  nixidy.target.repository = \"https://github.com/arnarg/nixidy-demo.git\";\n\n  # Set the target branch the rendered manifests for _this_\n  # environment should be pushed to in the repository defined\n  # above.\n  nixidy.target.branch = \"main\";\n\n  # Set the target sub-directory to copy the generated\n  # manifests to when running `nixidy switch .#dev`.\n  nixidy.target.rootPath = \"./manifests/dev\";\n}\n</code></pre> <p>Now running <code>nixidy info .#dev</code> you can get the same info we just declared above. This verifies that things are set up correctly so far.</p> <pre><code>&gt;&gt; nixidy info .#dev\nRepository: https://github.com/arnarg/nixidy-demo.git\nBranch:     main\n</code></pre> <p>If we now attempt to build this new environment with <code>nixidy build .#dev</code> we can see that nothing is generated but an empty folder called <code>apps</code>.</p> <pre><code>&gt;&gt; tree result\nresult\n\u2514\u2500\u2500 apps/\n</code></pre> <p>This is because we have not declared any applications yet for this environment.</p>"},{"location":"user_guide/getting_started/#our-first-application","title":"Our first Application","text":"<p>Applications and their resources are defined under <code>applications.&lt;applicationName&gt;</code>.</p> env/dev.nix<pre><code>{\n  # Set the target repository for the rendered manifests\n  # and applications.\n  # This should be replaced with yours, usually the same\n  # repository as the nixidy definitions.\n  nixidy.target.repository = \"https://github.com/arnarg/nixidy-demo.git\";\n\n  # Set the target branch the rendered manifests for _this_\n  # environment should be pushed to in the repository defined\n  # above.\n  nixidy.target.branch = \"main\";\n\n  # Set the target sub-directory to copy the generated\n  # manifests to when running `nixidy switch .#dev`.\n  nixidy.target.rootPath = \"./manifests/dev\";\n\n  # Define an application called `demo`.\n  applications.demo = {\n    # All resources will be deployed into this namespace.\n    namespace = \"demo\";\n\n    # Automatically generate a namespace resource for the\n    # above set namespace\n    createNamespace = true;\n\n    resources = let\n      labels = {\n        \"app.kubernetes.io/name\" = \"nginx\";\n      };\n    in {\n      # Define a deployment for running an nginx server\n      deployments.nginx.spec = {\n        selector.matchLabels = labels;\n        template = {\n          metadata.labels = labels;\n          spec = {\n            securityContext.fsGroup = 1000;\n            containers.nginx = {\n              image = \"nginx:1.25.1\";\n              imagePullPolicy = \"IfNotPresent\";\n              volumeMounts = {\n                \"/etc/nginx\".name = \"config\";\n                \"/var/lib/html\".name = \"static\";\n              };\n            };\n            volumes = {\n              config.configMap.name = \"nginx-config\";\n              static.configMap.name = \"nginx-static\";\n            };\n          };\n        };\n      };\n\n      # Define config maps with config for nginx\n      configMaps = {\n        nginx-config.data.\"nginx.conf\" = ''\n          user nginx nginx;\n          error_log /dev/stdout info;\n          pid /dev/null;\n          events {}\n          http {\n            access_log /dev/stdout;\n            server {\n              listen 80;\n              index index.html;\n              location / {\n                root /var/lib/html;\n              }\n            }\n          }\n        '';\n\n        nginx-static.data.\"index.html\" = ''\n          &lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello from NGINX&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\n        '';\n      };\n\n      # Define service for nginx\n      services.nginx.spec = {\n        selector = labels;\n        ports.http.port = 80;\n      };\n    };\n  };\n}\n</code></pre> <p>Running <code>nixidy build .#dev</code> will produce the following files.</p> <pre><code>&gt;&gt; tree -l result/\n\u251c\u2500\u2500 apps\n\u2502   \u2514\u2500\u2500 Application-demo.yaml\n\u2514\u2500\u2500 demo\n    \u251c\u2500\u2500 ConfigMap-nginx-config.yaml\n    \u251c\u2500\u2500 ConfigMap-nginx-static.yaml\n    \u251c\u2500\u2500 Deployment-nginx.yaml\n    \u251c\u2500\u2500 Namespace-demo.yaml\n    \u2514\u2500\u2500 Service-nginx.yaml\n</code></pre> <p>And the contents of the Argo CD application automatically generated is the following:</p> apps/Application-demo.yaml<pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  # This is the name of the application (`applications.demo`).\n  name: demo\n  namespace: argocd\nspec:\n  destination:\n    # This is the destination namespace for the application\n    # specified with `applications.demo.namespace`.\n    namespace: demo\n    server: https://kubernetes.default.svc\n  project: default\n  source:\n    # This is the output path declared for the application with\n    # option `applications.&lt;applicationName&gt;.output.path`\n    # (defaults to the name) with `nixidy.target.rootPath`\n    # prefix.\n    path: ./manifests/dev/demo\n    # Repository specified in `nixidy.target.repository`.\n    repoURL: https://github.com/arnarg/nixidy-demo.git\n    # Branch specified in `nixidy.target.branch`.\n    targetRevision: main\n  syncPolicy:\n    automated:\n      prune: false\n      selfHeal: false\n</code></pre> <p>A directory with rendered resources is generated for each application declared with <code>applications.&lt;name&gt;</code> as well as an Argo CD application resource YAML file in <code>apps/</code>. What this provides is the option to bootstrap the whole rendered branch to a cluster by adding an application pointing to the <code>apps/</code> folder.</p> <p>See App of Apps Pattern.</p> <p>Running <code>nixidy switch .#dev</code> will create the <code>./manifests/dev</code> relative to the current working directory and sync the newly generated manifests into it.</p>"},{"location":"user_guide/getting_started/#bootstrapping-cluster","title":"Bootstrapping Cluster","text":"<p>After creating a git repository that is specified in <code>nixidy.target.repository</code> and pushing the generated manifests (e.g. by running <code>nixidy switch .#dev</code>) to the branch specified in <code>nixidy.target.branch</code>, your cluster can be bootstrapped.</p> <p>Make sure you have access to the Kubernetes API and Argo CD is installed and running on your cluster (refer to Argo CD's getting started guide for that).</p> <p>For quick bootstrapping you can run the command <code>nixidy bootstrap</code> to output an initial <code>Application</code> that will trigger a deployment of all other applications.</p> <pre><code>&gt;&gt; nixidy bootstrap .#dev\n---\napiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: apps\n  namespace: argocd\nspec:\n  destination:\n    namespace: argocd\n    server: https://kubernetes.default.svc\n  project: default\n  source:\n    path: ./manifests/dev/apps\n    repoURL: https://github.com/arnarg/nixidy-demo.git\n    targetRevision: main\n  syncPolicy:\n    automated:\n      prune: true\n      selfHeal: true\n</code></pre> <p>To actually deploy it, run <code>nixidy bootstrap .#dev | kubectl apply -f -</code> (this assumes that the argocd namespace already exists in the cluster).</p> <p>Alternatively, create a new application in the Argo CD Web GUI by specifying the <code>manifests/dev/apps</code> path.</p>"},{"location":"user_guide/getting_started/#next-steps","title":"Next Steps","text":"<p>Now that the cluster is running the applications specified in your nixidy config, you might want to build your applications on top of helm charts or have Github Actions generate the manifests.</p>"},{"location":"user_guide/git_strategies/","title":"Git Strategies","text":"<p>When it comes to planning out how to structure the git repositories for your environments some options are available.</p>"},{"location":"user_guide/git_strategies/#monorepo","title":"Monorepo","text":"<p>With this strategy everything happens on the <code>main</code>/<code>master</code> branch. With every change to nixidy modules should result in a rebuild and the resulting manifests will be put in a sub-directory on the same branch.</p> <p></p> <p>The biggest gain from using this strategy is fast iteration locally as any change made to a nixidy module can be previewed by running <code>nixidy switch .#&lt;env&gt;</code> and then followed by <code>git diff</code> to see what has actually changed in the generated manifests.</p> <p>This strategy does require more complicated access control mechanism such as CODEOWNER file to make sure not everyone can change the generated manifests.</p>"},{"location":"user_guide/git_strategies/#setup","title":"Setup","text":"<p>In a module that's common to all the environment the target repository and branch needs to be set.</p> modules/default.nix<pre><code>{\n  # Set the target repository for the rendered manifests\n  # and applications.\n  # This should be replaced with yours.\n  nixidy.target.repository = \"https://github.com/arnarg/nixidy-demo.git\";\n\n  # Set the target branch the rendered manifests for every\n  # environment should be pushed to in the repository defined\n  # above.\n  nixidy.target.branch = \"main\";\n}\n</code></pre> <p>And in a module that's specific to each environment the target root path needs to be set.</p> env/dev.nix<pre><code>{\n  # Set the target sub-directory to copy the generated\n  # manifests to when running `nixidy switch .#dev`.\n  nixidy.target.rootPath = \"./manifests/dev\";\n}\n</code></pre> <p>Tip</p> <p>When using <code>mkEnvs</code> from nixidy, each environment's <code>rootPath</code> is automatically set to <code>./manifests/${dev}</code>.</p>"},{"location":"user_guide/git_strategies/#environment-branches","title":"Environment branches","text":"<p>With this strategy generated manifests are committed and pushed to separate environment specific branches. As these branches will not share any git history with the <code>main</code> branch or other environment branches (this is not git flow) they need to be created as orphan branches.</p> <p></p> <p>The biggest gain from this strategy is that it's simpler to implement access control compared to the monorepo, the branches can be setup with basic branch protection rules.</p>"},{"location":"user_guide/git_strategies/#setup_1","title":"Setup","text":"<p>In a module that's common to all the environments the target repository needs to be set. Unless you want the root path to differ between the environment's that can also be set here.</p> modules/default.nix<pre><code>{\n  # Set the target repository for the rendered manifests\n  # and applications.\n  # This should be replaced with yours.\n  nixidy.target.repository = \"https://github.com/arnarg/nixidy-demo.git\";\n\n  # The generated manifests should be at the root of\n  # each environment branch.\n  nixidy.target.rootPath = \"./\";\n}\n</code></pre> <p>And in a module that's specific to each environment the target branch needs to be set.</p> env/dev.nix<pre><code>{\n  # Set the target branch the rendered manifests for _this_\n  # environment should be pushed to in the repository defined\n  # above.\n  nixidy.target.branch = \"env/dev\";\n}\n</code></pre> <p>Info</p> <p>The environment branches need to be created manually and they need to be created as orphan branches.</p> <pre><code>git checkout --orphan env/dev\necho \"# env/dev\" &gt; README.md\ngit add README.md\ngit commit -m \"Initial commmit\"\ngit push -u origin env/dev\n</code></pre>"},{"location":"user_guide/git_strategies/#environment-repositories","title":"Environment repositories","text":"<p>With this strategy generated manifests are committed and pushed to separate repositories entirely.</p> <p></p> <p>The biggest gain from this strategy is that it's possible to go even further with access control from the environment branches.</p>"},{"location":"user_guide/git_strategies/#setup_2","title":"Setup","text":"<p>In a module that's common to all the branches only the root path should be set, unless that should differ between the environments.</p> modules/default.nix<pre><code>{\n  # The generated manifests should be at the root of\n  # each environment repository.\n  nixidy.target.rootPath = \"./\";\n}\n</code></pre> <p>And in a module that's specific to each environment the target repository and target branch needs to be set.</p> env/dev.nix<pre><code>{\n  # Set the target repository for the rendered manifests\n  # and applications.\n  # This should be replaced with yours.\n  nixidy.target.repository = \"https://github.com/arnarg/nixidy-demo-dev.git\";\n\n  # Set the target branch the rendered manifests for _this_\n  # environment should be pushed to in the repository defined\n  # above.\n  nixidy.target.branch = \"main\";\n}\n</code></pre>"},{"location":"user_guide/github_actions/","title":"GitHub Actions","text":"<p>Nixidy offers two GitHub Actions to build and switch to an environment.</p>"},{"location":"user_guide/github_actions/#arnargnixidyactionsbuild","title":"arnarg/nixidy/actions/build","text":"<p>This action will run <code>nixidy build</code> on a specified environment. It will not produce a <code>result</code> symlink and instead will have the output path in it's output <code>out-path</code>.</p>"},{"location":"user_guide/github_actions/#example","title":"Example","text":"<pre><code>name: Generate Kubernetes manifests\n\non:\n  push:\n    branches:\n      - main\n    paths-ignore:\n      - manifests/**\n\njobs:\n  generate:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v4\n\n    - uses: cachix/install-nix-action@v20\n      with:\n        # The `arnarg/nixidy/actions/build` action depends\n        # on nix flakes to run the actual nixidy cli.\n        # Therefore the following setting is required even\n        # when using nixidy with non-flakes.\n        extra_nix_config: |\n          extra-experimental-features = nix-command flakes\n\n    - uses: DeterminateSystems/magic-nix-cache-action@v7\n\n    - uses: arnarg/nixidy/actions/build@main\n      id: build\n      with:\n        environment: .#dev\n        # Without flakes:\n        # environment: dev\n\n    - shell: bash\n      run: |\n        rsync --recursive --delete '${{steps.build.outputs.out-path}}/' manifests\n\n    - uses: EndBug/add-and-commit@v9\n      id: commit\n      with:\n        default_author: github_actions\n        message: \"chore: promote to dev ${{github.sha}}\"\n        fetch: false\n        new_branch: promote/env/dev\n        push: --set-upstream origin promote/env/dev --force\n\n    - uses: thomaseizinger/create-pull-request@1.4.0\n      if: ${{ steps.commit.outputs.pushed == 'true' }}\n      with:\n        github_token: ${{github.token}}\n        head: promote/env/dev\n        base: main\n        title: \"chore: promote to dev ${{github.sha}}\"\n</code></pre>"},{"location":"user_guide/github_actions/#arnargnixidyactionsswitch","title":"arnarg/nixidy/actions/switch","text":"<p>This action will run <code>nixidy switch</code> on a specified environment.</p>"},{"location":"user_guide/github_actions/#example_1","title":"Example","text":"<pre><code>name: Generate Kubernetes manifests\n\non:\n  push:\n    branches:\n      - main\n    paths-ignore:\n      - manifests/**\n\njobs:\n  generate:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v4\n\n    - uses: cachix/install-nix-action@v20\n      with:\n        # The `arnarg/nixidy/actions/switch` action depends\n        # on nix flakes to run the actual nixidy cli.\n        # Therefore the following setting is required even\n        # when using nixidy with non-flakes.\n        extra_nix_config: |\n          extra-experimental-features = nix-command flakes\n\n    - uses: DeterminateSystems/magic-nix-cache-action@v7\n\n    - uses: arnarg/nixidy/actions/switch@main\n      with:\n        environment: .#dev\n        # Without flakes:\n        # environment: dev\n\n    - uses: EndBug/add-and-commit@v9\n      id: commit\n      with:\n        default_author: github_actions\n        message: \"chore: promote to dev ${{github.sha}}\"\n        fetch: false\n        new_branch: promote/env/dev\n        push: --set-upstream origin promote/env/dev --force\n\n    - uses: thomaseizinger/create-pull-request@1.4.0\n      if: ${{ steps.commit.outputs.pushed == 'true' }}\n      with:\n        github_token: ${{github.token}}\n        head: promote/env/dev\n        base: main\n        title: \"chore: promote to dev ${{github.sha}}\"\n</code></pre>"},{"location":"user_guide/helm_charts/","title":"Using Helm Charts","text":"<p>For better or for worse majority of software that's deployable to Kubernetes is packaged using Helm by developers or its community. It would be a waste not to use them and having to define all of its manifest yourself in nixidy.</p>"},{"location":"user_guide/helm_charts/#adding-a-helm-release-as-part-of-an-application","title":"Adding a Helm release as part of an application","text":"<p>Nixidy supports rendering Helm charts as part of applications. This can be done by specifying <code>applications.&lt;applicationName&gt;.helm.releases.&lt;releaseName&gt;</code>.</p>"},{"location":"user_guide/helm_charts/#example","title":"Example","text":"<pre><code>{lib, ...}: {\n  applications.traefik = {\n    namespace = \"traefik\";\n    createNamespace = true;\n\n    helm.releases.traefik = {\n      # Use `lib.helm.downloadHelmChart` to fetch\n      # the Helm Chart to use.\n      chart = lib.helm.downloadHelmChart {\n        repo = \"https://traefik.github.io/charts/\";\n        chart = \"traefik\";\n        version = \"25.0.0\";\n        chartHash = \"sha256-ua8KnUB6MxY7APqrrzaKKSOLwSjDYkk9tfVkb1bqkVM=\";\n      };\n\n      # Example values to pass to the Helm Chart.\n      values = {\n        ingressClass.enabled = true;\n      };\n    };\n  };\n}\n</code></pre>"},{"location":"user_guide/helm_charts/#patching-manifests-rendered-by-helm","title":"Patching manifests rendered by Helm","text":"<p>In some cases the Helm Chart doesn't support changing certain aspects of the final manifests. These can be modified to nixidy by overriding certain fields.</p>"},{"location":"user_guide/helm_charts/#example_1","title":"Example","text":"<pre><code>{lib, ...}: {\n  applications.traefik = {\n    namespace = \"traefik\";\n    createNamespace = true;\n\n    helm.releases.traefik = {\n      # Use `lib.helm.downloadHelmChart` to fetch\n      # the Helm Chart to use.\n      chart = lib.helm.downloadHelmChart {\n        repo = \"https://traefik.github.io/charts/\";\n        chart = \"traefik\";\n        version = \"25.0.0\";\n        chartHash = \"sha256-ua8KnUB6MxY7APqrrzaKKSOLwSjDYkk9tfVkb1bqkVM=\";\n      };\n\n      # Example values to pass to the Helm Chart.\n      values = {\n        ingressClass.enabled = true;\n      };\n    };\n\n    resources = {\n      # Add a label to the traefik pod and change\n      # the image.\n      deployments.traefik.spec.template = {\n        metadata.labels.my-custom-label = \"my-custom-values\";\n        spec.containers.traefik.image = lib.mkForce \"my-registry.io/patched-traefik:v3.0.0\";\n      };\n    };\n  };\n}\n</code></pre>"},{"location":"user_guide/transformers/","title":"Transformers","text":"<p>Nixidy supports adding a transformers to Helm releases and Kustomize applications. A transformer is only a function that takes in a list of Kubernetes manifests in attribute sets and returns the same (<code>[AttrSet] -&gt; [AttrSet]</code>). It is called after the manifests have been rendered and parsed into nix but before they're transformed into the nixidy form (<code>&lt;group&gt;.&lt;version&gt;.&lt;kind&gt;.&lt;name&gt;</code>) and can be used to modify the resources.</p> <p>Transformers can be set globally in <code>nixidy.defaults.helm.transformer</code> for Helm releases and <code>nixidy.defaults.kustomize.transformer</code> for kustomize applications.</p>"},{"location":"user_guide/transformers/#remove-version-specific-labels","title":"Remove Version Specific Labels","text":"<p>It's very common that helm charts will add the labels <code>helm.sh/chart</code> and <code>app.kubernetes.io/version</code> to all resources it renders. This can produce very big diffs when they're updated and nixidy renders them and commits the manifests to a git branch. The changes in these labels are not very relevant and will mostly just be noise to distract from the actual relevant changes of the rendered output.</p> <p>A transformer can be used to filter out these labels.</p> <pre><code>{\n  applications.argocd.helm.releases.argocd = {\n    # ...\n\n    # Remove the following labels from all manifests\n    transformer = map (lib.kube.removeLabels [\n      \"app.kubernetes.io/version\"\n      \"helm.sh/chart\"\n    ]);\n  }\n}\n</code></pre> <p>Here we use map to call <code>lib.kube.removeLabels</code> on each manifest in the list to remove the specified labels. The example uses function currying, this is equivalent to <code>manifests: map (m: lib.kube.removeLabels [\"...\"] m) manifests</code>.</p>"},{"location":"user_guide/typed_resources/","title":"Typed Resource Options","text":"<p>Kubenix has done a great work with generating nix options definitions from official JSON schemas and nixidy builds on top of this.</p> <p>All core Kubernetes resources are imported by default in nixidy along with Argo CD's <code>Application</code> and <code>AppProject</code>. Every resource can be defined under <code>applications.&lt;applicationName&gt;.resources.&lt;group&gt;.&lt;version&gt;.&lt;kind&gt;</code> but is also offered as an alias <code>applications.&lt;applicationName&gt;.resources.&lt;attrName&gt;</code> where <code>&lt;attrName&gt;</code> is the plural form of the kind in camelCase.</p> <p>For example:</p> <ul> <li><code>resources.core.v1.Service</code> -&gt; <code>resources.services</code></li> <li><code>resources.\"networking.k8s.io\".v1.NetworkPolicy</code> -&gt; <code>resources.networkPolicies</code></li> </ul> <p>The lack of availability of typed resource options only hinders the ability to define the resources in nix. Any manifests that are rendered from a Helm Chart or defined in <code>applications.&lt;applicationName&gt;.yamls</code> and do not have defined resource options for that group, version and kind will go straight to the output for the application and can not be patched by nixidy.</p>"},{"location":"user_guide/typed_resources/#generating-your-own-resource-options-from-crds","title":"Generating your own resource options from CRDs","text":"<p>Thankfully a code generator for generating resource options from CRDs is provided by nixidy (this is based heavily on kubenix's code generator).</p> flakesflake-less <p>As an example, to generate resource options for Cilium's <code>CiliumNetworkPolicy</code> and <code>CiliumClusterwideNetworkPolicy</code> the following can be defined in <code>flake.nix</code>.</p> flake.nix<pre><code>{\n  description = \"My ArgoCD configuration with nixidy.\";\n\n  inputs.nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n  inputs.flake-utils.url = \"github:numtide/flake-utils\";\n\n  inputs.nixidy = {\n    url = \"github:arnarg/nixidy\";\n    inputs.nixpkgs.follows = \"nixpkgs\";\n  };\n\n  outputs = {\n    self,\n    nixpkgs,\n    flake-utils,\n    nixidy,\n  }: (flake-utils.lib.eachDefaultSystem (system: let\n    pkgs = import nixpkgs {\n      inherit system;\n    };\n  in {\n    packages = {\n      generators.cilium = nixidy.packages.${system}.generators.fromCRD {\n        name = \"cilium\";\n        src = pkgs.fetchFromGitHub {\n          owner = \"cilium\";\n          repo = \"cilium\";\n          rev = \"v1.15.6\";\n          hash = \"sha256-oC6pjtiS8HvqzzRQsE+2bm6JP7Y3cbupXxCKSvP6/kU=\";\n        };\n        crds = [\n          \"pkg/k8s/apis/cilium.io/client/crds/v2/ciliumnetworkpolicies.yaml\"\n          \"pkg/k8s/apis/cilium.io/client/crds/v2/ciliumclusterwidenetworkpolicies.yaml\"\n        ];\n      };\n    };\n  }));\n}\n</code></pre> <p>Then running <code>nix build .#generators.cilium</code> will produce a nix file that can be copied into place in your repository. After that the generated file has to be added to <code>nixidy.resourceImports</code> in your nixidy modules.</p> <p>As an example, to generate resource options for Cilium's <code>CiliumNetworkPolicy</code> and <code>CiliumClusterwideNetworkPolicy</code> the following can be defined in <code>generate.nix</code>.</p> generate.nix<pre><code>let\n  # With npins\n  sources = import ./npins;\n  # With niv\n  # sources = import ./nix/sources.nix;\n\n  # nixpkgs added with:\n  #   npins: `npins add --name nixpkgs channel nixos-unstable`\n  #   niv: `niv add github nixos/nixpkgs -b nixos-unstable`\n  nixpkgs = sources.nixpkgs;\n  pkgs = import nixpkgs {};\n\n  # Import nixidy\n  nixidy = import sources.nixidy {inherit nixpkgs;};\nin\n  {\n    cilium = nixidy.generators.fromCRD {\n      name = \"cilium\";\n      src = pkgs.fetchFromGitHub {\n        owner = \"cilium\";\n        repo = \"cilium\";\n        rev = \"v1.15.6\";\n        hash = \"sha256-oC6pjtiS8HvqzzRQsE+2bm6JP7Y3cbupXxCKSvP6/kU=\";\n      };\n      crds = [\n        \"pkg/k8s/apis/cilium.io/client/crds/v2/ciliumnetworkpolicies.yaml\"\n        \"pkg/k8s/apis/cilium.io/client/crds/v2/ciliumclusterwidenetworkpolicies.yaml\"\n      ];\n    };\n  }\n</code></pre> <p>Then running <code>nix-build generate.nix -A cilium</code> will produce a nix file that can be copied into place in your repository. After that the generated file has to be added to <code>nixidy.resourceImports</code> in your nixidy modules.</p> env/dev.nix<pre><code>{\n  nixidy.resourceImports = [\n    ./generated/cilium.nix\n  ];\n}\n</code></pre>"},{"location":"user_guide/using_nixhelm/","title":"Using nixhelm","text":"<p>nixhelm is a collection of Helm Charts that can be used with nix-kube-generators and as a result also nixidy. The charts are automatically updated to the most recent version by CI regularly.</p> flakesflake-less <p>To use with nixidy, pass the nixhelm derivation attribute set to nixidy's <code>mkEnv</code> builder like so.</p> flake.nix<pre><code>{\n  description = \"My ArgoCD configuration with nixidy.\";\n\n  inputs.nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n  inputs.flake-utils.url = \"github:numtide/flake-utils\";\n\n  inputs.nixidy = {\n    url = \"github:arnarg/nixidy\";\n    inputs.nixpkgs.follows = \"nixpkgs\";\n  };\n\n  inputs.nixhelm = {\n    url = \"github:farcaller/nixhelm\";\n    inputs.nixpkgs.follows = \"nixpkgs\";\n  };\n\n  outputs = {\n    self,\n    nixpkgs,\n    flake-utils,\n    nixidy,\n    nixhelm,\n  }: (flake-utils.lib.eachDefaultSystem (system: let\n    pkgs = import nixpkgs {\n      inherit system;\n    };\n  in {\n    nixidyEnvs.dev = nixidy.lib.mkEnv {\n      inherit pkgs;\n\n      # Pass nixhelm to all nixidy modules.\n      charts = nixhelm.chartsDerivations.${system};\n\n      modules = [./env/dev.nix];\n    };\n  }));\n}\n</code></pre> <p>To use with nixidy, pass the nixhelm <code>charts/</code> directory to nixidy in a module like so:</p> default.nix<pre><code>let\n  # With npins\n  sources = import ./npins;\n  # With niv\n  # sources = import ./nix/sources.nix;\n\n  # nixhelm added with:\n  #   npins: `npins add github farcaller nixhelm --branch master`\n  #   niv: `niv add github farcaller/nixhelm --branch master`\n  nixhelm = sources.nixhelm;\n\n  # Import nixidy\n  nixidy = import sources.nixidy {};\nin\n  nixidy.lib.mkEnvs {\n    # These modules get passed to every env.\n    modules = [\n      ({lib, ...}: {\n        # nixhelm is a flake so we can't just import it\n        # like we do in flakes (as an input).\n        # Thankfully the directory structure in nixhelm\n        # is compatible with the one expected by\n        # `lib.helm.mkChartAttrs`.\n        nixidy.charts = lib.helm.mkChartAttrs \"${nixhelm}/charts\";\n      })\n    ];\n\n    # This declares the available nixidy envs.\n    envs = {\n      # Currently we only have the one dev env.\n      dev.modules = [./env/dev.nix];\n    };\n  }\n</code></pre> <p>And then the argument <code>charts</code> will be passed to every module in nixidy.</p> ./env/dev.nix<pre><code>{\n  charts,\n  ...\n}: {\n  applications.traefik = {\n    namespace = \"traefik\";\n    createNamespace = true;\n\n    helm.releases.traefik = {\n      # Use the traefik helm chart from nixhelm.\n      chart = charts.traefik.traefik;\n\n      # Example values to pass to the Helm Chart.\n      values = {\n        ingressClass.enabled = true;\n      };\n    };\n  };\n}\n</code></pre>"},{"location":"user_guide/using_nixhelm/#provide-your-own-charts-not-available-in-nixhelm","title":"Provide your own charts not available in nixhelm","text":"<p>Not all charts are available in nixhelm and in such cases you can contribute an initial version to them or setup a specific folder structure locally to merge with the <code>charts</code> argument passed to modules.</p> <p>With the nixidy option <code>nixidy.chartsDir</code> that folder will be walked recursively and look for <code>default.nix</code> files that will build up the charts attribute set.</p> ./charts/kubernetes-csi/csi-driver-nfs/default.nix<pre><code>{\n  repo = \"https://raw.githubusercontent.com/kubernetes-csi/csi-driver-nfs/master/charts\";\n  chart = \"csi-driver-nfs\";\n  version = \"4.7.0\";\n  chartHash = \"sha256-EU2qaZglUU3vxa41l1p/2yBscksIhYMr8kSgH8t0vL8=\";\n}\n</code></pre> <p>And then in your nixidy modules you pass that <code>./charts</code> folder to <code>nixidy.chartsDir</code>.</p> ./env/dev.nix<pre><code>{charts, ...}: {\n  # Point nixidy to a directory with charts to add to\n  # the charts attribute set.\n  nixidy.chartsDir = ../charts;\n\n  # Use the nfs chart in an application.\n  applications.csi-driver-nfs = {\n    namespace = \"kube-system\";\n\n    helm.releases.csi-driver-nfs = {\n      chart = charts.kubernetes-csi.csi-driver-nfs;\n\n      # Pass some values overrides to the chart.\n      values = {};\n    };\n  };\n}\n</code></pre>"}]}