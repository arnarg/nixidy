{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"nixidy","text":"<p>Kubernetes GitOps with nix and Argo CD.</p> <p>Kind of sounds like Nix CD.</p>"},{"location":"#what-is-it","title":"What is it?","text":"<p>Manage an entire Kubernetes cluster like it's NixOS, then have CI generate plain YAML manifests for ArgoCD.</p> <pre><code>{...}: {\n  applications.demo = {\n    namespace = \"demo\";\n\n    # Automatically generate a namespace resource with the\n    # above set namespace\n    createNamespace = true;\n\n    resources = let\n      labels = {\n        \"app.kubernetes.io/name\" = \"nginx\";\n      };\n    in {\n      # Define a deployment for running an nginx server\n      deployments.nginx.spec = {\n        selector.matchLabels = labels;\n        template = {\n          metadata.labels = labels;\n          spec = {\n            securityContext.fsGroup = 1000;\n            containers.nginx = {\n              image = \"nginx:1.25.1\";\n              imagePullPolicy = \"IfNotPresent\";\n              volumeMounts = {\n                \"/etc/nginx\".name = \"config\";\n                \"/var/lib/html\".name = \"static\";\n              };\n            };\n            volumes = {\n              config.configMap.name = \"nginx-config\";\n              static.configMap.name = \"nginx-static\";\n            };\n          };\n        };\n      };\n\n      # Define config maps with config for nginx\n      configMaps = {\n        nginx-config.data.\"nginx.conf\" = ''\n          user nginx nginx;\n          error_log /dev/stdout info;\n          pid /dev/null;\n          events {}\n          http {\n            access_log /dev/stdout;\n            server {\n              listen 80;\n              index index.html;\n              location / {\n                root /var/lib/html;\n              }\n            }\n          }\n        '';\n\n        nginx-static.data.\"index.html\" = ''\n          &lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello from NGINX&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\n        '';\n      };\n\n      # Define service for nginx\n      services.nginx.spec = {\n        selector = labels;\n        ports.http.port = 80;\n      };\n    };\n  };\n}\n</code></pre> <p>Then build with nixidy using <code>nixidy build .#prod</code></p> <pre><code>tree -l result/\n\u251c\u2500\u2500 apps\n\u2502   \u2514\u2500\u2500 Application-demo.yaml\n\u2514\u2500\u2500 demo\n    \u251c\u2500\u2500 ConfigMap-nginx-config.yaml\n    \u251c\u2500\u2500 ConfigMap-nginx-static.yaml\n    \u251c\u2500\u2500 Deployment-nginx.yaml\n    \u251c\u2500\u2500 Namespace-demo.yaml\n    \u2514\u2500\u2500 Service-nginx.yaml\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Take a look at the getting started guide.</p>"},{"location":"#examples","title":"Examples","text":"<ul> <li>arnarg's cluster config</li> </ul>"},{"location":"#why","title":"Why?","text":"<p>It's desirable to manage Kubernetes clusters in a declarative way using a git repository as a source of truth for manifests that should be deployed into the cluster. One popular solution that is often used to achieve this goal is Argo CD.</p> <p>Argo CD has a concept of applications. Each application has an entrypoint somewhere in your git repository that is either a Helm chart, kustomize application, jsonnet files or just a directory of YAML files. All the resources that are output when templating the helm chart, kustomizing the kustomize application or are defined in the YAML files in the directory, make up the application and are (usually) deployed into a single namespace.</p> <p>For those reasons these git repositories often need quite elaborate designs once many applications should be deployed, requiring use of application sets (generator for applications) or custom Helm charts just to render all the different applications of the repository.</p> <p>On top of that it can be quite obscure what exactly will be deployed by just looking at helm charts (along with all the values override, usually set for each environment) or the kustomize overlays (which often are many depending on number of environments/stages) without going in and just running <code>helm template</code> or <code>kubectl kustomize</code>.</p> <p>Having dealt with these design decisions and pains that come with the different approaches I'm starting to use The Rendered Manifests Pattern. While it's explained in way more detail in the linked blog post, basically it involves using your CI system to pre-render the helm charts or the kustomize overlays and commit all the rendered manifests to an environment branch (or go through a pull request review where you can review the exact changes to your environment). That way you can just point Argo CD to your different directories full of rendered YAML manifests without having to do any helm templating or kustomize rendering.</p>"},{"location":"#nixos-module-system","title":"NixOS' Module System","text":"<p>I have been a user and a fan of NixOS for many years and how its module system works to recursively merge all configuration options that are set in many different modules.</p> <p>I have not been a fan of helm's string templating of a whitespace-sensitive configuration language or kustomize's repitition (defining a <code>kustomization.yaml</code> file for each layer statically listing files to include, some are json patches some are not...).</p> <p>Therefore I made nixidy as an experiment to see if I can make something better (at least for myself). As all Argo CD applications are defined in a single configuration it can reference configuration options across applications and automatically generate an App of Apps bootstrapping all of them.</p>"},{"location":"#special-thanks","title":"Special Thanks","text":"<p>farcaller/nix-kube-generators is used internally to pull and render Helm charts and some functions are re-exposed in the lib passed to modules in nixidy.</p> <p>hall/kubenix project has code generation of nix module options for every standard kubernetes resource. Instead of doing this work in nixidy I simply import their generated resource options. The resource option generation scripts in nixidy are also a slight modification of kubenix's. Without their work this wouldn't be possible in nixidy.</p>"},{"location":"library/","title":"Libary Functions","text":"<p>The argument <code>lib</code> is passed to each module in nixidy. This is the standard nixpkgs library extended with the following functions.</p>"},{"location":"library/#libhelmdownloadhelmchart","title":"lib.helm.downloadHelmChart","text":"<p>Type: <code>downloadHelmChart :: AttrSet -&gt; Derivation</code></p> <p>Downloads a helm chart from a helm registry.</p> <p>This is re-exported directly from farcaller/nix-kube-generators.</p>"},{"location":"library/#libhelmbuildhelmchart","title":"lib.helm.buildHelmChart","text":"<p>Type: <code>buildHelmChart :: AttrSet -&gt; Derivation</code></p> <p>Templates a helm chart with provided values and creates a derivation with the output.</p> <p>This is re-exported directly from farcaller/nix-kube-generators.</p>"},{"location":"library/#libhelmgetchartvalues","title":"lib.helm.getChartValues","text":"<p>Type: <code>getChartValues :: Derivation -&gt; AttrSet</code></p> <p>Parse the default values file shipped with the helm chart.</p> <code>chart</code> <p>Derivation containing helm chart. Usually output of lib.helm.downloadHelmChart.</p> <p>Example:</p> <pre><code>getChartValues (lib.helm.downloadHelmChart {\n    repo = \"https://argoproj.github.io/argo-helm/\";\n    chart = \"argo-cd\";\n    version = \"5.51.4\";\n    chartHash = \"sha256-LOEJ5mYaHEA0RztDkgM9DGTA0P5eNd0SzSlwJIgpbWY=\";\n})\n=&gt; {\n  server.replicas = 1;\n  controller.replicas = 1;\n  # ...\n}\n</code></pre>"},{"location":"library/#libkustomizebuildkustomization","title":"lib.kustomize.buildKustomization","text":"<p>Type: <code>buildKustomization :: AttrSet -&gt; Derivation</code></p> <p>Builds a kustomization and creates a derivation with the output.</p> structured function argument <p><code>name</code></p> <p>Name is only used for derivation name.</p> <code>src</code> <p>Derivation containing the kustomization entrypoint and all relative bases that it might reference.</p> <code>path</code> <p>Relative path from the base of <code>src</code> to the kustomization folder to render.</p> <code>namespace</code> <p>Override namespace in kustomization.yaml.</p> <p>Example:</p> <pre><code>buildKustomization {\n  name = \"argocd\";\n  src = pkgs.fetchFromGitHub {\n    owner = \"argoproj\";\n    repo = \"argo-cd\";\n    rev = \"v2.9.3\";\n    hash = \"sha256-GaY4Cw/LlSwy35umbB4epXt6ev8ya19UjHRwhDwilqU=\";\n  };\n  path = \"manifests/cluster-install\";\n  namespace = \"argocd\";\n}\n=&gt; /nix/store/7i52...7pww-kustomize-argocd\n</code></pre>"},{"location":"library/#libkubefromyaml","title":"lib.kube.fromYAML","text":"<p>Type: <code>fromYAML :: String -&gt; [AttrSet]</code></p> <p>Parses a YAML document string into a list of attribute sets.</p> <p>This is re-exported directly from farcaller/nix-kube-generators.</p> <code>yaml</code> <p>String with a yaml document.</p> <p>Example:</p> <pre><code>fromYAML ''\n  apiVersion: v1\n  kind: Namespace\n  metadata:\n    name: default\n  ---\n  apiVersion: v1\n  kind: Namespace\n  metadata:\n    name: kube-system\n''\n=&gt; [\n  {\n    apiVersion = \"v1\";\n    kind = \"Namespace\";\n    metadata.name = \"default\";\n  }\n  {\n    apiVersion = \"v1\";\n    kind = \"Namespace\";\n    metadata.name = \"kube-system\";\n  }\n]\n</code></pre>"},{"location":"library/#libkubefromoctal","title":"lib.kube.fromOctal","text":"<p>Type: <code>fromOctal :: String -&gt; Integer</code></p> <p>Parse an octal representation of a number and convert into a decimal number. This can be useful when having to represent permission bits in a resource as nix has no support for representing octal numbers.</p> <code>octal</code> <p>String representation of the octal number to parse.</p> <p>Example:</p> <pre><code>fromOctal \"0555\"\n=&gt; 365\n</code></pre>"},{"location":"library/#libkuberemovelabels","title":"lib.kube.removeLabels","text":"<p>Type: <code>removeLabels :: [String] -&gt; AttrSet -&gt; AttrSet</code></p> <p>Removes labels from a Kubernetes manifest.</p> <code>labels</code> <p>List of labels that should be removed</p> <code>manifest</code> <p>Kubernetes manifest</p> <p>Example:</p> <pre><code>removeLabels [\"helm.sh/chart\"] {\n  apiVersion = \"v1\";\n  kind = \"ConfigMap\";\n  metadata = {\n    name = \"argocd-cm\";\n    labels = {\n      \"app.kubernetes.io/name\" = \"argocd-cm\";\n      \"helm.sh/chart\" = \"argo-cd-5.51.6\";\n    };\n  };\n}\n=&gt; {\n  apiVersion = \"v1\";\n  kind = \"ConfigMap\";\n  metadata = {\n    name = \"argocd-cm\";\n    labels = {\n      \"app.kubernetes.io/name\" = \"argocd-cm\";\n    };\n  };\n}\n</code></pre>"},{"location":"options/","title":"Configuration Options","text":""},{"location":"options/#applications","title":"applications","text":"<p>An application is a single Argo CD application that will be rendered by nixidy.</p> <p>The resources will be rendered into it's own directory and an Argo CD application created for it.</p> <p>Type: attribute set of (submodule)</p> <p>Default: <code>{ }</code></p> <p>Example:</p> <pre><code>{\n  nginx = {\n    namespace = \"nginx\";\n    resources = {\n      deployments = {\n        nginx = {\n          spec = {\n            replicas = 3;\n            selector = {\n              matchLabels = {\n                app = \"nginx\";\n              };\n            };\n            template = {\n              metadata = {\n                labels = {\n                  app = \"nginx\";\n                };\n              };\n              spec = {\n                containers = {\n                  nginx = {\n                    image = \"nginx:1.25.1\";\n                    imagePullPolicy = \"IfNotPresent\";\n                  };\n                };\n                securityContext = {\n                  fsGroup = 1000;\n                };\n              };\n            };\n          };\n        };\n      };\n      services = {\n        nginx = {\n          spec = {\n            ports = {\n              http = {\n                port = 80;\n              };\n            };\n            selector = {\n              app = \"nginx\";\n            };\n          };\n        };\n      };\n    };\n  };\n}\n</code></pre> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnameannotations","title":"applications.&lt;name&gt;.annotations","text":"<p>Annotations to add to the rendered ArgoCD application.</p> <p>Type: attribute set of string</p> <p>Default: <code>{ }</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamecompareoptionsignoreextraneous","title":"applications.&lt;name&gt;.compareOptions.ignoreExtraneous","text":"<p>Sets IgnoreExtraneous compare option for the application. Only setting it as <code>true</code> has any effect.</p> <p>Type: null or boolean</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamecompareoptionsincludemutationwebhook","title":"applications.&lt;name&gt;.compareOptions.includeMutationWebhook","text":"<p>Sets IncludeMutationWebhook compare option for the application. Only setting it as <code>true</code> has any effect.</p> <p>Type: null or boolean</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamecompareoptionsserversidediff","title":"applications.&lt;name&gt;.compareOptions.serverSideDiff","text":"<p>Sets ServerSideDiff compare option for the application. Leave as <code>null</code> for the default behavior.</p> <p>Type: null or boolean</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamecreatenamespace","title":"applications.&lt;name&gt;.createNamespace","text":"<p>Whether or not a namespace resource should be automatically created.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamedestinationserver","title":"applications.&lt;name&gt;.destination.server","text":"<p>The Kubernetes server that ArgoCD should deploy the application to.</p> <p>Type: string</p> <p>Default: <code>config.nixidy.defaults.destination.server</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleases","title":"applications.&lt;name&gt;.helm.releases","text":"<p>Helm releases to template and add to the rendered application's resources.</p> <p>Type: attribute set of (submodule)</p> <p>Default: <code>{ }</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/helm.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnamechart","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.chart","text":"<p>Derivation containing the helm chart for the release.</p> <p>Type: package or path</p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/helm.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnameincludecrds","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.includeCRDs","text":"<p>Whether or not to include CRDs in the helm release.</p> <p>Type: boolean</p> <p>Default: <code>true</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/helm.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnamename","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.name","text":"<p>Name of the helm release.</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/helm.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnamenamespace","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.namespace","text":"<p>Namespace for the release.</p> <p>Type: string</p> <p>Default: <code>config.applications.&lt;name&gt;.namespace</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/helm.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnametransformer","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.transformer","text":"<p>Function that will be applied to the list of rendered manifests after the helm templating.</p> <p>Type: function that evaluates to a(n) list of attribute set of anything</p> <p>Default: <code>config.nixidy.defaults.helm.transformer</code></p> <p>Example: <code>map (lib.kube.removeLabels [\"helm.sh/chart\"])</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/helm.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamehelmreleasesnamevalues","title":"applications.&lt;name&gt;.helm.releases.&lt;name&gt;.values","text":"<p>Values to pass to the helm chart when rendering it.</p> <p>Type: attribute set of anything</p> <p>Default: <code>{ }</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/helm.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamekustomizeapplications","title":"applications.&lt;name&gt;.kustomize.applications","text":"<p>Kustomize applications to render and add to the rendered application's resources.</p> <p>Type: attribute set of (submodule)</p> <p>Default: <code>{ }</code></p> <p>Example:</p> <pre><code>{\n  argocd = {\n    namespace = \"argocd\";\n    # Equivalent to `github.com/argoproj/argo-cd/manifests/cluster-install?ref=v2.9.3`\n    # in kustomization.yaml.\n    kustomization = {\n      src = pkgs.fetchFromGitHub {\n        owner = \"argoproj\";\n        repo = \"argo-cd\";\n        rev = \"v2.9.3\";\n        hash = \"sha256-GaY4Cw/LlSwy35umbB4epXt6ev8ya19UjHRwhDwilqU=\";\n      };\n      path = \"manifests/cluster-install\";\n    };\n  };\n};\n</code></pre> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/kustomize.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamekustomizeapplicationsnamekustomizationpath","title":"applications.&lt;name&gt;.kustomize.applications.&lt;name&gt;.kustomization.path","text":"<p>Path relative to the base of <code>src</code> to the entrypoint kustomization directory.</p> <p>Type: string</p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/kustomize.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamekustomizeapplicationsnamekustomizationsrc","title":"applications.&lt;name&gt;.kustomize.applications.&lt;name&gt;.kustomization.src","text":"<p>Derivation containing all the kustomize bases and overlays.</p> <p>Type: package</p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/kustomize.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamekustomizeapplicationsnamename","title":"applications.&lt;name&gt;.kustomize.applications.&lt;name&gt;.name","text":"<p>Name of the kustomize application.</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/kustomize.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamekustomizeapplicationsnamenamespace","title":"applications.&lt;name&gt;.kustomize.applications.&lt;name&gt;.namespace","text":"<p>Namespace for the kustomize application.</p> <p>Type: string</p> <p>Default: <code>config.applications.&lt;name&gt;.namespace</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/kustomize.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamekustomizeapplicationsnametransformer","title":"applications.&lt;name&gt;.kustomize.applications.&lt;name&gt;.transformer","text":"<p>Function that will be applied to the list of rendered manifests from kustomize.</p> <p>Type: function that evaluates to a(n) list of attribute set of anything</p> <p>Default: <code>config.nixidy.defaults.kustomize.transformer</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/kustomize.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamename","title":"applications.&lt;name&gt;.name","text":"<p>Name of the application.</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamenamespace","title":"applications.&lt;name&gt;.namespace","text":"<p>Namespace to deploy application into (defaults to name).</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnameoutputpath","title":"applications.&lt;name&gt;.output.path","text":"<p>Name of the folder that contains all rendered resources for the application. Relative to the root of the repository.</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnameproject","title":"applications.&lt;name&gt;.project","text":"<p>ArgoCD project to make application a part of.</p> <p>Type: string</p> <p>Default: <code>\"default\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnameresources","title":"applications.&lt;name&gt;.resources","text":"<p>Kubernetes resources for the application.</p> <p>The entire list of available resource options is too large for the current documentation setup but its usage is explained here.</p> <p>Type: attribute set</p> <p>Default: <code>{ }</code></p> <p>Example:</p> <pre><code>{\n  deployments = {\n    nginx = {\n      spec = {\n        replicas = 3;\n        selector = {\n          matchLabels = {\n            app = \"nginx\";\n          };\n        };\n        template = {\n          metadata = {\n            labels = {\n              app = \"nginx\";\n            };\n          };\n          spec = {\n            containers = {\n              nginx = {\n                image = \"nginx:1.25.1\";\n                imagePullPolicy = \"IfNotPresent\";\n              };\n            };\n            securityContext = {\n              fsGroup = 1000;\n            };\n          };\n        };\n      };\n    };\n  };\n  services = {\n    nginx = {\n      spec = {\n        ports = {\n          http = {\n            port = 80;\n          };\n        };\n        selector = {\n          app = \"nginx\";\n        };\n      };\n    };\n  };\n}\n</code></pre> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicyautosyncenabled","title":"applications.&lt;name&gt;.syncPolicy.autoSync.enabled","text":"<p>Specifies if application should automatically sync.</p> <p>Type: boolean</p> <p>Default: <code>config.nixidy.defaults.syncPolicy.autoSync.enabled</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicyautosyncprune","title":"applications.&lt;name&gt;.syncPolicy.autoSync.prune","text":"<p>Specifies if resources should be pruned during auto-syncing.</p> <p>Type: boolean</p> <p>Default: <code>config.nixidy.defaults.syncPolicy.autoSync.prune</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicyautosyncselfheal","title":"applications.&lt;name&gt;.syncPolicy.autoSync.selfHeal","text":"<p>Specifies if partial app sync should be executed when resources are changed only in target Kubernetes cluster and no git change detected.</p> <p>Type: boolean</p> <p>Default: <code>config.nixidy.defaults.syncPolicy.autoSync.selfHeal</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicysyncoptionsapplyoutofsynconly","title":"applications.&lt;name&gt;.syncPolicy.syncOptions.applyOutOfSyncOnly","text":"<p>Currently when syncing using auto sync Argo CD applies every object in the application. For applications containing thousands of objects this takes quite a long time and puts undue pressure on the api server. Turning on selective sync option which will sync only out-of-sync resources.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicysyncoptionsfailonsharedresource","title":"applications.&lt;name&gt;.syncPolicy.syncOptions.failOnSharedResource","text":"<p>By default, Argo CD will apply all manifests found in the git path configured in the Application regardless if the resources defined in the yamls are already applied by another Application. If the <code>failOnSharedResource</code> sync option is set, Argo CD will fail the sync whenever it finds a resource in the current Application that is already applied in the cluster by another Application.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicysyncoptionsprunelast","title":"applications.&lt;name&gt;.syncPolicy.syncOptions.pruneLast","text":"<p>This feature is to allow the ability for resource pruning to happen as a final, implicit wave of a sync operation, after the other resources have been deployed and become healthy, and after all other waves completed successfully.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicysyncoptionsreplace","title":"applications.&lt;name&gt;.syncPolicy.syncOptions.replace","text":"<p>By default, Argo CD executes <code>kubectl apply</code> operation to apply the configuration stored in Git. In some cases <code>kubectl apply</code> is not suitable. For example, resource spec might be too big and won't fit into <code>kubectl.kubernetes.io/last-applied-configuration</code> annotation that is added by kubectl apply.</p> <p>If the <code>replace = true;</code> sync option is set the Argo CD will use <code>kubectl replace</code> or <code>kubectl create</code> command to apply changes.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnamesyncpolicysyncoptionsserversideapply","title":"applications.&lt;name&gt;.syncPolicy.syncOptions.serverSideApply","text":"<p>By default, Argo CD executes <code>kubectl apply</code> operation to apply the configuration stored in Git. This is a client side operation that relies on <code>kubectl.kubernetes.io/last-applied-configuration</code> annotation to store the previous resource state.</p> <p>If <code>serverSideApply = true;</code> sync option is set, Argo CD will use <code>kubectl apply --server-side</code> command to apply changes.</p> <p>More info here.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications&gt;</li> </ul>"},{"location":"options/#applicationsnameyamls","title":"applications.&lt;name&gt;.yamls","text":"<p>List of Kubernetes manifests declared in YAML strings. They will be parsed and added to the application's <code>resources</code> where they can be overwritten and modified.</p> <p>Can be useful for reading existing YAML files (i.e. <code>[(builtins.readFile ./deployment.yaml)]</code>).</p> <p>Type: list of string</p> <p>Default: <code>[ ]</code></p> <p>Example:</p> <pre><code>[\n  ''\n    apiVersion: v1\n    kind: Namespace\n    metadata:\n      name: default\n''\n]\n</code></pre> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications/yamls.nix&gt;</li> </ul>"},{"location":"options/#nixidyappofappsname","title":"nixidy.appOfApps.name","text":"<p>Name of the application for bootstrapping all other applications (app of apps pattern).</p> <p>Type: string</p> <p>Default: <code>\"apps\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidyappofappsnamespace","title":"nixidy.appOfApps.namespace","text":"<p>Destination namespace for generated Argo CD Applications in the app of apps applications.</p> <p>Type: string</p> <p>Default: <code>\"argocd\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidybuildrevision","title":"nixidy.build.revision","text":"<p>The revision being built. Will be written to <code>.revision</code> in the environment destination directory.</p> <p>Type: null or string</p> <p>Default: <code>null</code></p> <p>Example: <code>if (self ? rev) then self.rev else self.dirtyRev</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidycharts","title":"nixidy.charts","text":"<p>Attrset of derivations containing helm charts. This will be passed as <code>charts</code> to every module.</p> <p>Type: attribute set of anything</p> <p>Default: <code>{ }</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidychartsdir","title":"nixidy.chartsDir","text":"<p>Path to a directory containing sub-directory structure that can be used to build a charts attrset. This will be passed as <code>charts</code> to every module.</p> <p>Type: null or path</p> <p>Default: <code>null</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidydefaultsdestinationserver","title":"nixidy.defaults.destination.server","text":"<p>The Kubernetes server that ArgoCD should deploy all applications to.</p> <p>This is the default value for all applications if not explicitly set for the application.</p> <p>Type: string</p> <p>Default: <code>\"https://kubernetes.default.svc\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidydefaultshelmtransformer","title":"nixidy.defaults.helm.transformer","text":"<p>Function that will be applied to the list of rendered manifests after the helm templating. This option applies to all helm releases in all applications unless explicitly specified there.</p> <p>Type: function that evaluates to a(n) list of attribute set of anything</p> <p>Default: <code>res: res</code></p> <p>Example: <code>map (lib.kube.removeLabels [\"helm.sh/chart\"])</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidydefaultskustomizetransformer","title":"nixidy.defaults.kustomize.transformer","text":"<p>Function that will be applied to the list of rendered manifests after kustomize rendering. This option applies to all kustomize applications in all nixidy applications unless explicitly specified there.</p> <p>Type: function that evaluates to a(n) list of attribute set of anything</p> <p>Default: <code>res: res</code></p> <p>Example: <code>map (lib.kube.removeLabels [\"app.kubernetes.io/version\"])</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidydefaultssyncpolicyautosyncenabled","title":"nixidy.defaults.syncPolicy.autoSync.enabled","text":"<p>Specifies if applications should automatically sync.</p> <p>This is the default value for all applications if not explicitly set for the application.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidydefaultssyncpolicyautosyncprune","title":"nixidy.defaults.syncPolicy.autoSync.prune","text":"<p>Specifies if resources should be pruned during auto-syncing.</p> <p>This is the default value for all applications if not explicitly set for the application.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidydefaultssyncpolicyautosyncselfheal","title":"nixidy.defaults.syncPolicy.autoSync.selfHeal","text":"<p>Specifies if partial app sync should be executed when resources are changed only in target Kubernetes cluster and no git change detected.</p> <p>This is the default value for all applications if not explicitly set for the application.</p> <p>Type: boolean</p> <p>Default: <code>false</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidyextrafiles","title":"nixidy.extraFiles","text":"<p>Extra files to write in the generated stage.</p> <p>Type: attribute set of (submodule)</p> <p>Default: <code>{ }</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidyextrafilesnamepath","title":"nixidy.extraFiles.&lt;name&gt;.path","text":"<p>Path of output file.</p> <p>Type: string</p> <p>Default: <code>\"\u2039name\u203a\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidyextrafilesnametext","title":"nixidy.extraFiles.&lt;name&gt;.text","text":"<p>Text of the output file.</p> <p>Type: strings concatenated with \"\\n\"</p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidyresourceimports","title":"nixidy.resourceImports","text":"<p>List of modules to import for resource defintion options.</p> <p>Type: list of (package or path or function that evaluates to a(n) (attribute set))</p> <p>Default: <code>[ ]</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/applications.nix&gt;</li> </ul>"},{"location":"options/#nixidytargetbranch","title":"nixidy.target.branch","text":"<p>The destination branch of the generated applications.</p> <p>Type: string</p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidytargetrepository","title":"nixidy.target.repository","text":"<p>The repository URL to put in all generated applications.</p> <p>Type: string</p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"options/#nixidytargetrootpath","title":"nixidy.target.rootPath","text":"<p>The root path of all generated applications in the repository.</p> <p>Type: string</p> <p>Default: <code>\"./\"</code></p> <p>Declared by:</p> <ul> <li>&lt;nixidy/modules/nixidy.nix&gt;</li> </ul>"},{"location":"user_guide/getting_started/","title":"Getting Started","text":"<p>Nixidy only supports Nix Flakes so that needs to be enabled.</p>"},{"location":"user_guide/getting_started/#initialize-repository","title":"Initialize Repository","text":"<p>First a <code>flake.nix</code> needs to be created in the root of the repository.</p> flake.nix<pre><code>{\n  description = \"My ArgoCD configuration with nixidy.\";\n\n  inputs.nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n  inputs.flake-utils.url = \"github:numtide/flake-utils\";\n  inputs.nixidy.url = \"github:arnarg/nixidy\";\n\n  outputs = {\n    self,\n    nixpkgs,\n    flake-utils,\n    nixidy,\n  }: (flake-utils.lib.eachDefaultSystem (system: let\n    pkgs = import nixpkgs {\n      inherit system;\n    };\n  in {\n    # This declares the available nixidy envs.\n    nixidyEnvs = nixidy.lib.mkEnvs {\n      inherit pkgs;\n\n      envs = {\n        # Currently we only have the one dev env.\n        dev.modules = [./env/dev.nix];\n      };\n    };\n\n    # Handy to have nixidy cli available in the local\n    # flake too.\n    packages.nixidy = nixidy.packages.${system}.default;\n\n    # Useful development shell with nixidy in path.\n    # Run `nix develop` to enter.\n    devShells.default = pkgs.mkShell {\n      buildInputs = [nixidy.packages.${system}.default];\n    };\n  }));\n}\n</code></pre> <p>The flake declares a single nixidy environment called <code>dev</code>. It includes a single nix module found at <code>./env/dev.nix</code>, so let's create that.</p> env/dev.nix<pre><code>{\n  # Set the target repository for the rendered manifests\n  # and applications.\n  # This should be replaced with yours, usually the same\n  # repository as the nixidy definitions.\n  nixidy.target.repository = \"https://github.com/arnarg/nixidy-demo.git\";\n\n  # Set the target branch the rendered manifests for _this_\n  # environment should be pushed to in the repository defined\n  # above.\n  nixidy.target.branch = \"main\";\n\n  # Set the target sub-directory to copy the generated\n  # manifests to when running `nixidy switch .#dev`.\n  nixidy.target.rootPath = \"./manifests/dev\";\n}\n</code></pre> <p>Now runnig <code>nix run .#nixidy -- info .#dev</code> (or simply <code>nixidy info .#dev</code> if run in nix shell using <code>nix develop</code>) you can get the same info we just declared above. This verifies that things are set up correctly so far.</p> <pre><code>&gt;&gt; nix run .#nixidy -- info .#dev\nRepository: https://github.com/arnarg/nixidy-demo.git\nBranch:     main\n</code></pre> <p>If we now attempt to build this new environment with <code>nix run .#nixidy -- build .#dev</code> we can see that nothing is generated but an empty folder called <code>apps</code>.</p> <pre><code>&gt;&gt; tree result\nresult\n\u2514\u2500\u2500 apps/\n</code></pre> <p>This is because we have not declared any applications yet for this environment.</p>"},{"location":"user_guide/getting_started/#our-first-application","title":"Our first Application","text":"<p>Applications and their resources are defined under <code>applications.&lt;applicationName&gt;</code>.</p> env/dev.nix<pre><code>{\n  # Set the target repository for the rendered manifests\n  # and applications.\n  # This should be replaced with yours, usually the same\n  # repository as the nixidy definitions.\n  nixidy.target.repository = \"https://github.com/arnarg/nixidy-demo.git\";\n\n  # Set the target branch the rendered manifests for _this_\n  # environment should be pushed to in the repository defined\n  # above.\n  nixidy.target.branch = \"main\";\n\n  # Set the target sub-directory to copy the generated\n  # manifests to when running `nixidy switch .#dev`.\n  nixidy.target.rootPath = \"./manifests/dev\";\n\n  # Define an application called `demo`.\n  applications.demo = {\n    # All resources will be deployed into this namespace.\n    namespace = \"demo\";\n\n    # Automatically generate a namespace resource for the\n    # above set namespace\n    createNamespace = true;\n\n    resources = let\n      labels = {\n        \"app.kubernetes.io/name\" = \"nginx\";\n      };\n    in {\n      # Define a deployment for running an nginx server\n      deployments.nginx.spec = {\n        selector.matchLabels = labels;\n        template = {\n          metadata.labels = labels;\n          spec = {\n            securityContext.fsGroup = 1000;\n            containers.nginx = {\n              image = \"nginx:1.25.1\";\n              imagePullPolicy = \"IfNotPresent\";\n              volumeMounts = {\n                \"/etc/nginx\".name = \"config\";\n                \"/var/lib/html\".name = \"static\";\n              };\n            };\n            volumes = {\n              config.configMap.name = \"nginx-config\";\n              static.configMap.name = \"nginx-static\";\n            };\n          };\n        };\n      };\n\n      # Define config maps with config for nginx\n      configMaps = {\n        nginx-config.data.\"nginx.conf\" = ''\n          user nginx nginx;\n          error_log /dev/stdout info;\n          pid /dev/null;\n          events {}\n          http {\n            access_log /dev/stdout;\n            server {\n              listen 80;\n              index index.html;\n              location / {\n                root /var/lib/html;\n              }\n            }\n          }\n        '';\n\n        nginx-static.data.\"index.html\" = ''\n          &lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello from NGINX&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\n        '';\n      };\n\n      # Define service for nginx\n      services.nginx.spec = {\n        selector = labels;\n        ports.http.port = 80;\n      };\n    };\n  };\n}\n</code></pre> <p>Running <code>nixidy build .#dev</code> will produce the following files.</p> <pre><code>tree -l result/\n\u251c\u2500\u2500 apps\n\u2502   \u2514\u2500\u2500 Application-demo.yaml\n\u2514\u2500\u2500 demo\n    \u251c\u2500\u2500 ConfigMap-nginx-config.yaml\n    \u251c\u2500\u2500 ConfigMap-nginx-static.yaml\n    \u251c\u2500\u2500 Deployment-nginx.yaml\n    \u251c\u2500\u2500 Namespace-demo.yaml\n    \u2514\u2500\u2500 Service-nginx.yaml\n</code></pre> <p>And the contents of the Argo CD application automatically generated is the following:</p> apps/Application-demo.yaml<pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n# This is the name of the application (`applications.demo`).\nname: demo\nnamespace: argocd\nspec:\ndestination:\n# This is the destination namespace for the application\n# specified with `applications.demo.namespace`.\nnamespace: demo\nserver: https://kubernetes.default.svc\nproject: default\nsource:\n# This is the output path declared for the application with\n# option `applications.&lt;applicationName&gt;.output.path`\n# (defaults to the name) with `nixidy.target.rootPath`\n# prefix.\npath: ./manifests/dev/demo\n# Repository specified in `nixidy.target.repository`.\nrepoURL: https://github.com/arnarg/nixidy-demo.git\n# Branch specified in `nixidy.target.branch`.\ntargetRevision: main\nsyncPolicy:\nautomated:\nprune: false\nselfHeal: false\n</code></pre> <p>A directory with rendered resources is generated for each application declared with <code>applications.&lt;name&gt;</code> as well as an Argo CD application resource YAML file in <code>apps/</code>. What this provides is the option to bootstrap the whole rendered branch to a cluster by adding an application pointing to the <code>apps/</code> folder.</p> <p>See App of Apps Pattern.</p> <p>Running <code>nixidy switch .#dev</code> will create the <code>./manifests/dev</code> relative to the current working directory and sync the newly generated manifests into it.</p>"},{"location":"user_guide/github_actions/","title":"GitHub Actions","text":"<p>Nixidy offers two GitHub Actions to build and switch to an environment.</p>"},{"location":"user_guide/github_actions/#arnargnixidyactionsbuild","title":"arnarg/nixidy/actions/build","text":"<p>This action will run <code>nixidy build</code> on a specified environment. It will not produce a <code>result</code> symlink and instead will have the output path in it's output <code>out-path</code>.</p>"},{"location":"user_guide/github_actions/#example","title":"Example","text":"<pre><code>name: Generate Kubernetes manifests\n\non:\npush:\nbranches:\n- main\npaths-ignore:\n- manifests/**\n\njobs:\ngenerate:\nruns-on: ubuntu-latest\nsteps:\n- uses: actions/checkout@v4\n\n- uses: cachix/install-nix-action@v20\nwith:\nextra_nix_config: |\nextra-experimental-features = nix-command flakes\n\n- uses: DeterminateSystems/magic-nix-cache-action@v7\n\n- uses: arnarg/nixidy/actions/build@main\nid: build\nwith:\nenvironment: .#dev\n\n- shell: bash\nrun: |\nrsync --recursive --delete '${{steps.build.outputs.out-path}}/' manifests\n\n- uses: EndBug/add-and-commit@v9\nid: commit\nwith:\ndefault_author: github_actions\nmessage: \"chore: promote to dev ${{github.sha}}\"\nfetch: false\nnew_branch: promote/env/dev\npush: --set-upstream origin promote/env/dev --force\n\n- uses: thomaseizinger/create-pull-request@1.4.0\nif: ${{ steps.commit.outputs.pushed == 'true' }}\nwith:\ngithub_token: ${{github.token}}\nhead: promote/env/dev\nbase: main\ntitle: \"chore: promote to dev ${{github.sha}}\"\n</code></pre>"},{"location":"user_guide/github_actions/#arnargnixidyactionsswitch","title":"arnarg/nixidy/actions/switch","text":"<p>This action will run <code>nixidy switch</code> on a specified environment.</p>"},{"location":"user_guide/github_actions/#example_1","title":"Example","text":"<pre><code>name: Generate Kubernetes manifests\n\non:\npush:\nbranches:\n- main\npaths-ignore:\n- manifests/**\n\njobs:\ngenerate:\nruns-on: ubuntu-latest\nsteps:\n- uses: actions/checkout@v4\n\n- uses: cachix/install-nix-action@v20\nwith:\nextra_nix_config: |\nextra-experimental-features = nix-command flakes\n\n- uses: DeterminateSystems/magic-nix-cache-action@v7\n\n- uses: arnarg/nixidy/actions/switch@main\nwith:\nenvironment: .#dev\n\n- uses: EndBug/add-and-commit@v9\nid: commit\nwith:\ndefault_author: github_actions\nmessage: \"chore: promote to dev ${{github.sha}}\"\nfetch: false\nnew_branch: promote/env/dev\npush: --set-upstream origin promote/env/dev --force\n\n- uses: thomaseizinger/create-pull-request@1.4.0\nif: ${{ steps.commit.outputs.pushed == 'true' }}\nwith:\ngithub_token: ${{github.token}}\nhead: promote/env/dev\nbase: main\ntitle: \"chore: promote to dev ${{github.sha}}\"\n</code></pre>"},{"location":"user_guide/helm_charts/","title":"Using Helm Charts","text":"<p>For better or for worse majority of software that's deployable to Kubernetes is packaged using Helm by developers or its community. It would be a waste not to use them and having to define all of its manifest yourself in nixidy.</p>"},{"location":"user_guide/helm_charts/#adding-a-helm-release-as-part-of-an-application","title":"Adding a Helm release as part of an application","text":"<p>Nixidy supports rendering Helm charts as part of applications. This can be done by specifying <code>applications.&lt;applicationName&gt;.helm.releases.&lt;releaseName&gt;</code>.</p>"},{"location":"user_guide/helm_charts/#example","title":"Example","text":"<pre><code>{lib, ...}: {\n  applications.traefik = {\n    namespace = \"traefik\";\n    createNamespace = true;\n\n    helm.releases.traefik = {\n      # Use `lib.helm.downloadHelmChart` to fetch\n      # the Helm Chart to use.\n      chart = lib.helm.downloadHelmChart {\n        repo = \"https://traefik.github.io/charts/\";\n        chart = \"traefik\";\n        version = \"25.0.0\";\n        chartHash = \"sha256-ua8KnUB6MxY7APqrrzaKKSOLwSjDYkk9tfVkb1bqkVM=\";\n      };\n\n      # Example values to pass to the Helm Chart.\n      values = {\n        ingressClass.enabled = true;\n      };\n    };\n  };\n}\n</code></pre>"},{"location":"user_guide/helm_charts/#patching-manifests-rendered-by-helm","title":"Patching manifests rendered by Helm","text":"<p>In some cases the Helm Chart doesn't support changing certain aspects of the final manifests. These can be modified to nixidy by overriding certain fields.</p>"},{"location":"user_guide/helm_charts/#example_1","title":"Example","text":"<pre><code>{lib, ...}: {\n  applications.traefik = {\n    namespace = \"traefik\";\n    createNamespace = true;\n\n    helm.releases.traefik = {\n      # Use `lib.helm.downloadHelmChart` to fetch\n      # the Helm Chart to use.\n      chart = lib.helm.downloadHelmChart {\n        repo = \"https://traefik.github.io/charts/\";\n        chart = \"traefik\";\n        version = \"25.0.0\";\n        chartHash = \"sha256-ua8KnUB6MxY7APqrrzaKKSOLwSjDYkk9tfVkb1bqkVM=\";\n      };\n\n      # Example values to pass to the Helm Chart.\n      values = {\n        ingressClass.enabled = true;\n      };\n    };\n\n    resources = {\n      # Add a label to the traefik pod and change\n      # the image.\n      deployments.traefik.spec.template = {\n        metadata.labels.my-custom-label = \"my-custom-values\";\n        spec.containers.traefik.image = lib.mkForce \"my-registry.io/patched-traefik:v3.0.0\";\n      };\n    };\n  };\n}\n</code></pre>"},{"location":"user_guide/transformers/","title":"Transformers","text":"<p>Nixidy supports adding a transformers to Helm releases and Kustomize applications. A transformer is only a function that takes in a list of Kubernetes manifests in attribute sets and returns the same (<code>[AttrSet] -&gt; [AttrSet]</code>). It is called after the manifests have been rendered and parsed into nix but before they're transformed into the nixidy form (<code>&lt;group&gt;.&lt;version&gt;.&lt;kind&gt;.&lt;name&gt;</code>) and can be used to modify the resources.</p> <p>Transformers can be set globally in <code>nixidy.defaults.helm.transformer</code> for Helm releases and <code>nixidy.defaults.kustomize.transformer</code> for kustomize applications.</p>"},{"location":"user_guide/transformers/#remove-version-specific-labels","title":"Remove Version Specific Labels","text":"<p>It's very common that helm charts will add the labels <code>helm.sh/chart</code> and <code>app.kubernetes.io/version</code> to all resources it renders. This can produce very big diffs when they're updated and nixidy renders them and commits the manifests to a git branch. The changes in these labels are not very relevant and will mostly just be noise to distract from the actual relevant changes of the rendered output.</p> <p>A transformer can be used to filter out these labels.</p> <pre><code>{\n  applications.argocd.helm.releases.argocd = {\n    # ...\n\n    # Remove the following labels from all manifests\n    transformer = map (lib.kube.removeLabels [\n      \"app.kubernetes.io/version\"\n      \"helm.sh/chart\"\n    ]);\n  }\n}\n</code></pre> <p>Here we use map to call <code>lib.kube.removeLabels</code> on each manifest in the list to remove the specified labels. The example uses function currying, this is equivalent to <code>manifests: map (m: lib.kube.removeLabels [\"...\"] m) manifests</code>.</p>"},{"location":"user_guide/typed_resources/","title":"Typed Resource Options","text":"<p>Kubenix has done a great work with generating nix options definitions from official json schemas and nixidy builds on top of this.</p> <p>All core Kubernetes resources are imported by default in nixidy along with Argo CD's <code>Application</code> and <code>AppProject</code>. Every resource can be defined under <code>applications.&lt;applicationName&gt;.resources.&lt;group&gt;.&lt;version&gt;.&lt;kind&gt;</code> but is also offered as an alias <code>applications.&lt;applicationName&gt;.resources.&lt;attrName&gt;</code> where <code>&lt;attrName&gt;</code> is the plural form of the kind in camelCase.</p> <p>For example:</p> <ul> <li><code>resources.core.v1.Service</code> -&gt; <code>resources.services</code></li> <li><code>resources.\"networking.k8s.io\".v1.NetworkPolicy</code> -&gt; <code>resources.networkPolicies</code></li> </ul> <p>The lack of availability of typed resource options only hinders the ability to define the resources in nix. Any manifests that are rendered from a Helm Chart or defined in <code>applications.&lt;applicationName&gt;.yamls</code> and do not have defined resource options for that group, version and kind will go straight to the output for the application and can not be patched by nixidy.</p>"},{"location":"user_guide/typed_resources/#generating-your-own-resource-options-from-crds","title":"Generating your own resource options from CRDs","text":"<p>Thankfully a code generator for generating resource options from CRDs is provided by nixidy (this is based heavily on kubenix's code generator).</p> <p>As an example, to generate resource options for Cilium's <code>CiliumNetworkPolicy</code> and <code>CiliumClusterwideNetworkPolicy</code> the following can be defined in <code>flake.nix</code>.</p> flake.nix<pre><code>{\n  description = \"My ArgoCD configuration with nixidy.\";\n\n  inputs.nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n  inputs.flake-utils.url = \"github:numtide/flake-utils\";\n\n  inputs.nixidy = {\n    url = \"github:arnarg/nixidy\";\n    inputs.nixpkgs.follows = \"nixpkgs\";\n  };\n\n  outputs = {\n    self,\n    nixpkgs,\n    flake-utils,\n    nixidy,\n  }: (flake-utils.lib.eachDefaultSystem (system: let\n    pkgs = import nixpkgs {\n      inherit system;\n    };\n  in {\n    packages = {\n      generators.cilium = nixidy.packages.${system}.generators.fromCRD {\n        name = \"cilium\";\n        src = pkgs.fetchFromGitHub {\n          owner = \"cilium\";\n          repo = \"cilium\";\n          rev = \"v1.15.6\";\n          hash = \"sha256-oC6pjtiS8HvqzzRQsE+2bm6JP7Y3cbupXxCKSvP6/kU=\";\n        };\n        crds = [\n          \"pkg/k8s/apis/cilium.io/client/crds/v2/ciliumnetworkpolicies.yaml\"\n          \"pkg/k8s/apis/cilium.io/client/crds/v2/ciliumclusterwidenetworkpolicies.yaml\"\n        ];\n      };\n    };\n  }));\n}\n</code></pre> <p>Then running <code>nix build .#generators.cilium</code> will produce a nix file that can be copied into place in your repository. After that the generated file has to be added to <code>nixidy.resourceImports</code> in your nixidy modules.</p> env/dev.nix<pre><code>{\n  nixidy.resourceImports = [\n    ./generated/cilium.nix\n  ];\n}\n</code></pre>"},{"location":"user_guide/using_nixhelm/","title":"Using nixhelm","text":"<p>nixhelm is a collection of Helm Charts that can be used with nix-kube-generators and therefore also nixidy. The charts are automatically updated to the most recent version by CI regularly.</p> <p>To use with nixidy the nixhelm derivation attribute set can be passed to nixidy's <code>mkEnv</code> builder like so.</p> flake.nix<pre><code>{\n  description = \"My ArgoCD configuration with nixidy.\";\n\n  inputs.nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n  inputs.flake-utils.url = \"github:numtide/flake-utils\";\n\n  inputs.nixidy = {\n    url = \"github:arnarg/nixidy\";\n    inputs.nixpkgs.follows = \"nixpkgs\";\n  };\n\n  inputs.nixhelm = {\n    url = \"github:farcaller/nixhelm\";\n    inputs.nixpkgs.follows = \"nixpkgs\";\n  };\n\n  outputs = {\n    self,\n    nixpkgs,\n    flake-utils,\n    nixidy,\n    nixhelm,\n  }: (flake-utils.lib.eachDefaultSystem (system: let\n    pkgs = import nixpkgs {\n      inherit system;\n    };\n  in {\n    nixidyEnvs.dev = nixidy.lib.mkEnv {\n      inherit pkgs;\n\n      # Pass nixhelm to all nixidy modules.\n      charts = nixhelm.chartsDerivations.${system};\n\n      modules = [./env/dev.nix];\n    };\n  }));\n}\n</code></pre> <p>And then the argument <code>charts</code> will be passed to every module in nixidy.</p> ./env/dev.nix<pre><code>{\n  lib,\n  charts,\n  ...\n}: {\n  applications.traefik = {\n    namespace = \"traefik\";\n    createNamespace = true;\n\n    helm.releases.traefik = {\n      # Use the traefik helm chart from nixhelm.\n      chart = charts.traefik.traefik;\n\n      # Example values to pass to the Helm Chart.\n      values = {\n        ingressClass.enabled = true;\n      };\n    };\n  };\n}\n</code></pre>"},{"location":"user_guide/using_nixhelm/#provide-your-own-charts-not-available-in-nixhelm","title":"Provide your own charts not available in nixhelm","text":"<p>Not all charts are available in nixhelm and in such cases you can contribute an initial version to them or setup a special folder structure locally to merge with the <code>charts</code> argument passed to modules.</p> <p>With the nixidy option <code>nixidy.chartsDir</code> that folder will be walked recursively and look for <code>default.nix</code> files that will build up the charts attribute set.</p> ./charts/kubernetes-csi/csi-driver-nfs/default.nix<pre><code>{\n  repo = \"https://raw.githubusercontent.com/kubernetes-csi/csi-driver-nfs/master/charts\";\n  chart = \"csi-driver-nfs\";\n  version = \"4.7.0\";\n  chartHash = \"sha256-EU2qaZglUU3vxa41l1p/2yBscksIhYMr8kSgH8t0vL8=\";\n}\n</code></pre> <p>And then in your nixidy modules you pass that <code>./charts</code> folder to <code>nixidy.chartsDir</code>.</p> ./env/dev.nix<pre><code>{charts, ...}: {\n  # Point nixidy to a directory with charts to add to\n  # the charts attribute set.\n  nixidy.chartsDir = ../charts;\n\n  # Use the nfs chart in an application.\n  applications.csi-driver-nfs = {\n    namespace = \"kube-system\";\n\n    helm.releases.csi-driver-nfs = {\n      chart = charts.kubernetes-csi.csi-driver-nfs;\n\n      # Pass some values overrides to the chart.\n      values = {};\n    };\n  };\n}\n</code></pre>"}]}